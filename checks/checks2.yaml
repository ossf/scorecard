# Copyright 2021 Security Scorecard Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This is the source of truth for all check descriptions and remediation steps.
# Run `cd checks/main && go run /main` to generate `checks.json` and `checks.md`.
checks:
  Active:
    risk: High
    description: >-
      This check tries to determine if the project is "actively maintained".

      A project which is not active may not be patched, may not have its
      dependencies patched, or may not be actively tested and used. 
      A low score is therefore considered `High` risk.
      
      The check currently works by looking for commits within the last 90 days, and
      outputs the highest score if there are at least 1 commit/week during this period.
    remediation:
      - >-
        There is *NO* remediation work needed here. This is just to indicate
        your project activity and maintenance commitment.
  Binary-Artifacts:
    risk: High
    description: >-
      This check tries to determine if a project has binary artifacts in the source repository.

      Binaries are a threat to auditability and vulnerability management. 
      In addition, a binary could be compromised or malicious. 
      A low score is therefore considered `High` risk.
    remediation:
      - >-
        Remove the binary artifacts from the repository. 
      - >-
        Build from source.
  Automatic-Dependency-Update:
    risk: High
    description: >-
      This check tries to determine if a project has dependencies automatically updated.

      Not updating dependencies makes a project vulnerable to known flaws and prone to attacks. 
      A low score is therefore considered `High` risk.

      The checks looks for [dependabot](https://dependabot.com/docs/config-file/) or
      [renovatebot](https://docs.renovatebot.com/configuration-options/). This check only looks if 
      it is enabled and does not ensure that it is run and pull requests are merged.
      
    remediation:
      - >-
        Signup for automatic dependency updates with dependabot or renovatebot and place the config
        file in the locations that are recommended by these tools.
  Code-Review:
    risk: High
    description: >-
      This check tries to determine if a project requires code review before
      pull requests are merged. 

      Reviewing code improves quality of code in general. In addition, it ensures
      compromised contributors cannot intentionally inject malicious code. A low
      score is therefore considered `High` risk.
      
      The check first tries to detect if branch-Protection is enabled
      on the default branch and the number of reviewers is at least 1. If this
      fails, it checks if the recent (~30) commits have a Github-approved
      review or if the merger is different from the committer (implicit review).
      It also performs similar check for reviews using 
      [Prow](https://github.com/kubernetes/test-infra/tree/master/prow#readme)
      (labels "lgtm" or "approved") and Gerrit ("Reviewed-on" and "Reviewed-by").
    remediation:
      - >-
        Follow security best practices by performing strict code reviews for
        every new pull request.
      - >-
        Make "code reviews" mandatory in your repository configuration. E.g.
        [GitHub](https://docs.github.com/en/github/administering-a-repository/about-protected-branches#require-pull-request-reviews-before-merging).
      - >-
        Enforce the rule for administrators / code owners as well. E.g.
        [GitHub](https://docs.github.com/en/github/administering-a-repository/about-protected-branches#include-administrators)
  Branch-Protection:
    risk: High
    description: >-
      Branch protection allows defining rules to enforce certain workflows for
      branches, such as requiring a review or passing certain status checks.

      Branch protection ensures compromised contributors cannot 
      intentionally inject malicious code. A low score is therefore considered `High` risk.
      
      This check determines if the default and release branches are
      protected with GitHub's branch protection settings.
      The check only works when the token has [Admin
      access](https://github.community/t/enable-branch-protection-get-api-without-admin/14197)
      to the repository. This check determines if the default and release branches are
      protected.
    remediation:
      - >-
        Enable branch protection settings in your source hosting provider to
        avoid force pushes or deletion of your important branches.
      - >-
        For GitHub, check out the steps
        [here](https://docs.github.com/en/github/administering-a-repository/managing-a-branch-protection-rule).
  Frozen-Deps:
    risk: Medium
    description: >-
      This check tries to determine if a project has declared and pinned its
      dependencies. 
      
      Pinning dependencies is important to mitigate compromised dependencies
      from undermining the security of the project. Low score is therefore considered
      `Medium` risk.

      The checks works by (1) looking for the following files in the root
      directory: go.mod, go.sum (Golang), package-lock.json, npm-shrinkwrap.json
      (Javascript),  requirements.txt, pipfile.lock (Python), gemfile.lock
      (Ruby), cargo.lock (Rust), yarn.lock (package manager), composer.lock
      (PHP), vendor/, third_party/, third-party/; (2) looks for 
      unpinned dependencies in Dockerfiles, shell scripts and GitHub workflows. 
    remediation:
      - >-
        Declare all your dependencies with specific versions in your package
        format file (e.g. `package.json` for npm, `requirements.txt` for
        python). For C/C++, check in the code from a trusted source and add a
        `README` on the specific version used (and the archive SHA hashes).
      - >-
        If the package manager supports lock files (e.g. `package-lock.json` for
        npm), make sure to check these in the source code as well. These files
        maintain signatures for the entire dependency tree and saves from future
        exploitation in case the package is compromised.
      - >-
        For Dockerfiles and github workflows, pin dependencies by hash. See example
        [gitcache-docker.yaml](https://github.com/ossf/scorecard/blob/main/.github/workflows/gitcache-docker.yaml#L36)
        and [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/worker/Dockerfile) examples.
      - >-
        To help update your dependencies after pinning them, use tools such as 
        Github's [dependabot](https://github.blog/2020-06-01-keep-all-your-packages-up-to-date-with-dependabot/)
        or [renovate bot](https://github.com/renovatebot/renovate).