// Code generated from Java20Parser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package java20 // Java20Parser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Java20Parser struct {
	*antlr.BaseParser
}

var Java20ParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func java20parserParserInit() {
	staticData := &Java20ParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'exports'", "'module'", "'non-sealed'", "'<>'", "'open'", "'opens'",
		"'permits'", "'provides'", "'record'", "'requires'", "'sealed'", "'to'",
		"'transitive'", "'uses'", "'var'", "'with'", "'yield'", "'abstract'",
		"'assert'", "'boolean'", "'break'", "'byte'", "'case'", "'catch'", "'char'",
		"'class'", "'const'", "'continue'", "'default'", "'do'", "'double'",
		"'else'", "'enum'", "'extends'", "'final'", "'finally'", "'float'",
		"'for'", "'if'", "'goto'", "'implements'", "'import'", "'instanceof'",
		"'int'", "'interface'", "'long'", "'native'", "'new'", "'package'",
		"'private'", "'protected'", "'public'", "'return'", "'short'", "'static'",
		"'strictfp'", "'super'", "'switch'", "'synchronized'", "'this'", "'throw'",
		"'throws'", "'transient'", "'try'", "'void'", "'volatile'", "'while'",
		"'_'", "", "", "", "", "", "", "'null'", "'('", "')'", "'{'", "'}'",
		"'['", "']'", "';'", "','", "'.'", "'...'", "'@'", "'::'", "'='", "'>'",
		"'<'", "'!'", "'~'", "'?'", "':'", "'->'", "'=='", "'<='", "'>='", "'!='",
		"'&&'", "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", "'/'", "'&'", "'|'",
		"'^'", "'%'", "'+='", "'-='", "'*='", "'/='", "'&='", "'|='", "'^='",
		"'%='", "'<<='", "'>>='", "'>>>='",
	}
	staticData.SymbolicNames = []string{
		"", "EXPORTS", "MODULE", "NONSEALED", "OACA", "OPEN", "OPENS", "PERMITS",
		"PROVIDES", "RECORD", "REQUIRES", "SEALED", "TO", "TRANSITIVE", "USES",
		"VAR", "WITH", "YIELD", "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", "BYTE",
		"CASE", "CATCH", "CHAR", "CLASS", "CONST", "CONTINUE", "DEFAULT", "DO",
		"DOUBLE", "ELSE", "ENUM", "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR",
		"IF", "GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INT", "INTERFACE",
		"LONG", "NATIVE", "NEW", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC",
		"RETURN", "SHORT", "STATIC", "STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED",
		"THIS", "THROW", "THROWS", "TRANSIENT", "TRY", "VOID", "VOLATILE", "WHILE",
		"UNDER_SCORE", "IntegerLiteral", "FloatingPointLiteral", "BooleanLiteral",
		"CharacterLiteral", "StringLiteral", "TextBlock", "NullLiteral", "LPAREN",
		"RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", "COMMA", "DOT",
		"ELLIPSIS", "AT", "COLONCOLON", "ASSIGN", "GT", "LT", "BANG", "TILDE",
		"QUESTION", "COLON", "ARROW", "EQUAL", "LE", "GE", "NOTEQUAL", "AND",
		"OR", "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", "CARET",
		"MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN",
		"OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN",
		"URSHIFT_ASSIGN", "Identifier", "WS", "COMMENT", "LINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"start_", "identifier", "typeIdentifier", "unqualifiedMethodIdentifier",
		"contextualKeyword", "contextualKeywordMinusForTypeIdentifier", "contextualKeywordMinusForUnqualifiedMethodIdentifier",
		"literal", "primitiveType", "numericType", "integralType", "floatingPointType",
		"referenceType", "coit", "classOrInterfaceType", "classType", "interfaceType",
		"typeVariable", "arrayType", "dims", "typeParameter", "typeParameterModifier",
		"typeBound", "additionalBound", "typeArguments", "typeArgumentList",
		"typeArgument", "wildcard", "wildcardBounds", "moduleName", "packageName",
		"typeName", "packageOrTypeName", "expressionName", "methodName", "ambiguousName",
		"compilationUnit", "ordinaryCompilationUnit", "modularCompilationUnit",
		"packageDeclaration", "packageModifier", "importDeclaration", "singleTypeImportDeclaration",
		"typeImportOnDemandDeclaration", "singleStaticImportDeclaration", "staticImportOnDemandDeclaration",
		"topLevelClassOrInterfaceDeclaration", "moduleDeclaration", "moduleDirective",
		"requiresModifier", "classDeclaration", "normalClassDeclaration", "classModifier",
		"typeParameters", "typeParameterList", "classExtends", "classImplements",
		"interfaceTypeList", "classPermits", "classBody", "classBodyDeclaration",
		"classMemberDeclaration", "fieldDeclaration", "fieldModifier", "variableDeclaratorList",
		"variableDeclarator", "variableDeclaratorId", "variableInitializer",
		"unannType", "unannPrimitiveType", "unannReferenceType", "unannClassOrInterfaceType",
		"uCOIT", "unannClassType", "unannInterfaceType", "unannTypeVariable",
		"unannArrayType", "methodDeclaration", "methodModifier", "methodHeader",
		"result", "methodDeclarator", "receiverParameter", "formalParameterList",
		"formalParameter", "variableArityParameter", "variableModifier", "throwsT",
		"exceptionTypeList", "exceptionType", "methodBody", "instanceInitializer",
		"staticInitializer", "constructorDeclaration", "constructorModifier",
		"constructorDeclarator", "simpleTypeName", "constructorBody", "explicitConstructorInvocation",
		"enumDeclaration", "enumBody", "enumConstantList", "enumConstant", "enumConstantModifier",
		"enumBodyDeclarations", "recordDeclaration", "recordHeader", "recordComponentList",
		"recordComponent", "variableArityRecordComponent", "recordComponentModifier",
		"recordBody", "recordBodyDeclaration", "compactConstructorDeclaration",
		"interfaceDeclaration", "normalInterfaceDeclaration", "interfaceModifier",
		"interfaceExtends", "interfacePermits", "interfaceBody", "interfaceMemberDeclaration",
		"constantDeclaration", "constantModifier", "interfaceMethodDeclaration",
		"interfaceMethodModifier", "annotationInterfaceDeclaration", "annotationInterfaceBody",
		"annotationInterfaceMemberDeclaration", "annotationInterfaceElementDeclaration",
		"annotationInterfaceElementModifier", "defaultValue", "annotation",
		"normalAnnotation", "elementValuePairList", "elementValuePair", "elementValue",
		"elementValueArrayInitializer", "elementValueList", "markerAnnotation",
		"singleElementAnnotation", "arrayInitializer", "variableInitializerList",
		"block", "blockStatements", "blockStatement", "localClassOrInterfaceDeclaration",
		"localVariableDeclaration", "localVariableType", "localVariableDeclarationStatement",
		"statement", "statementNoShortIf", "statementWithoutTrailingSubstatement",
		"emptyStatement_", "labeledStatement", "labeledStatementNoShortIf",
		"expressionStatement", "statementExpression", "ifThenStatement", "ifThenElseStatement",
		"ifThenElseStatementNoShortIf", "assertStatement", "switchStatement",
		"switchBlock", "switchRule", "switchBlockStatementGroup", "switchLabel",
		"caseConstant", "whileStatement", "whileStatementNoShortIf", "doStatement",
		"forStatement", "forStatementNoShortIf", "basicForStatement", "basicForStatementNoShortIf",
		"forInit", "forUpdate", "statementExpressionList", "enhancedForStatement",
		"enhancedForStatementNoShortIf", "breakStatement", "continueStatement",
		"returnStatement", "throwStatement", "synchronizedStatement", "tryStatement",
		"catches", "catchClause", "catchFormalParameter", "catchType", "finallyBlock",
		"tryWithResourcesStatement", "resourceSpecification", "resourceList",
		"resource", "variableAccess", "yieldStatement", "pattern", "typePattern",
		"expression", "primary", "primaryNoNewArray", "pNNA", "classLiteral",
		"classInstanceCreationExpression", "unqualifiedClassInstanceCreationExpression",
		"classOrInterfaceTypeToInstantiate", "typeArgumentsOrDiamond", "arrayCreationExpression",
		"arrayCreationExpressionWithoutInitializer", "arrayCreationExpressionWithInitializer",
		"dimExprs", "dimExpr", "arrayAccess", "fieldAccess", "methodInvocation",
		"argumentList", "methodReference", "postfixExpression", "pfE", "postIncrementExpression",
		"postDecrementExpression", "unaryExpression", "preIncrementExpression",
		"preDecrementExpression", "unaryExpressionNotPlusMinus", "castExpression",
		"multiplicativeExpression", "additiveExpression", "shiftExpression",
		"relationalExpression", "equalityExpression", "andExpression", "exclusiveOrExpression",
		"inclusiveOrExpression", "conditionalAndExpression", "conditionalOrExpression",
		"conditionalExpression", "assignmentExpression", "assignment", "leftHandSide",
		"assignmentOperator", "lambdaExpression", "lambdaParameters", "lambdaParameterList",
		"lambdaParameter", "lambdaParameterType", "lambdaBody", "switchExpression",
		"constantExpression",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 126, 2970, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 504, 8, 1, 1, 2, 1, 2,
		3, 2, 508, 8, 2, 1, 3, 1, 3, 3, 3, 512, 8, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1,
		6, 1, 6, 1, 7, 1, 7, 1, 8, 5, 8, 523, 8, 8, 10, 8, 12, 8, 526, 9, 8, 1,
		8, 1, 8, 3, 8, 530, 8, 8, 1, 9, 1, 9, 3, 9, 534, 8, 9, 1, 10, 1, 10, 1,
		11, 1, 11, 1, 12, 1, 12, 1, 12, 3, 12, 543, 8, 12, 1, 13, 1, 13, 5, 13,
		547, 8, 13, 10, 13, 12, 13, 550, 9, 13, 1, 13, 1, 13, 3, 13, 554, 8, 13,
		1, 13, 3, 13, 557, 8, 13, 1, 14, 1, 14, 1, 14, 3, 14, 562, 8, 14, 1, 14,
		5, 14, 565, 8, 14, 10, 14, 12, 14, 568, 9, 14, 1, 14, 1, 14, 3, 14, 572,
		8, 14, 1, 14, 3, 14, 575, 8, 14, 1, 15, 5, 15, 578, 8, 15, 10, 15, 12,
		15, 581, 9, 15, 1, 15, 1, 15, 3, 15, 585, 8, 15, 1, 15, 1, 15, 1, 15, 5,
		15, 590, 8, 15, 10, 15, 12, 15, 593, 9, 15, 1, 15, 1, 15, 3, 15, 597, 8,
		15, 1, 15, 1, 15, 1, 15, 5, 15, 602, 8, 15, 10, 15, 12, 15, 605, 9, 15,
		1, 15, 1, 15, 3, 15, 609, 8, 15, 3, 15, 611, 8, 15, 1, 16, 1, 16, 1, 17,
		5, 17, 616, 8, 17, 10, 17, 12, 17, 619, 9, 17, 1, 17, 1, 17, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 632, 8, 18,
		1, 19, 5, 19, 635, 8, 19, 10, 19, 12, 19, 638, 9, 19, 1, 19, 1, 19, 1,
		19, 5, 19, 643, 8, 19, 10, 19, 12, 19, 646, 9, 19, 1, 19, 1, 19, 5, 19,
		650, 8, 19, 10, 19, 12, 19, 653, 9, 19, 1, 20, 5, 20, 656, 8, 20, 10, 20,
		12, 20, 659, 9, 20, 1, 20, 1, 20, 3, 20, 663, 8, 20, 1, 21, 1, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 5, 22, 671, 8, 22, 10, 22, 12, 22, 674, 9, 22, 3,
		22, 676, 8, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25,
		1, 25, 1, 25, 5, 25, 688, 8, 25, 10, 25, 12, 25, 691, 9, 25, 1, 26, 1,
		26, 3, 26, 695, 8, 26, 1, 27, 5, 27, 698, 8, 27, 10, 27, 12, 27, 701, 9,
		27, 1, 27, 1, 27, 3, 27, 705, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28,
		711, 8, 28, 1, 29, 1, 29, 1, 29, 3, 29, 716, 8, 29, 1, 30, 1, 30, 1, 30,
		3, 30, 721, 8, 30, 1, 31, 1, 31, 1, 31, 3, 31, 726, 8, 31, 1, 32, 1, 32,
		1, 32, 3, 32, 731, 8, 32, 1, 33, 1, 33, 1, 33, 3, 33, 736, 8, 33, 1, 33,
		1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 3, 35, 745, 8, 35, 1, 36, 1,
		36, 3, 36, 749, 8, 36, 1, 37, 3, 37, 752, 8, 37, 1, 37, 5, 37, 755, 8,
		37, 10, 37, 12, 37, 758, 9, 37, 1, 37, 5, 37, 761, 8, 37, 10, 37, 12, 37,
		764, 9, 37, 1, 38, 5, 38, 767, 8, 38, 10, 38, 12, 38, 770, 9, 38, 1, 38,
		1, 38, 1, 39, 5, 39, 775, 8, 39, 10, 39, 12, 39, 778, 9, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 5, 39, 784, 8, 39, 10, 39, 12, 39, 787, 9, 39, 1, 39,
		1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 797, 8, 41, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 3, 46, 826, 8, 46, 1, 47, 5, 47,
		829, 8, 47, 10, 47, 12, 47, 832, 9, 47, 1, 47, 3, 47, 835, 8, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 5, 47, 841, 8, 47, 10, 47, 12, 47, 844, 9, 47, 1,
		47, 1, 47, 5, 47, 848, 8, 47, 10, 47, 12, 47, 851, 9, 47, 1, 47, 1, 47,
		1, 48, 1, 48, 5, 48, 857, 8, 48, 10, 48, 12, 48, 860, 9, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 871, 8, 48,
		10, 48, 12, 48, 874, 9, 48, 3, 48, 876, 8, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 886, 8, 48, 10, 48, 12, 48, 889,
		9, 48, 3, 48, 891, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 905, 8, 48, 10, 48, 12, 48,
		908, 9, 48, 1, 48, 1, 48, 3, 48, 912, 8, 48, 1, 49, 1, 49, 1, 50, 1, 50,
		1, 50, 3, 50, 919, 8, 50, 1, 51, 5, 51, 922, 8, 51, 10, 51, 12, 51, 925,
		9, 51, 1, 51, 1, 51, 1, 51, 3, 51, 930, 8, 51, 1, 51, 3, 51, 933, 8, 51,
		1, 51, 3, 51, 936, 8, 51, 1, 51, 3, 51, 939, 8, 51, 1, 51, 1, 51, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 953,
		8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 5, 54, 962, 8,
		54, 10, 54, 12, 54, 965, 9, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56,
		1, 57, 1, 57, 1, 57, 5, 57, 976, 8, 57, 10, 57, 12, 57, 979, 9, 57, 1,
		58, 1, 58, 1, 58, 1, 58, 5, 58, 985, 8, 58, 10, 58, 12, 58, 988, 9, 58,
		1, 59, 1, 59, 5, 59, 992, 8, 59, 10, 59, 12, 59, 995, 9, 59, 1, 59, 1,
		59, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1003, 8, 60, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 3, 61, 1010, 8, 61, 1, 62, 5, 62, 1013, 8, 62, 10, 62, 12,
		62, 1016, 9, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1030, 8, 63, 1, 64, 1, 64, 1, 64, 5,
		64, 1035, 8, 64, 10, 64, 12, 64, 1038, 9, 64, 1, 65, 1, 65, 1, 65, 3, 65,
		1043, 8, 65, 1, 66, 1, 66, 3, 66, 1047, 8, 66, 1, 67, 1, 67, 3, 67, 1051,
		8, 67, 1, 68, 1, 68, 3, 68, 1055, 8, 68, 1, 69, 1, 69, 3, 69, 1059, 8,
		69, 1, 70, 1, 70, 1, 70, 3, 70, 1064, 8, 70, 1, 71, 1, 71, 1, 71, 5, 71,
		1069, 8, 71, 10, 71, 12, 71, 1072, 9, 71, 3, 71, 1074, 8, 71, 1, 71, 1,
		71, 3, 71, 1078, 8, 71, 1, 71, 3, 71, 1081, 8, 71, 1, 72, 1, 72, 5, 72,
		1085, 8, 72, 10, 72, 12, 72, 1088, 9, 72, 1, 72, 1, 72, 3, 72, 1092, 8,
		72, 1, 72, 3, 72, 1095, 8, 72, 1, 73, 1, 73, 3, 73, 1099, 8, 73, 1, 73,
		1, 73, 3, 73, 1103, 8, 73, 1, 73, 1, 73, 5, 73, 1107, 8, 73, 10, 73, 12,
		73, 1110, 9, 73, 1, 73, 1, 73, 3, 73, 1114, 8, 73, 3, 73, 1116, 8, 73,
		1, 74, 1, 74, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 3, 76, 1125, 8, 76, 1,
		76, 1, 76, 1, 77, 5, 77, 1130, 8, 77, 10, 77, 12, 77, 1133, 9, 77, 1, 77,
		1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 1, 78, 3, 78, 1148, 8, 78, 1, 79, 1, 79, 5, 79, 1152, 8, 79, 10, 79,
		12, 79, 1155, 9, 79, 3, 79, 1157, 8, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1162,
		8, 79, 1, 80, 1, 80, 3, 80, 1166, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1,
		81, 3, 81, 1173, 8, 81, 1, 81, 3, 81, 1176, 8, 81, 1, 81, 1, 81, 3, 81,
		1180, 8, 81, 1, 82, 5, 82, 1183, 8, 82, 10, 82, 12, 82, 1186, 9, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 3, 82, 1192, 8, 82, 1, 82, 1, 82, 1, 83, 1, 83,
		1, 83, 5, 83, 1199, 8, 83, 10, 83, 12, 83, 1202, 9, 83, 1, 84, 5, 84, 1205,
		8, 84, 10, 84, 12, 84, 1208, 9, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84,
		1214, 8, 84, 1, 85, 5, 85, 1217, 8, 85, 10, 85, 12, 85, 1220, 9, 85, 1,
		85, 1, 85, 5, 85, 1224, 8, 85, 10, 85, 12, 85, 1227, 9, 85, 1, 85, 1, 85,
		1, 85, 1, 86, 1, 86, 3, 86, 1234, 8, 86, 1, 87, 1, 87, 1, 87, 1, 88, 1,
		88, 1, 88, 5, 88, 1242, 8, 88, 10, 88, 12, 88, 1245, 9, 88, 1, 89, 1, 89,
		3, 89, 1249, 8, 89, 1, 90, 1, 90, 3, 90, 1253, 8, 90, 1, 91, 1, 91, 1,
		92, 1, 92, 1, 92, 1, 93, 5, 93, 1261, 8, 93, 10, 93, 12, 93, 1264, 9, 93,
		1, 93, 1, 93, 3, 93, 1268, 8, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1,
		94, 3, 94, 1276, 8, 94, 1, 95, 3, 95, 1279, 8, 95, 1, 95, 1, 95, 1, 95,
		1, 95, 1, 95, 3, 95, 1286, 8, 95, 1, 95, 3, 95, 1289, 8, 95, 1, 95, 1,
		95, 1, 96, 1, 96, 1, 97, 1, 97, 3, 97, 1297, 8, 97, 1, 97, 3, 97, 1300,
		8, 97, 1, 97, 1, 97, 1, 98, 3, 98, 1305, 8, 98, 1, 98, 1, 98, 1, 98, 3,
		98, 1310, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1316, 8, 98, 1, 98,
		1, 98, 3, 98, 1320, 8, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1325, 8, 98, 1,
		98, 1, 98, 1, 98, 3, 98, 1330, 8, 98, 1, 99, 5, 99, 1333, 8, 99, 10, 99,
		12, 99, 1336, 9, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1341, 8, 99, 1, 99, 1,
		99, 1, 100, 1, 100, 3, 100, 1347, 8, 100, 1, 100, 3, 100, 1350, 8, 100,
		1, 100, 3, 100, 1353, 8, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 5,
		101, 1360, 8, 101, 10, 101, 12, 101, 1363, 9, 101, 1, 102, 5, 102, 1366,
		8, 102, 10, 102, 12, 102, 1369, 9, 102, 1, 102, 1, 102, 1, 102, 3, 102,
		1374, 8, 102, 1, 102, 3, 102, 1377, 8, 102, 1, 102, 3, 102, 1380, 8, 102,
		1, 103, 1, 103, 1, 104, 1, 104, 5, 104, 1386, 8, 104, 10, 104, 12, 104,
		1389, 9, 104, 1, 105, 5, 105, 1392, 8, 105, 10, 105, 12, 105, 1395, 9,
		105, 1, 105, 1, 105, 1, 105, 3, 105, 1400, 8, 105, 1, 105, 1, 105, 3, 105,
		1404, 8, 105, 1, 105, 1, 105, 1, 106, 1, 106, 3, 106, 1410, 8, 106, 1,
		106, 1, 106, 1, 107, 1, 107, 1, 107, 5, 107, 1417, 8, 107, 10, 107, 12,
		107, 1420, 9, 107, 1, 108, 5, 108, 1423, 8, 108, 10, 108, 12, 108, 1426,
		9, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1432, 8, 108, 1, 109, 5,
		109, 1435, 8, 109, 10, 109, 12, 109, 1438, 9, 109, 1, 109, 1, 109, 5, 109,
		1442, 8, 109, 10, 109, 12, 109, 1445, 9, 109, 1, 109, 1, 109, 1, 109, 1,
		110, 1, 110, 1, 111, 1, 111, 5, 111, 1454, 8, 111, 10, 111, 12, 111, 1457,
		9, 111, 1, 111, 1, 111, 1, 112, 1, 112, 3, 112, 1463, 8, 112, 1, 113, 5,
		113, 1466, 8, 113, 10, 113, 12, 113, 1469, 9, 113, 1, 113, 1, 113, 1, 113,
		1, 114, 1, 114, 3, 114, 1476, 8, 114, 1, 115, 5, 115, 1479, 8, 115, 10,
		115, 12, 115, 1482, 9, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1487, 8, 115,
		1, 115, 3, 115, 1490, 8, 115, 1, 115, 3, 115, 1493, 8, 115, 1, 115, 1,
		115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 3, 116, 1506, 8, 116, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118,
		1, 118, 5, 118, 1515, 8, 118, 10, 118, 12, 118, 1518, 9, 118, 1, 119, 1,
		119, 5, 119, 1522, 8, 119, 10, 119, 12, 119, 1525, 9, 119, 1, 119, 1, 119,
		1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1534, 8, 120, 1, 121, 5,
		121, 1537, 8, 121, 10, 121, 12, 121, 1540, 9, 121, 1, 121, 1, 121, 1, 121,
		1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 1550, 8, 122, 1, 123, 5,
		123, 1553, 8, 123, 10, 123, 12, 123, 1556, 9, 123, 1, 123, 1, 123, 1, 123,
		1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1568, 8,
		124, 1, 125, 5, 125, 1571, 8, 125, 10, 125, 12, 125, 1574, 9, 125, 1, 125,
		1, 125, 1, 125, 1, 125, 1, 125, 1, 126, 1, 126, 5, 126, 1583, 8, 126, 10,
		126, 12, 126, 1586, 9, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1,
		127, 1, 127, 3, 127, 1595, 8, 127, 1, 128, 5, 128, 1598, 8, 128, 10, 128,
		12, 128, 1601, 9, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128,
		1608, 8, 128, 1, 128, 3, 128, 1611, 8, 128, 1, 128, 1, 128, 1, 129, 1,
		129, 1, 129, 3, 129, 1618, 8, 129, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131,
		1, 131, 3, 131, 1626, 8, 131, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132, 1632,
		8, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 5, 133, 1639, 8, 133, 10,
		133, 12, 133, 1642, 9, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1,
		135, 1, 135, 3, 135, 1651, 8, 135, 1, 136, 1, 136, 3, 136, 1655, 8, 136,
		1, 136, 3, 136, 1658, 8, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 5,
		137, 1665, 8, 137, 10, 137, 12, 137, 1668, 9, 137, 1, 138, 1, 138, 1, 138,
		1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 140, 1, 140, 3, 140,
		1681, 8, 140, 1, 140, 3, 140, 1684, 8, 140, 1, 140, 1, 140, 1, 141, 1,
		141, 1, 141, 5, 141, 1691, 8, 141, 10, 141, 12, 141, 1694, 9, 141, 1, 142,
		1, 142, 3, 142, 1698, 8, 142, 1, 142, 1, 142, 1, 143, 1, 143, 5, 143, 1704,
		8, 143, 10, 143, 12, 143, 1707, 9, 143, 1, 144, 1, 144, 1, 144, 3, 144,
		1712, 8, 144, 1, 145, 1, 145, 3, 145, 1716, 8, 145, 1, 146, 5, 146, 1719,
		8, 146, 10, 146, 12, 146, 1722, 9, 146, 1, 146, 1, 146, 3, 146, 1726, 8,
		146, 1, 147, 1, 147, 3, 147, 1730, 8, 147, 1, 148, 1, 148, 1, 148, 1, 149,
		1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 1741, 8, 149, 1, 150, 1,
		150, 1, 150, 1, 150, 1, 150, 3, 150, 1748, 8, 150, 1, 151, 1, 151, 1, 151,
		1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151,
		1, 151, 3, 151, 1763, 8, 151, 1, 152, 1, 152, 1, 153, 1, 153, 1, 153, 1,
		153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 155, 1, 155, 1, 155, 1, 156, 1,
		156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 3, 156, 1785, 8, 156, 1, 157,
		1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 158,
		1, 158, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159,
		1, 159, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 1813, 8,
		160, 1, 160, 1, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1,
		162, 1, 162, 1, 162, 5, 162, 1826, 8, 162, 10, 162, 12, 162, 1829, 9, 162,
		1, 162, 1, 162, 1, 162, 1, 162, 5, 162, 1835, 8, 162, 10, 162, 12, 162,
		1838, 9, 162, 1, 162, 1, 162, 1, 162, 5, 162, 1843, 8, 162, 10, 162, 12,
		162, 1846, 9, 162, 1, 162, 3, 162, 1849, 8, 162, 1, 163, 1, 163, 1, 163,
		1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 1858, 8, 163, 1, 164, 1, 164, 1,
		164, 1, 164, 1, 164, 5, 164, 1865, 8, 164, 10, 164, 12, 164, 1868, 9, 164,
		1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1, 165, 5, 165, 1876, 8, 165, 10,
		165, 12, 165, 1879, 9, 165, 1, 165, 3, 165, 1882, 8, 165, 1, 166, 1, 166,
		1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 168, 1, 168, 1, 168,
		1, 168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169,
		1, 169, 1, 169, 1, 170, 1, 170, 3, 170, 1908, 8, 170, 1, 171, 1, 171, 3,
		171, 1912, 8, 171, 1, 172, 1, 172, 1, 172, 3, 172, 1917, 8, 172, 1, 172,
		1, 172, 3, 172, 1921, 8, 172, 1, 172, 1, 172, 3, 172, 1925, 8, 172, 1,
		172, 1, 172, 1, 172, 1, 173, 1, 173, 1, 173, 3, 173, 1933, 8, 173, 1, 173,
		1, 173, 3, 173, 1937, 8, 173, 1, 173, 1, 173, 3, 173, 1941, 8, 173, 1,
		173, 1, 173, 1, 173, 1, 174, 1, 174, 3, 174, 1948, 8, 174, 1, 175, 1, 175,
		1, 176, 1, 176, 1, 176, 5, 176, 1955, 8, 176, 10, 176, 12, 176, 1958, 9,
		176, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1,
		178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 179, 1,
		179, 3, 179, 1978, 8, 179, 1, 179, 1, 179, 1, 180, 1, 180, 3, 180, 1984,
		8, 180, 1, 180, 1, 180, 1, 181, 1, 181, 3, 181, 1990, 8, 181, 1, 181, 1,
		181, 1, 182, 1, 182, 1, 182, 1, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1,
		183, 1, 183, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1,
		184, 1, 184, 1, 184, 1, 184, 3, 184, 2015, 8, 184, 1, 184, 1, 184, 1, 184,
		3, 184, 2020, 8, 184, 1, 185, 1, 185, 5, 185, 2024, 8, 185, 10, 185, 12,
		185, 2027, 9, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187,
		5, 187, 2036, 8, 187, 10, 187, 12, 187, 2039, 9, 187, 1, 187, 1, 187, 1,
		187, 1, 188, 1, 188, 1, 188, 5, 188, 2047, 8, 188, 10, 188, 12, 188, 2050,
		9, 188, 1, 189, 1, 189, 1, 189, 1, 190, 1, 190, 1, 190, 1, 190, 3, 190,
		2059, 8, 190, 1, 190, 3, 190, 2062, 8, 190, 1, 191, 1, 191, 1, 191, 3,
		191, 2067, 8, 191, 1, 191, 1, 191, 1, 192, 1, 192, 1, 192, 5, 192, 2074,
		8, 192, 10, 192, 12, 192, 2077, 9, 192, 1, 193, 1, 193, 3, 193, 2081, 8,
		193, 1, 194, 1, 194, 3, 194, 2085, 8, 194, 1, 195, 1, 195, 1, 195, 1, 195,
		1, 196, 1, 196, 1, 197, 1, 197, 1, 198, 1, 198, 3, 198, 2097, 8, 198, 1,
		199, 1, 199, 3, 199, 2101, 8, 199, 1, 200, 1, 200, 3, 200, 2105, 8, 200,
		1, 200, 1, 200, 3, 200, 2109, 8, 200, 1, 200, 1, 200, 3, 200, 2113, 8,
		200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2119, 8, 200, 1, 200, 1, 200,
		1, 200, 1, 200, 3, 200, 2125, 8, 200, 1, 200, 1, 200, 3, 200, 2129, 8,
		200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2135, 8, 200, 1, 200, 1, 200,
		1, 200, 1, 200, 3, 200, 2141, 8, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3,
		200, 2147, 8, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2153, 8, 200,
		1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2161, 8, 200, 1,
		200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2168, 8, 200, 1, 200, 1, 200,
		1, 200, 1, 200, 1, 200, 3, 200, 2175, 8, 200, 1, 200, 1, 200, 1, 200, 3,
		200, 2180, 8, 200, 1, 200, 1, 200, 3, 200, 2184, 8, 200, 1, 200, 1, 200,
		1, 200, 3, 200, 2189, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2194, 8,
		200, 1, 200, 1, 200, 3, 200, 2198, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200,
		2203, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2208, 8, 200, 1, 200, 1,
		200, 3, 200, 2212, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2217, 8, 200,
		1, 200, 1, 200, 1, 200, 3, 200, 2222, 8, 200, 1, 200, 1, 200, 3, 200, 2226,
		8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2231, 8, 200, 1, 200, 1, 200, 1,
		200, 3, 200, 2236, 8, 200, 1, 200, 1, 200, 3, 200, 2240, 8, 200, 1, 200,
		1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2247, 8, 200, 1, 200, 1, 200, 1,
		200, 3, 200, 2252, 8, 200, 1, 200, 1, 200, 3, 200, 2256, 8, 200, 1, 200,
		1, 200, 1, 200, 3, 200, 2261, 8, 200, 1, 200, 1, 200, 3, 200, 2265, 8,
		200, 1, 200, 1, 200, 1, 200, 3, 200, 2270, 8, 200, 1, 200, 1, 200, 3, 200,
		2274, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2279, 8, 200, 1, 200, 1,
		200, 3, 200, 2283, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2288, 8, 200,
		1, 200, 1, 200, 3, 200, 2292, 8, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1,
		200, 3, 200, 2299, 8, 200, 1, 200, 1, 200, 3, 200, 2303, 8, 200, 1, 200,
		1, 200, 1, 200, 3, 200, 2308, 8, 200, 1, 200, 1, 200, 3, 200, 2312, 8,
		200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2318, 8, 200, 3, 200, 2320,
		8, 200, 1, 201, 1, 201, 1, 201, 3, 201, 2325, 8, 201, 1, 201, 1, 201, 1,
		201, 3, 201, 2330, 8, 201, 1, 201, 1, 201, 1, 201, 1, 201, 3, 201, 2336,
		8, 201, 1, 201, 1, 201, 3, 201, 2340, 8, 201, 1, 201, 1, 201, 1, 201, 3,
		201, 2345, 8, 201, 1, 201, 1, 201, 3, 201, 2349, 8, 201, 1, 201, 1, 201,
		3, 201, 2353, 8, 201, 1, 201, 1, 201, 3, 201, 2357, 8, 201, 3, 201, 2359,
		8, 201, 1, 202, 1, 202, 1, 202, 5, 202, 2364, 8, 202, 10, 202, 12, 202,
		2367, 9, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 5, 202, 2375,
		8, 202, 10, 202, 12, 202, 2378, 9, 202, 1, 202, 1, 202, 1, 202, 1, 202,
		1, 202, 1, 202, 5, 202, 2386, 8, 202, 10, 202, 12, 202, 2389, 9, 202, 1,
		202, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 2396, 8, 202, 1, 203, 1, 203,
		1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 3, 203, 2407, 8,
		203, 1, 204, 1, 204, 3, 204, 2411, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204,
		2416, 8, 204, 1, 204, 1, 204, 3, 204, 2420, 8, 204, 1, 205, 5, 205, 2423,
		8, 205, 10, 205, 12, 205, 2426, 9, 205, 1, 205, 1, 205, 1, 205, 5, 205,
		2431, 8, 205, 10, 205, 12, 205, 2434, 9, 205, 1, 205, 5, 205, 2437, 8,
		205, 10, 205, 12, 205, 2440, 9, 205, 1, 205, 3, 205, 2443, 8, 205, 1, 206,
		1, 206, 3, 206, 2447, 8, 206, 1, 207, 1, 207, 3, 207, 2451, 8, 207, 1,
		208, 1, 208, 1, 208, 1, 208, 3, 208, 2457, 8, 208, 1, 208, 1, 208, 1, 208,
		1, 208, 3, 208, 2463, 8, 208, 3, 208, 2465, 8, 208, 1, 209, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 2477,
		8, 209, 1, 210, 1, 210, 5, 210, 2481, 8, 210, 10, 210, 12, 210, 2484, 9,
		210, 1, 211, 5, 211, 2487, 8, 211, 10, 211, 12, 211, 2490, 9, 211, 1, 211,
		1, 211, 1, 211, 1, 211, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		3, 212, 2511, 8, 212, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213, 2526, 8, 213,
		1, 214, 1, 214, 1, 214, 3, 214, 2531, 8, 214, 1, 214, 1, 214, 1, 214, 1,
		214, 1, 214, 3, 214, 2538, 8, 214, 1, 214, 1, 214, 1, 214, 3, 214, 2543,
		8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 3, 214, 2550, 8, 214, 1,
		214, 1, 214, 1, 214, 3, 214, 2555, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214,
		1, 214, 3, 214, 2562, 8, 214, 1, 214, 1, 214, 1, 214, 3, 214, 2567, 8,
		214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 3, 214, 2574, 8, 214, 1, 214,
		1, 214, 1, 214, 3, 214, 2579, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1,
		214, 1, 214, 1, 214, 3, 214, 2588, 8, 214, 1, 214, 1, 214, 1, 214, 3, 214,
		2593, 8, 214, 1, 214, 1, 214, 3, 214, 2597, 8, 214, 1, 215, 1, 215, 1,
		215, 5, 215, 2602, 8, 215, 10, 215, 12, 215, 2605, 9, 215, 1, 216, 1, 216,
		1, 216, 3, 216, 2610, 8, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 3,
		216, 2617, 8, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 3, 216, 2624,
		8, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 3, 216, 2631, 8, 216, 1,
		216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 3, 216, 2639, 8, 216, 1, 216,
		1, 216, 1, 216, 1, 216, 1, 216, 3, 216, 2646, 8, 216, 1, 216, 1, 216, 1,
		216, 1, 216, 1, 216, 1, 216, 3, 216, 2654, 8, 216, 1, 217, 1, 217, 3, 217,
		2658, 8, 217, 1, 217, 1, 217, 3, 217, 2662, 8, 217, 3, 217, 2664, 8, 217,
		1, 218, 1, 218, 3, 218, 2668, 8, 218, 1, 218, 1, 218, 3, 218, 2672, 8,
		218, 3, 218, 2674, 8, 218, 1, 219, 1, 219, 1, 219, 1, 220, 1, 220, 1, 220,
		1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 3, 221, 2689, 8,
		221, 1, 222, 1, 222, 1, 222, 1, 223, 1, 223, 1, 223, 1, 224, 1, 224, 1,
		224, 1, 224, 1, 224, 1, 224, 1, 224, 3, 224, 2704, 8, 224, 1, 225, 1, 225,
		1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 5, 225, 2714, 8, 225, 10,
		225, 12, 225, 2717, 9, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1,
		225, 5, 225, 2725, 8, 225, 10, 225, 12, 225, 2728, 9, 225, 1, 225, 1, 225,
		1, 225, 3, 225, 2733, 8, 225, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1,
		226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 5, 226, 2747, 8, 226,
		10, 226, 12, 226, 2750, 9, 226, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227,
		1, 227, 1, 227, 1, 227, 1, 227, 5, 227, 2761, 8, 227, 10, 227, 12, 227,
		2764, 9, 227, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 5,
		228, 2782, 8, 228, 10, 228, 12, 228, 2785, 9, 228, 1, 229, 1, 229, 1, 229,
		1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229,
		1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 3, 229, 2806, 8,
		229, 5, 229, 2808, 8, 229, 10, 229, 12, 229, 2811, 9, 229, 1, 230, 1, 230,
		1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 5, 230, 2822, 8,
		230, 10, 230, 12, 230, 2825, 9, 230, 1, 231, 1, 231, 1, 231, 1, 231, 1,
		231, 1, 231, 5, 231, 2833, 8, 231, 10, 231, 12, 231, 2836, 9, 231, 1, 232,
		1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 5, 232, 2844, 8, 232, 10, 232,
		12, 232, 2847, 9, 232, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233,
		5, 233, 2855, 8, 233, 10, 233, 12, 233, 2858, 9, 233, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 1, 234, 5, 234, 2866, 8, 234, 10, 234, 12, 234, 2869,
		9, 234, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 5, 235, 2877, 8,
		235, 10, 235, 12, 235, 2880, 9, 235, 1, 236, 1, 236, 1, 236, 1, 236, 1,
		236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 3,
		236, 2895, 8, 236, 1, 237, 1, 237, 3, 237, 2899, 8, 237, 1, 238, 1, 238,
		1, 238, 1, 238, 1, 239, 1, 239, 1, 239, 3, 239, 2908, 8, 239, 1, 240, 1,
		240, 1, 241, 1, 241, 1, 241, 1, 241, 1, 242, 1, 242, 3, 242, 2918, 8, 242,
		1, 242, 1, 242, 3, 242, 2922, 8, 242, 1, 243, 1, 243, 1, 243, 5, 243, 2927,
		8, 243, 10, 243, 12, 243, 2930, 9, 243, 1, 243, 1, 243, 1, 243, 5, 243,
		2935, 8, 243, 10, 243, 12, 243, 2938, 9, 243, 3, 243, 2940, 8, 243, 1,
		244, 5, 244, 2943, 8, 244, 10, 244, 12, 244, 2946, 9, 244, 1, 244, 1, 244,
		1, 244, 1, 244, 3, 244, 2952, 8, 244, 1, 245, 1, 245, 3, 245, 2956, 8,
		245, 1, 246, 1, 246, 3, 246, 2960, 8, 246, 1, 247, 1, 247, 1, 247, 1, 247,
		1, 247, 1, 247, 1, 248, 1, 248, 1, 248, 0, 10, 452, 454, 456, 458, 460,
		462, 464, 466, 468, 470, 249, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
		24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
		60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
		96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
		126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
		156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
		186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214,
		216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244,
		246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274,
		276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304,
		306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334,
		336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364,
		366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394,
		396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424,
		426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454,
		456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484,
		486, 488, 490, 492, 494, 496, 0, 9, 2, 0, 1, 3, 5, 17, 6, 0, 1, 3, 5, 6,
		8, 8, 10, 10, 12, 14, 16, 16, 2, 0, 1, 3, 5, 16, 1, 0, 69, 75, 5, 0, 22,
		22, 25, 25, 44, 44, 46, 46, 54, 54, 2, 0, 31, 31, 37, 37, 2, 0, 13, 13,
		55, 55, 2, 0, 57, 57, 60, 60, 2, 0, 88, 88, 112, 122, 3229, 0, 498, 1,
		0, 0, 0, 2, 503, 1, 0, 0, 0, 4, 507, 1, 0, 0, 0, 6, 511, 1, 0, 0, 0, 8,
		513, 1, 0, 0, 0, 10, 515, 1, 0, 0, 0, 12, 517, 1, 0, 0, 0, 14, 519, 1,
		0, 0, 0, 16, 524, 1, 0, 0, 0, 18, 533, 1, 0, 0, 0, 20, 535, 1, 0, 0, 0,
		22, 537, 1, 0, 0, 0, 24, 542, 1, 0, 0, 0, 26, 544, 1, 0, 0, 0, 28, 561,
		1, 0, 0, 0, 30, 610, 1, 0, 0, 0, 32, 612, 1, 0, 0, 0, 34, 617, 1, 0, 0,
		0, 36, 631, 1, 0, 0, 0, 38, 636, 1, 0, 0, 0, 40, 657, 1, 0, 0, 0, 42, 664,
		1, 0, 0, 0, 44, 666, 1, 0, 0, 0, 46, 677, 1, 0, 0, 0, 48, 680, 1, 0, 0,
		0, 50, 684, 1, 0, 0, 0, 52, 694, 1, 0, 0, 0, 54, 699, 1, 0, 0, 0, 56, 710,
		1, 0, 0, 0, 58, 712, 1, 0, 0, 0, 60, 717, 1, 0, 0, 0, 62, 722, 1, 0, 0,
		0, 64, 727, 1, 0, 0, 0, 66, 735, 1, 0, 0, 0, 68, 739, 1, 0, 0, 0, 70, 741,
		1, 0, 0, 0, 72, 748, 1, 0, 0, 0, 74, 751, 1, 0, 0, 0, 76, 768, 1, 0, 0,
		0, 78, 776, 1, 0, 0, 0, 80, 790, 1, 0, 0, 0, 82, 796, 1, 0, 0, 0, 84, 798,
		1, 0, 0, 0, 86, 802, 1, 0, 0, 0, 88, 808, 1, 0, 0, 0, 90, 815, 1, 0, 0,
		0, 92, 825, 1, 0, 0, 0, 94, 830, 1, 0, 0, 0, 96, 911, 1, 0, 0, 0, 98, 913,
		1, 0, 0, 0, 100, 918, 1, 0, 0, 0, 102, 923, 1, 0, 0, 0, 104, 952, 1, 0,
		0, 0, 106, 954, 1, 0, 0, 0, 108, 958, 1, 0, 0, 0, 110, 966, 1, 0, 0, 0,
		112, 969, 1, 0, 0, 0, 114, 972, 1, 0, 0, 0, 116, 980, 1, 0, 0, 0, 118,
		989, 1, 0, 0, 0, 120, 1002, 1, 0, 0, 0, 122, 1009, 1, 0, 0, 0, 124, 1014,
		1, 0, 0, 0, 126, 1029, 1, 0, 0, 0, 128, 1031, 1, 0, 0, 0, 130, 1039, 1,
		0, 0, 0, 132, 1044, 1, 0, 0, 0, 134, 1050, 1, 0, 0, 0, 136, 1054, 1, 0,
		0, 0, 138, 1058, 1, 0, 0, 0, 140, 1063, 1, 0, 0, 0, 142, 1073, 1, 0, 0,
		0, 144, 1082, 1, 0, 0, 0, 146, 1115, 1, 0, 0, 0, 148, 1117, 1, 0, 0, 0,
		150, 1119, 1, 0, 0, 0, 152, 1124, 1, 0, 0, 0, 154, 1131, 1, 0, 0, 0, 156,
		1147, 1, 0, 0, 0, 158, 1156, 1, 0, 0, 0, 160, 1165, 1, 0, 0, 0, 162, 1167,
		1, 0, 0, 0, 164, 1184, 1, 0, 0, 0, 166, 1195, 1, 0, 0, 0, 168, 1213, 1,
		0, 0, 0, 170, 1218, 1, 0, 0, 0, 172, 1233, 1, 0, 0, 0, 174, 1235, 1, 0,
		0, 0, 176, 1238, 1, 0, 0, 0, 178, 1248, 1, 0, 0, 0, 180, 1252, 1, 0, 0,
		0, 182, 1254, 1, 0, 0, 0, 184, 1256, 1, 0, 0, 0, 186, 1262, 1, 0, 0, 0,
		188, 1275, 1, 0, 0, 0, 190, 1278, 1, 0, 0, 0, 192, 1292, 1, 0, 0, 0, 194,
		1294, 1, 0, 0, 0, 196, 1329, 1, 0, 0, 0, 198, 1334, 1, 0, 0, 0, 200, 1344,
		1, 0, 0, 0, 202, 1356, 1, 0, 0, 0, 204, 1367, 1, 0, 0, 0, 206, 1381, 1,
		0, 0, 0, 208, 1383, 1, 0, 0, 0, 210, 1393, 1, 0, 0, 0, 212, 1407, 1, 0,
		0, 0, 214, 1413, 1, 0, 0, 0, 216, 1431, 1, 0, 0, 0, 218, 1436, 1, 0, 0,
		0, 220, 1449, 1, 0, 0, 0, 222, 1451, 1, 0, 0, 0, 224, 1462, 1, 0, 0, 0,
		226, 1467, 1, 0, 0, 0, 228, 1475, 1, 0, 0, 0, 230, 1480, 1, 0, 0, 0, 232,
		1505, 1, 0, 0, 0, 234, 1507, 1, 0, 0, 0, 236, 1510, 1, 0, 0, 0, 238, 1519,
		1, 0, 0, 0, 240, 1533, 1, 0, 0, 0, 242, 1538, 1, 0, 0, 0, 244, 1549, 1,
		0, 0, 0, 246, 1554, 1, 0, 0, 0, 248, 1567, 1, 0, 0, 0, 250, 1572, 1, 0,
		0, 0, 252, 1580, 1, 0, 0, 0, 254, 1594, 1, 0, 0, 0, 256, 1599, 1, 0, 0,
		0, 258, 1617, 1, 0, 0, 0, 260, 1619, 1, 0, 0, 0, 262, 1625, 1, 0, 0, 0,
		264, 1627, 1, 0, 0, 0, 266, 1635, 1, 0, 0, 0, 268, 1643, 1, 0, 0, 0, 270,
		1650, 1, 0, 0, 0, 272, 1652, 1, 0, 0, 0, 274, 1661, 1, 0, 0, 0, 276, 1669,
		1, 0, 0, 0, 278, 1672, 1, 0, 0, 0, 280, 1678, 1, 0, 0, 0, 282, 1687, 1,
		0, 0, 0, 284, 1695, 1, 0, 0, 0, 286, 1701, 1, 0, 0, 0, 288, 1711, 1, 0,
		0, 0, 290, 1715, 1, 0, 0, 0, 292, 1720, 1, 0, 0, 0, 294, 1729, 1, 0, 0,
		0, 296, 1731, 1, 0, 0, 0, 298, 1740, 1, 0, 0, 0, 300, 1747, 1, 0, 0, 0,
		302, 1762, 1, 0, 0, 0, 304, 1764, 1, 0, 0, 0, 306, 1766, 1, 0, 0, 0, 308,
		1770, 1, 0, 0, 0, 310, 1774, 1, 0, 0, 0, 312, 1784, 1, 0, 0, 0, 314, 1786,
		1, 0, 0, 0, 316, 1792, 1, 0, 0, 0, 318, 1800, 1, 0, 0, 0, 320, 1808, 1,
		0, 0, 0, 322, 1816, 1, 0, 0, 0, 324, 1848, 1, 0, 0, 0, 326, 1850, 1, 0,
		0, 0, 328, 1859, 1, 0, 0, 0, 330, 1881, 1, 0, 0, 0, 332, 1883, 1, 0, 0,
		0, 334, 1885, 1, 0, 0, 0, 336, 1891, 1, 0, 0, 0, 338, 1897, 1, 0, 0, 0,
		340, 1907, 1, 0, 0, 0, 342, 1911, 1, 0, 0, 0, 344, 1913, 1, 0, 0, 0, 346,
		1929, 1, 0, 0, 0, 348, 1947, 1, 0, 0, 0, 350, 1949, 1, 0, 0, 0, 352, 1951,
		1, 0, 0, 0, 354, 1959, 1, 0, 0, 0, 356, 1967, 1, 0, 0, 0, 358, 1975, 1,
		0, 0, 0, 360, 1981, 1, 0, 0, 0, 362, 1987, 1, 0, 0, 0, 364, 1993, 1, 0,
		0, 0, 366, 1997, 1, 0, 0, 0, 368, 2019, 1, 0, 0, 0, 370, 2021, 1, 0, 0,
		0, 372, 2028, 1, 0, 0, 0, 374, 2037, 1, 0, 0, 0, 376, 2043, 1, 0, 0, 0,
		378, 2051, 1, 0, 0, 0, 380, 2054, 1, 0, 0, 0, 382, 2063, 1, 0, 0, 0, 384,
		2070, 1, 0, 0, 0, 386, 2080, 1, 0, 0, 0, 388, 2084, 1, 0, 0, 0, 390, 2086,
		1, 0, 0, 0, 392, 2090, 1, 0, 0, 0, 394, 2092, 1, 0, 0, 0, 396, 2096, 1,
		0, 0, 0, 398, 2100, 1, 0, 0, 0, 400, 2319, 1, 0, 0, 0, 402, 2358, 1, 0,
		0, 0, 404, 2395, 1, 0, 0, 0, 406, 2406, 1, 0, 0, 0, 408, 2408, 1, 0, 0,
		0, 410, 2424, 1, 0, 0, 0, 412, 2446, 1, 0, 0, 0, 414, 2450, 1, 0, 0, 0,
		416, 2464, 1, 0, 0, 0, 418, 2476, 1, 0, 0, 0, 420, 2478, 1, 0, 0, 0, 422,
		2488, 1, 0, 0, 0, 424, 2510, 1, 0, 0, 0, 426, 2525, 1, 0, 0, 0, 428, 2596,
		1, 0, 0, 0, 430, 2598, 1, 0, 0, 0, 432, 2653, 1, 0, 0, 0, 434, 2663, 1,
		0, 0, 0, 436, 2673, 1, 0, 0, 0, 438, 2675, 1, 0, 0, 0, 440, 2678, 1, 0,
		0, 0, 442, 2688, 1, 0, 0, 0, 444, 2690, 1, 0, 0, 0, 446, 2693, 1, 0, 0,
		0, 448, 2703, 1, 0, 0, 0, 450, 2732, 1, 0, 0, 0, 452, 2734, 1, 0, 0, 0,
		454, 2751, 1, 0, 0, 0, 456, 2765, 1, 0, 0, 0, 458, 2786, 1, 0, 0, 0, 460,
		2812, 1, 0, 0, 0, 462, 2826, 1, 0, 0, 0, 464, 2837, 1, 0, 0, 0, 466, 2848,
		1, 0, 0, 0, 468, 2859, 1, 0, 0, 0, 470, 2870, 1, 0, 0, 0, 472, 2894, 1,
		0, 0, 0, 474, 2898, 1, 0, 0, 0, 476, 2900, 1, 0, 0, 0, 478, 2907, 1, 0,
		0, 0, 480, 2909, 1, 0, 0, 0, 482, 2911, 1, 0, 0, 0, 484, 2921, 1, 0, 0,
		0, 486, 2939, 1, 0, 0, 0, 488, 2951, 1, 0, 0, 0, 490, 2955, 1, 0, 0, 0,
		492, 2959, 1, 0, 0, 0, 494, 2961, 1, 0, 0, 0, 496, 2967, 1, 0, 0, 0, 498,
		499, 3, 72, 36, 0, 499, 500, 5, 0, 0, 1, 500, 1, 1, 0, 0, 0, 501, 504,
		5, 123, 0, 0, 502, 504, 3, 8, 4, 0, 503, 501, 1, 0, 0, 0, 503, 502, 1,
		0, 0, 0, 504, 3, 1, 0, 0, 0, 505, 508, 5, 123, 0, 0, 506, 508, 3, 10, 5,
		0, 507, 505, 1, 0, 0, 0, 507, 506, 1, 0, 0, 0, 508, 5, 1, 0, 0, 0, 509,
		512, 5, 123, 0, 0, 510, 512, 3, 12, 6, 0, 511, 509, 1, 0, 0, 0, 511, 510,
		1, 0, 0, 0, 512, 7, 1, 0, 0, 0, 513, 514, 7, 0, 0, 0, 514, 9, 1, 0, 0,
		0, 515, 516, 7, 1, 0, 0, 516, 11, 1, 0, 0, 0, 517, 518, 7, 2, 0, 0, 518,
		13, 1, 0, 0, 0, 519, 520, 7, 3, 0, 0, 520, 15, 1, 0, 0, 0, 521, 523, 3,
		262, 131, 0, 522, 521, 1, 0, 0, 0, 523, 526, 1, 0, 0, 0, 524, 522, 1, 0,
		0, 0, 524, 525, 1, 0, 0, 0, 525, 529, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0,
		527, 530, 3, 18, 9, 0, 528, 530, 5, 20, 0, 0, 529, 527, 1, 0, 0, 0, 529,
		528, 1, 0, 0, 0, 530, 17, 1, 0, 0, 0, 531, 534, 3, 20, 10, 0, 532, 534,
		3, 22, 11, 0, 533, 531, 1, 0, 0, 0, 533, 532, 1, 0, 0, 0, 534, 19, 1, 0,
		0, 0, 535, 536, 7, 4, 0, 0, 536, 21, 1, 0, 0, 0, 537, 538, 7, 5, 0, 0,
		538, 23, 1, 0, 0, 0, 539, 543, 3, 28, 14, 0, 540, 543, 3, 34, 17, 0, 541,
		543, 3, 36, 18, 0, 542, 539, 1, 0, 0, 0, 542, 540, 1, 0, 0, 0, 542, 541,
		1, 0, 0, 0, 543, 25, 1, 0, 0, 0, 544, 548, 5, 84, 0, 0, 545, 547, 3, 262,
		131, 0, 546, 545, 1, 0, 0, 0, 547, 550, 1, 0, 0, 0, 548, 546, 1, 0, 0,
		0, 548, 549, 1, 0, 0, 0, 549, 551, 1, 0, 0, 0, 550, 548, 1, 0, 0, 0, 551,
		553, 3, 4, 2, 0, 552, 554, 3, 48, 24, 0, 553, 552, 1, 0, 0, 0, 553, 554,
		1, 0, 0, 0, 554, 556, 1, 0, 0, 0, 555, 557, 3, 26, 13, 0, 556, 555, 1,
		0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 27, 1, 0, 0, 0, 558, 559, 3, 60, 30,
		0, 559, 560, 5, 84, 0, 0, 560, 562, 1, 0, 0, 0, 561, 558, 1, 0, 0, 0, 561,
		562, 1, 0, 0, 0, 562, 566, 1, 0, 0, 0, 563, 565, 3, 262, 131, 0, 564, 563,
		1, 0, 0, 0, 565, 568, 1, 0, 0, 0, 566, 564, 1, 0, 0, 0, 566, 567, 1, 0,
		0, 0, 567, 569, 1, 0, 0, 0, 568, 566, 1, 0, 0, 0, 569, 571, 3, 4, 2, 0,
		570, 572, 3, 48, 24, 0, 571, 570, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572,
		574, 1, 0, 0, 0, 573, 575, 3, 26, 13, 0, 574, 573, 1, 0, 0, 0, 574, 575,
		1, 0, 0, 0, 575, 29, 1, 0, 0, 0, 576, 578, 3, 262, 131, 0, 577, 576, 1,
		0, 0, 0, 578, 581, 1, 0, 0, 0, 579, 577, 1, 0, 0, 0, 579, 580, 1, 0, 0,
		0, 580, 582, 1, 0, 0, 0, 581, 579, 1, 0, 0, 0, 582, 584, 3, 4, 2, 0, 583,
		585, 3, 48, 24, 0, 584, 583, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 611,
		1, 0, 0, 0, 586, 587, 3, 60, 30, 0, 587, 591, 5, 84, 0, 0, 588, 590, 3,
		262, 131, 0, 589, 588, 1, 0, 0, 0, 590, 593, 1, 0, 0, 0, 591, 589, 1, 0,
		0, 0, 591, 592, 1, 0, 0, 0, 592, 594, 1, 0, 0, 0, 593, 591, 1, 0, 0, 0,
		594, 596, 3, 4, 2, 0, 595, 597, 3, 48, 24, 0, 596, 595, 1, 0, 0, 0, 596,
		597, 1, 0, 0, 0, 597, 611, 1, 0, 0, 0, 598, 599, 3, 28, 14, 0, 599, 603,
		5, 84, 0, 0, 600, 602, 3, 262, 131, 0, 601, 600, 1, 0, 0, 0, 602, 605,
		1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 606, 1, 0,
		0, 0, 605, 603, 1, 0, 0, 0, 606, 608, 3, 4, 2, 0, 607, 609, 3, 48, 24,
		0, 608, 607, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 611, 1, 0, 0, 0, 610,
		579, 1, 0, 0, 0, 610, 586, 1, 0, 0, 0, 610, 598, 1, 0, 0, 0, 611, 31, 1,
		0, 0, 0, 612, 613, 3, 30, 15, 0, 613, 33, 1, 0, 0, 0, 614, 616, 3, 262,
		131, 0, 615, 614, 1, 0, 0, 0, 616, 619, 1, 0, 0, 0, 617, 615, 1, 0, 0,
		0, 617, 618, 1, 0, 0, 0, 618, 620, 1, 0, 0, 0, 619, 617, 1, 0, 0, 0, 620,
		621, 3, 4, 2, 0, 621, 35, 1, 0, 0, 0, 622, 623, 3, 16, 8, 0, 623, 624,
		3, 38, 19, 0, 624, 632, 1, 0, 0, 0, 625, 626, 3, 30, 15, 0, 626, 627, 3,
		38, 19, 0, 627, 632, 1, 0, 0, 0, 628, 629, 3, 34, 17, 0, 629, 630, 3, 38,
		19, 0, 630, 632, 1, 0, 0, 0, 631, 622, 1, 0, 0, 0, 631, 625, 1, 0, 0, 0,
		631, 628, 1, 0, 0, 0, 632, 37, 1, 0, 0, 0, 633, 635, 3, 262, 131, 0, 634,
		633, 1, 0, 0, 0, 635, 638, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 636, 637,
		1, 0, 0, 0, 637, 639, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 639, 640, 5, 80,
		0, 0, 640, 651, 5, 81, 0, 0, 641, 643, 3, 262, 131, 0, 642, 641, 1, 0,
		0, 0, 643, 646, 1, 0, 0, 0, 644, 642, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0,
		645, 647, 1, 0, 0, 0, 646, 644, 1, 0, 0, 0, 647, 648, 5, 80, 0, 0, 648,
		650, 5, 81, 0, 0, 649, 644, 1, 0, 0, 0, 650, 653, 1, 0, 0, 0, 651, 649,
		1, 0, 0, 0, 651, 652, 1, 0, 0, 0, 652, 39, 1, 0, 0, 0, 653, 651, 1, 0,
		0, 0, 654, 656, 3, 42, 21, 0, 655, 654, 1, 0, 0, 0, 656, 659, 1, 0, 0,
		0, 657, 655, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 660, 1, 0, 0, 0, 659,
		657, 1, 0, 0, 0, 660, 662, 3, 4, 2, 0, 661, 663, 3, 44, 22, 0, 662, 661,
		1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 41, 1, 0, 0, 0, 664, 665, 3, 262,
		131, 0, 665, 43, 1, 0, 0, 0, 666, 675, 5, 34, 0, 0, 667, 676, 3, 34, 17,
		0, 668, 672, 3, 28, 14, 0, 669, 671, 3, 46, 23, 0, 670, 669, 1, 0, 0, 0,
		671, 674, 1, 0, 0, 0, 672, 670, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673,
		676, 1, 0, 0, 0, 674, 672, 1, 0, 0, 0, 675, 667, 1, 0, 0, 0, 675, 668,
		1, 0, 0, 0, 676, 45, 1, 0, 0, 0, 677, 678, 5, 108, 0, 0, 678, 679, 3, 32,
		16, 0, 679, 47, 1, 0, 0, 0, 680, 681, 5, 90, 0, 0, 681, 682, 3, 50, 25,
		0, 682, 683, 5, 89, 0, 0, 683, 49, 1, 0, 0, 0, 684, 689, 3, 52, 26, 0,
		685, 686, 5, 83, 0, 0, 686, 688, 3, 52, 26, 0, 687, 685, 1, 0, 0, 0, 688,
		691, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 51, 1,
		0, 0, 0, 691, 689, 1, 0, 0, 0, 692, 695, 3, 24, 12, 0, 693, 695, 3, 54,
		27, 0, 694, 692, 1, 0, 0, 0, 694, 693, 1, 0, 0, 0, 695, 53, 1, 0, 0, 0,
		696, 698, 3, 262, 131, 0, 697, 696, 1, 0, 0, 0, 698, 701, 1, 0, 0, 0, 699,
		697, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 702, 1, 0, 0, 0, 701, 699,
		1, 0, 0, 0, 702, 704, 5, 93, 0, 0, 703, 705, 3, 56, 28, 0, 704, 703, 1,
		0, 0, 0, 704, 705, 1, 0, 0, 0, 705, 55, 1, 0, 0, 0, 706, 707, 5, 34, 0,
		0, 707, 711, 3, 24, 12, 0, 708, 709, 5, 57, 0, 0, 709, 711, 3, 24, 12,
		0, 710, 706, 1, 0, 0, 0, 710, 708, 1, 0, 0, 0, 711, 57, 1, 0, 0, 0, 712,
		715, 3, 2, 1, 0, 713, 714, 5, 84, 0, 0, 714, 716, 3, 58, 29, 0, 715, 713,
		1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 59, 1, 0, 0, 0, 717, 720, 3, 2,
		1, 0, 718, 719, 5, 84, 0, 0, 719, 721, 3, 60, 30, 0, 720, 718, 1, 0, 0,
		0, 720, 721, 1, 0, 0, 0, 721, 61, 1, 0, 0, 0, 722, 725, 3, 60, 30, 0, 723,
		724, 5, 84, 0, 0, 724, 726, 3, 4, 2, 0, 725, 723, 1, 0, 0, 0, 725, 726,
		1, 0, 0, 0, 726, 63, 1, 0, 0, 0, 727, 730, 3, 2, 1, 0, 728, 729, 5, 84,
		0, 0, 729, 731, 3, 64, 32, 0, 730, 728, 1, 0, 0, 0, 730, 731, 1, 0, 0,
		0, 731, 65, 1, 0, 0, 0, 732, 733, 3, 70, 35, 0, 733, 734, 5, 84, 0, 0,
		734, 736, 1, 0, 0, 0, 735, 732, 1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736,
		737, 1, 0, 0, 0, 737, 738, 3, 2, 1, 0, 738, 67, 1, 0, 0, 0, 739, 740, 3,
		6, 3, 0, 740, 69, 1, 0, 0, 0, 741, 744, 3, 2, 1, 0, 742, 743, 5, 84, 0,
		0, 743, 745, 3, 70, 35, 0, 744, 742, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0,
		745, 71, 1, 0, 0, 0, 746, 749, 3, 74, 37, 0, 747, 749, 3, 76, 38, 0, 748,
		746, 1, 0, 0, 0, 748, 747, 1, 0, 0, 0, 749, 73, 1, 0, 0, 0, 750, 752, 3,
		78, 39, 0, 751, 750, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 756, 1, 0,
		0, 0, 753, 755, 3, 82, 41, 0, 754, 753, 1, 0, 0, 0, 755, 758, 1, 0, 0,
		0, 756, 754, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 762, 1, 0, 0, 0, 758,
		756, 1, 0, 0, 0, 759, 761, 3, 92, 46, 0, 760, 759, 1, 0, 0, 0, 761, 764,
		1, 0, 0, 0, 762, 760, 1, 0, 0, 0, 762, 763, 1, 0, 0, 0, 763, 75, 1, 0,
		0, 0, 764, 762, 1, 0, 0, 0, 765, 767, 3, 82, 41, 0, 766, 765, 1, 0, 0,
		0, 767, 770, 1, 0, 0, 0, 768, 766, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769,
		771, 1, 0, 0, 0, 770, 768, 1, 0, 0, 0, 771, 772, 3, 94, 47, 0, 772, 77,
		1, 0, 0, 0, 773, 775, 3, 80, 40, 0, 774, 773, 1, 0, 0, 0, 775, 778, 1,
		0, 0, 0, 776, 774, 1, 0, 0, 0, 776, 777, 1, 0, 0, 0, 777, 779, 1, 0, 0,
		0, 778, 776, 1, 0, 0, 0, 779, 780, 5, 49, 0, 0, 780, 785, 3, 2, 1, 0, 781,
		782, 5, 84, 0, 0, 782, 784, 3, 2, 1, 0, 783, 781, 1, 0, 0, 0, 784, 787,
		1, 0, 0, 0, 785, 783, 1, 0, 0, 0, 785, 786, 1, 0, 0, 0, 786, 788, 1, 0,
		0, 0, 787, 785, 1, 0, 0, 0, 788, 789, 5, 82, 0, 0, 789, 79, 1, 0, 0, 0,
		790, 791, 3, 262, 131, 0, 791, 81, 1, 0, 0, 0, 792, 797, 3, 84, 42, 0,
		793, 797, 3, 86, 43, 0, 794, 797, 3, 88, 44, 0, 795, 797, 3, 90, 45, 0,
		796, 792, 1, 0, 0, 0, 796, 793, 1, 0, 0, 0, 796, 794, 1, 0, 0, 0, 796,
		795, 1, 0, 0, 0, 797, 83, 1, 0, 0, 0, 798, 799, 5, 42, 0, 0, 799, 800,
		3, 62, 31, 0, 800, 801, 5, 82, 0, 0, 801, 85, 1, 0, 0, 0, 802, 803, 5,
		42, 0, 0, 803, 804, 3, 64, 32, 0, 804, 805, 5, 84, 0, 0, 805, 806, 5, 106,
		0, 0, 806, 807, 5, 82, 0, 0, 807, 87, 1, 0, 0, 0, 808, 809, 5, 42, 0, 0,
		809, 810, 5, 55, 0, 0, 810, 811, 3, 62, 31, 0, 811, 812, 5, 84, 0, 0, 812,
		813, 3, 2, 1, 0, 813, 814, 5, 82, 0, 0, 814, 89, 1, 0, 0, 0, 815, 816,
		5, 42, 0, 0, 816, 817, 5, 55, 0, 0, 817, 818, 3, 62, 31, 0, 818, 819, 5,
		84, 0, 0, 819, 820, 5, 106, 0, 0, 820, 821, 5, 82, 0, 0, 821, 91, 1, 0,
		0, 0, 822, 826, 3, 100, 50, 0, 823, 826, 3, 228, 114, 0, 824, 826, 5, 82,
		0, 0, 825, 822, 1, 0, 0, 0, 825, 823, 1, 0, 0, 0, 825, 824, 1, 0, 0, 0,
		826, 93, 1, 0, 0, 0, 827, 829, 3, 262, 131, 0, 828, 827, 1, 0, 0, 0, 829,
		832, 1, 0, 0, 0, 830, 828, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 834,
		1, 0, 0, 0, 832, 830, 1, 0, 0, 0, 833, 835, 5, 5, 0, 0, 834, 833, 1, 0,
		0, 0, 834, 835, 1, 0, 0, 0, 835, 836, 1, 0, 0, 0, 836, 837, 5, 2, 0, 0,
		837, 842, 3, 2, 1, 0, 838, 839, 5, 84, 0, 0, 839, 841, 3, 2, 1, 0, 840,
		838, 1, 0, 0, 0, 841, 844, 1, 0, 0, 0, 842, 840, 1, 0, 0, 0, 842, 843,
		1, 0, 0, 0, 843, 845, 1, 0, 0, 0, 844, 842, 1, 0, 0, 0, 845, 849, 5, 78,
		0, 0, 846, 848, 3, 96, 48, 0, 847, 846, 1, 0, 0, 0, 848, 851, 1, 0, 0,
		0, 849, 847, 1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850, 852, 1, 0, 0, 0, 851,
		849, 1, 0, 0, 0, 852, 853, 5, 79, 0, 0, 853, 95, 1, 0, 0, 0, 854, 858,
		5, 10, 0, 0, 855, 857, 3, 98, 49, 0, 856, 855, 1, 0, 0, 0, 857, 860, 1,
		0, 0, 0, 858, 856, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 861, 1, 0, 0,
		0, 860, 858, 1, 0, 0, 0, 861, 862, 3, 58, 29, 0, 862, 863, 5, 82, 0, 0,
		863, 912, 1, 0, 0, 0, 864, 865, 5, 1, 0, 0, 865, 875, 3, 60, 30, 0, 866,
		867, 5, 12, 0, 0, 867, 872, 3, 58, 29, 0, 868, 869, 5, 83, 0, 0, 869, 871,
		3, 58, 29, 0, 870, 868, 1, 0, 0, 0, 871, 874, 1, 0, 0, 0, 872, 870, 1,
		0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 876, 1, 0, 0, 0, 874, 872, 1, 0, 0,
		0, 875, 866, 1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877,
		878, 5, 82, 0, 0, 878, 912, 1, 0, 0, 0, 879, 880, 5, 6, 0, 0, 880, 890,
		3, 60, 30, 0, 881, 882, 5, 12, 0, 0, 882, 887, 3, 58, 29, 0, 883, 884,
		5, 83, 0, 0, 884, 886, 3, 58, 29, 0, 885, 883, 1, 0, 0, 0, 886, 889, 1,
		0, 0, 0, 887, 885, 1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888, 891, 1, 0, 0,
		0, 889, 887, 1, 0, 0, 0, 890, 881, 1, 0, 0, 0, 890, 891, 1, 0, 0, 0, 891,
		892, 1, 0, 0, 0, 892, 893, 5, 82, 0, 0, 893, 912, 1, 0, 0, 0, 894, 895,
		5, 14, 0, 0, 895, 896, 3, 62, 31, 0, 896, 897, 5, 82, 0, 0, 897, 912, 1,
		0, 0, 0, 898, 899, 5, 8, 0, 0, 899, 900, 3, 62, 31, 0, 900, 901, 5, 16,
		0, 0, 901, 906, 3, 62, 31, 0, 902, 903, 5, 83, 0, 0, 903, 905, 3, 62, 31,
		0, 904, 902, 1, 0, 0, 0, 905, 908, 1, 0, 0, 0, 906, 904, 1, 0, 0, 0, 906,
		907, 1, 0, 0, 0, 907, 909, 1, 0, 0, 0, 908, 906, 1, 0, 0, 0, 909, 910,
		5, 82, 0, 0, 910, 912, 1, 0, 0, 0, 911, 854, 1, 0, 0, 0, 911, 864, 1, 0,
		0, 0, 911, 879, 1, 0, 0, 0, 911, 894, 1, 0, 0, 0, 911, 898, 1, 0, 0, 0,
		912, 97, 1, 0, 0, 0, 913, 914, 7, 6, 0, 0, 914, 99, 1, 0, 0, 0, 915, 919,
		3, 102, 51, 0, 916, 919, 3, 198, 99, 0, 917, 919, 3, 210, 105, 0, 918,
		915, 1, 0, 0, 0, 918, 916, 1, 0, 0, 0, 918, 917, 1, 0, 0, 0, 919, 101,
		1, 0, 0, 0, 920, 922, 3, 104, 52, 0, 921, 920, 1, 0, 0, 0, 922, 925, 1,
		0, 0, 0, 923, 921, 1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 926, 1, 0, 0,
		0, 925, 923, 1, 0, 0, 0, 926, 927, 5, 26, 0, 0, 927, 929, 3, 4, 2, 0, 928,
		930, 3, 106, 53, 0, 929, 928, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 932,
		1, 0, 0, 0, 931, 933, 3, 110, 55, 0, 932, 931, 1, 0, 0, 0, 932, 933, 1,
		0, 0, 0, 933, 935, 1, 0, 0, 0, 934, 936, 3, 112, 56, 0, 935, 934, 1, 0,
		0, 0, 935, 936, 1, 0, 0, 0, 936, 938, 1, 0, 0, 0, 937, 939, 3, 116, 58,
		0, 938, 937, 1, 0, 0, 0, 938, 939, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940,
		941, 3, 118, 59, 0, 941, 103, 1, 0, 0, 0, 942, 953, 3, 262, 131, 0, 943,
		953, 5, 52, 0, 0, 944, 953, 5, 51, 0, 0, 945, 953, 5, 50, 0, 0, 946, 953,
		5, 18, 0, 0, 947, 953, 5, 55, 0, 0, 948, 953, 5, 35, 0, 0, 949, 953, 5,
		11, 0, 0, 950, 953, 5, 3, 0, 0, 951, 953, 5, 56, 0, 0, 952, 942, 1, 0,
		0, 0, 952, 943, 1, 0, 0, 0, 952, 944, 1, 0, 0, 0, 952, 945, 1, 0, 0, 0,
		952, 946, 1, 0, 0, 0, 952, 947, 1, 0, 0, 0, 952, 948, 1, 0, 0, 0, 952,
		949, 1, 0, 0, 0, 952, 950, 1, 0, 0, 0, 952, 951, 1, 0, 0, 0, 953, 105,
		1, 0, 0, 0, 954, 955, 5, 90, 0, 0, 955, 956, 3, 108, 54, 0, 956, 957, 5,
		89, 0, 0, 957, 107, 1, 0, 0, 0, 958, 963, 3, 40, 20, 0, 959, 960, 5, 83,
		0, 0, 960, 962, 3, 40, 20, 0, 961, 959, 1, 0, 0, 0, 962, 965, 1, 0, 0,
		0, 963, 961, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964, 109, 1, 0, 0, 0, 965,
		963, 1, 0, 0, 0, 966, 967, 5, 34, 0, 0, 967, 968, 3, 30, 15, 0, 968, 111,
		1, 0, 0, 0, 969, 970, 5, 41, 0, 0, 970, 971, 3, 114, 57, 0, 971, 113, 1,
		0, 0, 0, 972, 977, 3, 32, 16, 0, 973, 974, 5, 83, 0, 0, 974, 976, 3, 32,
		16, 0, 975, 973, 1, 0, 0, 0, 976, 979, 1, 0, 0, 0, 977, 975, 1, 0, 0, 0,
		977, 978, 1, 0, 0, 0, 978, 115, 1, 0, 0, 0, 979, 977, 1, 0, 0, 0, 980,
		981, 5, 7, 0, 0, 981, 986, 3, 62, 31, 0, 982, 983, 5, 83, 0, 0, 983, 985,
		3, 62, 31, 0, 984, 982, 1, 0, 0, 0, 985, 988, 1, 0, 0, 0, 986, 984, 1,
		0, 0, 0, 986, 987, 1, 0, 0, 0, 987, 117, 1, 0, 0, 0, 988, 986, 1, 0, 0,
		0, 989, 993, 5, 78, 0, 0, 990, 992, 3, 120, 60, 0, 991, 990, 1, 0, 0, 0,
		992, 995, 1, 0, 0, 0, 993, 991, 1, 0, 0, 0, 993, 994, 1, 0, 0, 0, 994,
		996, 1, 0, 0, 0, 995, 993, 1, 0, 0, 0, 996, 997, 5, 79, 0, 0, 997, 119,
		1, 0, 0, 0, 998, 1003, 3, 122, 61, 0, 999, 1003, 3, 182, 91, 0, 1000, 1003,
		3, 184, 92, 0, 1001, 1003, 3, 186, 93, 0, 1002, 998, 1, 0, 0, 0, 1002,
		999, 1, 0, 0, 0, 1002, 1000, 1, 0, 0, 0, 1002, 1001, 1, 0, 0, 0, 1003,
		121, 1, 0, 0, 0, 1004, 1010, 3, 124, 62, 0, 1005, 1010, 3, 154, 77, 0,
		1006, 1010, 3, 100, 50, 0, 1007, 1010, 3, 228, 114, 0, 1008, 1010, 5, 82,
		0, 0, 1009, 1004, 1, 0, 0, 0, 1009, 1005, 1, 0, 0, 0, 1009, 1006, 1, 0,
		0, 0, 1009, 1007, 1, 0, 0, 0, 1009, 1008, 1, 0, 0, 0, 1010, 123, 1, 0,
		0, 0, 1011, 1013, 3, 126, 63, 0, 1012, 1011, 1, 0, 0, 0, 1013, 1016, 1,
		0, 0, 0, 1014, 1012, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 1017, 1,
		0, 0, 0, 1016, 1014, 1, 0, 0, 0, 1017, 1018, 3, 136, 68, 0, 1018, 1019,
		3, 128, 64, 0, 1019, 1020, 5, 82, 0, 0, 1020, 125, 1, 0, 0, 0, 1021, 1030,
		3, 262, 131, 0, 1022, 1030, 5, 52, 0, 0, 1023, 1030, 5, 51, 0, 0, 1024,
		1030, 5, 50, 0, 0, 1025, 1030, 5, 55, 0, 0, 1026, 1030, 5, 35, 0, 0, 1027,
		1030, 5, 63, 0, 0, 1028, 1030, 5, 66, 0, 0, 1029, 1021, 1, 0, 0, 0, 1029,
		1022, 1, 0, 0, 0, 1029, 1023, 1, 0, 0, 0, 1029, 1024, 1, 0, 0, 0, 1029,
		1025, 1, 0, 0, 0, 1029, 1026, 1, 0, 0, 0, 1029, 1027, 1, 0, 0, 0, 1029,
		1028, 1, 0, 0, 0, 1030, 127, 1, 0, 0, 0, 1031, 1036, 3, 130, 65, 0, 1032,
		1033, 5, 83, 0, 0, 1033, 1035, 3, 130, 65, 0, 1034, 1032, 1, 0, 0, 0, 1035,
		1038, 1, 0, 0, 0, 1036, 1034, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037,
		129, 1, 0, 0, 0, 1038, 1036, 1, 0, 0, 0, 1039, 1042, 3, 132, 66, 0, 1040,
		1041, 5, 88, 0, 0, 1041, 1043, 3, 134, 67, 0, 1042, 1040, 1, 0, 0, 0, 1042,
		1043, 1, 0, 0, 0, 1043, 131, 1, 0, 0, 0, 1044, 1046, 3, 2, 1, 0, 1045,
		1047, 3, 38, 19, 0, 1046, 1045, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047,
		133, 1, 0, 0, 0, 1048, 1051, 3, 396, 198, 0, 1049, 1051, 3, 280, 140, 0,
		1050, 1048, 1, 0, 0, 0, 1050, 1049, 1, 0, 0, 0, 1051, 135, 1, 0, 0, 0,
		1052, 1055, 3, 138, 69, 0, 1053, 1055, 3, 140, 70, 0, 1054, 1052, 1, 0,
		0, 0, 1054, 1053, 1, 0, 0, 0, 1055, 137, 1, 0, 0, 0, 1056, 1059, 3, 18,
		9, 0, 1057, 1059, 5, 20, 0, 0, 1058, 1056, 1, 0, 0, 0, 1058, 1057, 1, 0,
		0, 0, 1059, 139, 1, 0, 0, 0, 1060, 1064, 3, 142, 71, 0, 1061, 1064, 3,
		150, 75, 0, 1062, 1064, 3, 152, 76, 0, 1063, 1060, 1, 0, 0, 0, 1063, 1061,
		1, 0, 0, 0, 1063, 1062, 1, 0, 0, 0, 1064, 141, 1, 0, 0, 0, 1065, 1066,
		3, 60, 30, 0, 1066, 1070, 5, 84, 0, 0, 1067, 1069, 3, 262, 131, 0, 1068,
		1067, 1, 0, 0, 0, 1069, 1072, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1070,
		1071, 1, 0, 0, 0, 1071, 1074, 1, 0, 0, 0, 1072, 1070, 1, 0, 0, 0, 1073,
		1065, 1, 0, 0, 0, 1073, 1074, 1, 0, 0, 0, 1074, 1075, 1, 0, 0, 0, 1075,
		1077, 3, 4, 2, 0, 1076, 1078, 3, 48, 24, 0, 1077, 1076, 1, 0, 0, 0, 1077,
		1078, 1, 0, 0, 0, 1078, 1080, 1, 0, 0, 0, 1079, 1081, 3, 144, 72, 0, 1080,
		1079, 1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 143, 1, 0, 0, 0, 1082,
		1086, 5, 84, 0, 0, 1083, 1085, 3, 262, 131, 0, 1084, 1083, 1, 0, 0, 0,
		1085, 1088, 1, 0, 0, 0, 1086, 1084, 1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0,
		1087, 1089, 1, 0, 0, 0, 1088, 1086, 1, 0, 0, 0, 1089, 1091, 3, 4, 2, 0,
		1090, 1092, 3, 48, 24, 0, 1091, 1090, 1, 0, 0, 0, 1091, 1092, 1, 0, 0,
		0, 1092, 1094, 1, 0, 0, 0, 1093, 1095, 3, 144, 72, 0, 1094, 1093, 1, 0,
		0, 0, 1094, 1095, 1, 0, 0, 0, 1095, 145, 1, 0, 0, 0, 1096, 1098, 3, 4,
		2, 0, 1097, 1099, 3, 48, 24, 0, 1098, 1097, 1, 0, 0, 0, 1098, 1099, 1,
		0, 0, 0, 1099, 1116, 1, 0, 0, 0, 1100, 1103, 3, 60, 30, 0, 1101, 1103,
		3, 142, 71, 0, 1102, 1100, 1, 0, 0, 0, 1102, 1101, 1, 0, 0, 0, 1103, 1104,
		1, 0, 0, 0, 1104, 1108, 5, 84, 0, 0, 1105, 1107, 3, 262, 131, 0, 1106,
		1105, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 0, 1108, 1106, 1, 0, 0, 0, 1108,
		1109, 1, 0, 0, 0, 1109, 1111, 1, 0, 0, 0, 1110, 1108, 1, 0, 0, 0, 1111,
		1113, 3, 4, 2, 0, 1112, 1114, 3, 48, 24, 0, 1113, 1112, 1, 0, 0, 0, 1113,
		1114, 1, 0, 0, 0, 1114, 1116, 1, 0, 0, 0, 1115, 1096, 1, 0, 0, 0, 1115,
		1102, 1, 0, 0, 0, 1116, 147, 1, 0, 0, 0, 1117, 1118, 3, 146, 73, 0, 1118,
		149, 1, 0, 0, 0, 1119, 1120, 3, 4, 2, 0, 1120, 151, 1, 0, 0, 0, 1121, 1125,
		3, 138, 69, 0, 1122, 1125, 3, 142, 71, 0, 1123, 1125, 3, 150, 75, 0, 1124,
		1121, 1, 0, 0, 0, 1124, 1122, 1, 0, 0, 0, 1124, 1123, 1, 0, 0, 0, 1125,
		1126, 1, 0, 0, 0, 1126, 1127, 3, 38, 19, 0, 1127, 153, 1, 0, 0, 0, 1128,
		1130, 3, 156, 78, 0, 1129, 1128, 1, 0, 0, 0, 1130, 1133, 1, 0, 0, 0, 1131,
		1129, 1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 1134, 1, 0, 0, 0, 1133,
		1131, 1, 0, 0, 0, 1134, 1135, 3, 158, 79, 0, 1135, 1136, 3, 180, 90, 0,
		1136, 155, 1, 0, 0, 0, 1137, 1148, 3, 262, 131, 0, 1138, 1148, 5, 52, 0,
		0, 1139, 1148, 5, 51, 0, 0, 1140, 1148, 5, 50, 0, 0, 1141, 1148, 5, 18,
		0, 0, 1142, 1148, 5, 55, 0, 0, 1143, 1148, 5, 35, 0, 0, 1144, 1148, 5,
		59, 0, 0, 1145, 1148, 5, 47, 0, 0, 1146, 1148, 5, 56, 0, 0, 1147, 1137,
		1, 0, 0, 0, 1147, 1138, 1, 0, 0, 0, 1147, 1139, 1, 0, 0, 0, 1147, 1140,
		1, 0, 0, 0, 1147, 1141, 1, 0, 0, 0, 1147, 1142, 1, 0, 0, 0, 1147, 1143,
		1, 0, 0, 0, 1147, 1144, 1, 0, 0, 0, 1147, 1145, 1, 0, 0, 0, 1147, 1146,
		1, 0, 0, 0, 1148, 157, 1, 0, 0, 0, 1149, 1153, 3, 106, 53, 0, 1150, 1152,
		3, 262, 131, 0, 1151, 1150, 1, 0, 0, 0, 1152, 1155, 1, 0, 0, 0, 1153, 1151,
		1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 1157, 1, 0, 0, 0, 1155, 1153,
		1, 0, 0, 0, 1156, 1149, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1158,
		1, 0, 0, 0, 1158, 1159, 3, 160, 80, 0, 1159, 1161, 3, 162, 81, 0, 1160,
		1162, 3, 174, 87, 0, 1161, 1160, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162,
		159, 1, 0, 0, 0, 1163, 1166, 3, 136, 68, 0, 1164, 1166, 5, 65, 0, 0, 1165,
		1163, 1, 0, 0, 0, 1165, 1164, 1, 0, 0, 0, 1166, 161, 1, 0, 0, 0, 1167,
		1168, 3, 2, 1, 0, 1168, 1172, 5, 76, 0, 0, 1169, 1170, 3, 164, 82, 0, 1170,
		1171, 5, 83, 0, 0, 1171, 1173, 1, 0, 0, 0, 1172, 1169, 1, 0, 0, 0, 1172,
		1173, 1, 0, 0, 0, 1173, 1175, 1, 0, 0, 0, 1174, 1176, 3, 166, 83, 0, 1175,
		1174, 1, 0, 0, 0, 1175, 1176, 1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177,
		1179, 5, 77, 0, 0, 1178, 1180, 3, 38, 19, 0, 1179, 1178, 1, 0, 0, 0, 1179,
		1180, 1, 0, 0, 0, 1180, 163, 1, 0, 0, 0, 1181, 1183, 3, 262, 131, 0, 1182,
		1181, 1, 0, 0, 0, 1183, 1186, 1, 0, 0, 0, 1184, 1182, 1, 0, 0, 0, 1184,
		1185, 1, 0, 0, 0, 1185, 1187, 1, 0, 0, 0, 1186, 1184, 1, 0, 0, 0, 1187,
		1191, 3, 136, 68, 0, 1188, 1189, 3, 2, 1, 0, 1189, 1190, 5, 84, 0, 0, 1190,
		1192, 1, 0, 0, 0, 1191, 1188, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192,
		1193, 1, 0, 0, 0, 1193, 1194, 5, 60, 0, 0, 1194, 165, 1, 0, 0, 0, 1195,
		1200, 3, 168, 84, 0, 1196, 1197, 5, 83, 0, 0, 1197, 1199, 3, 168, 84, 0,
		1198, 1196, 1, 0, 0, 0, 1199, 1202, 1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0,
		1200, 1201, 1, 0, 0, 0, 1201, 167, 1, 0, 0, 0, 1202, 1200, 1, 0, 0, 0,
		1203, 1205, 3, 172, 86, 0, 1204, 1203, 1, 0, 0, 0, 1205, 1208, 1, 0, 0,
		0, 1206, 1204, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 1209, 1, 0, 0,
		0, 1208, 1206, 1, 0, 0, 0, 1209, 1210, 3, 136, 68, 0, 1210, 1211, 3, 132,
		66, 0, 1211, 1214, 1, 0, 0, 0, 1212, 1214, 3, 170, 85, 0, 1213, 1206, 1,
		0, 0, 0, 1213, 1212, 1, 0, 0, 0, 1214, 169, 1, 0, 0, 0, 1215, 1217, 3,
		172, 86, 0, 1216, 1215, 1, 0, 0, 0, 1217, 1220, 1, 0, 0, 0, 1218, 1216,
		1, 0, 0, 0, 1218, 1219, 1, 0, 0, 0, 1219, 1221, 1, 0, 0, 0, 1220, 1218,
		1, 0, 0, 0, 1221, 1225, 3, 136, 68, 0, 1222, 1224, 3, 262, 131, 0, 1223,
		1222, 1, 0, 0, 0, 1224, 1227, 1, 0, 0, 0, 1225, 1223, 1, 0, 0, 0, 1225,
		1226, 1, 0, 0, 0, 1226, 1228, 1, 0, 0, 0, 1227, 1225, 1, 0, 0, 0, 1228,
		1229, 5, 85, 0, 0, 1229, 1230, 3, 2, 1, 0, 1230, 171, 1, 0, 0, 0, 1231,
		1234, 3, 262, 131, 0, 1232, 1234, 5, 35, 0, 0, 1233, 1231, 1, 0, 0, 0,
		1233, 1232, 1, 0, 0, 0, 1234, 173, 1, 0, 0, 0, 1235, 1236, 5, 62, 0, 0,
		1236, 1237, 3, 176, 88, 0, 1237, 175, 1, 0, 0, 0, 1238, 1243, 3, 178, 89,
		0, 1239, 1240, 5, 83, 0, 0, 1240, 1242, 3, 178, 89, 0, 1241, 1239, 1, 0,
		0, 0, 1242, 1245, 1, 0, 0, 0, 1243, 1241, 1, 0, 0, 0, 1243, 1244, 1, 0,
		0, 0, 1244, 177, 1, 0, 0, 0, 1245, 1243, 1, 0, 0, 0, 1246, 1249, 3, 30,
		15, 0, 1247, 1249, 3, 34, 17, 0, 1248, 1246, 1, 0, 0, 0, 1248, 1247, 1,
		0, 0, 0, 1249, 179, 1, 0, 0, 0, 1250, 1253, 3, 284, 142, 0, 1251, 1253,
		5, 82, 0, 0, 1252, 1250, 1, 0, 0, 0, 1252, 1251, 1, 0, 0, 0, 1253, 181,
		1, 0, 0, 0, 1254, 1255, 3, 284, 142, 0, 1255, 183, 1, 0, 0, 0, 1256, 1257,
		5, 55, 0, 0, 1257, 1258, 3, 284, 142, 0, 1258, 185, 1, 0, 0, 0, 1259, 1261,
		3, 188, 94, 0, 1260, 1259, 1, 0, 0, 0, 1261, 1264, 1, 0, 0, 0, 1262, 1260,
		1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263, 1265, 1, 0, 0, 0, 1264, 1262,
		1, 0, 0, 0, 1265, 1267, 3, 190, 95, 0, 1266, 1268, 3, 174, 87, 0, 1267,
		1266, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269,
		1270, 3, 194, 97, 0, 1270, 187, 1, 0, 0, 0, 1271, 1276, 3, 262, 131, 0,
		1272, 1276, 5, 52, 0, 0, 1273, 1276, 5, 51, 0, 0, 1274, 1276, 5, 50, 0,
		0, 1275, 1271, 1, 0, 0, 0, 1275, 1272, 1, 0, 0, 0, 1275, 1273, 1, 0, 0,
		0, 1275, 1274, 1, 0, 0, 0, 1276, 189, 1, 0, 0, 0, 1277, 1279, 3, 106, 53,
		0, 1278, 1277, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0, 1279, 1280, 1, 0, 0,
		0, 1280, 1281, 3, 192, 96, 0, 1281, 1285, 5, 76, 0, 0, 1282, 1283, 3, 164,
		82, 0, 1283, 1284, 5, 83, 0, 0, 1284, 1286, 1, 0, 0, 0, 1285, 1282, 1,
		0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1288, 1, 0, 0, 0, 1287, 1289, 3,
		166, 83, 0, 1288, 1287, 1, 0, 0, 0, 1288, 1289, 1, 0, 0, 0, 1289, 1290,
		1, 0, 0, 0, 1290, 1291, 5, 77, 0, 0, 1291, 191, 1, 0, 0, 0, 1292, 1293,
		3, 4, 2, 0, 1293, 193, 1, 0, 0, 0, 1294, 1296, 5, 78, 0, 0, 1295, 1297,
		3, 196, 98, 0, 1296, 1295, 1, 0, 0, 0, 1296, 1297, 1, 0, 0, 0, 1297, 1299,
		1, 0, 0, 0, 1298, 1300, 3, 286, 143, 0, 1299, 1298, 1, 0, 0, 0, 1299, 1300,
		1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301, 1302, 5, 79, 0, 0, 1302, 195,
		1, 0, 0, 0, 1303, 1305, 3, 48, 24, 0, 1304, 1303, 1, 0, 0, 0, 1304, 1305,
		1, 0, 0, 0, 1305, 1306, 1, 0, 0, 0, 1306, 1307, 7, 7, 0, 0, 1307, 1309,
		5, 76, 0, 0, 1308, 1310, 3, 430, 215, 0, 1309, 1308, 1, 0, 0, 0, 1309,
		1310, 1, 0, 0, 0, 1310, 1311, 1, 0, 0, 0, 1311, 1312, 5, 77, 0, 0, 1312,
		1330, 5, 82, 0, 0, 1313, 1316, 3, 66, 33, 0, 1314, 1316, 3, 398, 199, 0,
		1315, 1313, 1, 0, 0, 0, 1315, 1314, 1, 0, 0, 0, 1316, 1317, 1, 0, 0, 0,
		1317, 1319, 5, 84, 0, 0, 1318, 1320, 3, 48, 24, 0, 1319, 1318, 1, 0, 0,
		0, 1319, 1320, 1, 0, 0, 0, 1320, 1321, 1, 0, 0, 0, 1321, 1322, 5, 57, 0,
		0, 1322, 1324, 5, 76, 0, 0, 1323, 1325, 3, 430, 215, 0, 1324, 1323, 1,
		0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 1327, 5,
		77, 0, 0, 1327, 1328, 5, 82, 0, 0, 1328, 1330, 1, 0, 0, 0, 1329, 1304,
		1, 0, 0, 0, 1329, 1315, 1, 0, 0, 0, 1330, 197, 1, 0, 0, 0, 1331, 1333,
		3, 104, 52, 0, 1332, 1331, 1, 0, 0, 0, 1333, 1336, 1, 0, 0, 0, 1334, 1332,
		1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 1337, 1, 0, 0, 0, 1336, 1334,
		1, 0, 0, 0, 1337, 1338, 5, 33, 0, 0, 1338, 1340, 3, 4, 2, 0, 1339, 1341,
		3, 112, 56, 0, 1340, 1339, 1, 0, 0, 0, 1340, 1341, 1, 0, 0, 0, 1341, 1342,
		1, 0, 0, 0, 1342, 1343, 3, 200, 100, 0, 1343, 199, 1, 0, 0, 0, 1344, 1346,
		5, 78, 0, 0, 1345, 1347, 3, 202, 101, 0, 1346, 1345, 1, 0, 0, 0, 1346,
		1347, 1, 0, 0, 0, 1347, 1349, 1, 0, 0, 0, 1348, 1350, 5, 83, 0, 0, 1349,
		1348, 1, 0, 0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 1352, 1, 0, 0, 0, 1351,
		1353, 3, 208, 104, 0, 1352, 1351, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353,
		1354, 1, 0, 0, 0, 1354, 1355, 5, 79, 0, 0, 1355, 201, 1, 0, 0, 0, 1356,
		1361, 3, 204, 102, 0, 1357, 1358, 5, 83, 0, 0, 1358, 1360, 3, 204, 102,
		0, 1359, 1357, 1, 0, 0, 0, 1360, 1363, 1, 0, 0, 0, 1361, 1359, 1, 0, 0,
		0, 1361, 1362, 1, 0, 0, 0, 1362, 203, 1, 0, 0, 0, 1363, 1361, 1, 0, 0,
		0, 1364, 1366, 3, 206, 103, 0, 1365, 1364, 1, 0, 0, 0, 1366, 1369, 1, 0,
		0, 0, 1367, 1365, 1, 0, 0, 0, 1367, 1368, 1, 0, 0, 0, 1368, 1370, 1, 0,
		0, 0, 1369, 1367, 1, 0, 0, 0, 1370, 1376, 3, 2, 1, 0, 1371, 1373, 5, 76,
		0, 0, 1372, 1374, 3, 430, 215, 0, 1373, 1372, 1, 0, 0, 0, 1373, 1374, 1,
		0, 0, 0, 1374, 1375, 1, 0, 0, 0, 1375, 1377, 5, 77, 0, 0, 1376, 1371, 1,
		0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 1379, 1, 0, 0, 0, 1378, 1380, 3,
		118, 59, 0, 1379, 1378, 1, 0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380, 205,
		1, 0, 0, 0, 1381, 1382, 3, 262, 131, 0, 1382, 207, 1, 0, 0, 0, 1383, 1387,
		5, 82, 0, 0, 1384, 1386, 3, 120, 60, 0, 1385, 1384, 1, 0, 0, 0, 1386, 1389,
		1, 0, 0, 0, 1387, 1385, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0, 1388, 209,
		1, 0, 0, 0, 1389, 1387, 1, 0, 0, 0, 1390, 1392, 3, 104, 52, 0, 1391, 1390,
		1, 0, 0, 0, 1392, 1395, 1, 0, 0, 0, 1393, 1391, 1, 0, 0, 0, 1393, 1394,
		1, 0, 0, 0, 1394, 1396, 1, 0, 0, 0, 1395, 1393, 1, 0, 0, 0, 1396, 1397,
		5, 9, 0, 0, 1397, 1399, 3, 4, 2, 0, 1398, 1400, 3, 106, 53, 0, 1399, 1398,
		1, 0, 0, 0, 1399, 1400, 1, 0, 0, 0, 1400, 1401, 1, 0, 0, 0, 1401, 1403,
		3, 212, 106, 0, 1402, 1404, 3, 112, 56, 0, 1403, 1402, 1, 0, 0, 0, 1403,
		1404, 1, 0, 0, 0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 3, 222, 111, 0, 1406,
		211, 1, 0, 0, 0, 1407, 1409, 5, 76, 0, 0, 1408, 1410, 3, 214, 107, 0, 1409,
		1408, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411,
		1412, 5, 77, 0, 0, 1412, 213, 1, 0, 0, 0, 1413, 1418, 3, 216, 108, 0, 1414,
		1415, 5, 83, 0, 0, 1415, 1417, 3, 216, 108, 0, 1416, 1414, 1, 0, 0, 0,
		1417, 1420, 1, 0, 0, 0, 1418, 1416, 1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0,
		1419, 215, 1, 0, 0, 0, 1420, 1418, 1, 0, 0, 0, 1421, 1423, 3, 220, 110,
		0, 1422, 1421, 1, 0, 0, 0, 1423, 1426, 1, 0, 0, 0, 1424, 1422, 1, 0, 0,
		0, 1424, 1425, 1, 0, 0, 0, 1425, 1427, 1, 0, 0, 0, 1426, 1424, 1, 0, 0,
		0, 1427, 1428, 3, 136, 68, 0, 1428, 1429, 3, 2, 1, 0, 1429, 1432, 1, 0,
		0, 0, 1430, 1432, 3, 218, 109, 0, 1431, 1424, 1, 0, 0, 0, 1431, 1430, 1,
		0, 0, 0, 1432, 217, 1, 0, 0, 0, 1433, 1435, 3, 220, 110, 0, 1434, 1433,
		1, 0, 0, 0, 1435, 1438, 1, 0, 0, 0, 1436, 1434, 1, 0, 0, 0, 1436, 1437,
		1, 0, 0, 0, 1437, 1439, 1, 0, 0, 0, 1438, 1436, 1, 0, 0, 0, 1439, 1443,
		3, 136, 68, 0, 1440, 1442, 3, 262, 131, 0, 1441, 1440, 1, 0, 0, 0, 1442,
		1445, 1, 0, 0, 0, 1443, 1441, 1, 0, 0, 0, 1443, 1444, 1, 0, 0, 0, 1444,
		1446, 1, 0, 0, 0, 1445, 1443, 1, 0, 0, 0, 1446, 1447, 5, 85, 0, 0, 1447,
		1448, 3, 2, 1, 0, 1448, 219, 1, 0, 0, 0, 1449, 1450, 3, 262, 131, 0, 1450,
		221, 1, 0, 0, 0, 1451, 1455, 5, 78, 0, 0, 1452, 1454, 3, 224, 112, 0, 1453,
		1452, 1, 0, 0, 0, 1454, 1457, 1, 0, 0, 0, 1455, 1453, 1, 0, 0, 0, 1455,
		1456, 1, 0, 0, 0, 1456, 1458, 1, 0, 0, 0, 1457, 1455, 1, 0, 0, 0, 1458,
		1459, 5, 79, 0, 0, 1459, 223, 1, 0, 0, 0, 1460, 1463, 3, 120, 60, 0, 1461,
		1463, 3, 226, 113, 0, 1462, 1460, 1, 0, 0, 0, 1462, 1461, 1, 0, 0, 0, 1463,
		225, 1, 0, 0, 0, 1464, 1466, 3, 188, 94, 0, 1465, 1464, 1, 0, 0, 0, 1466,
		1469, 1, 0, 0, 0, 1467, 1465, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468,
		1470, 1, 0, 0, 0, 1469, 1467, 1, 0, 0, 0, 1470, 1471, 3, 192, 96, 0, 1471,
		1472, 3, 194, 97, 0, 1472, 227, 1, 0, 0, 0, 1473, 1476, 3, 230, 115, 0,
		1474, 1476, 3, 250, 125, 0, 1475, 1473, 1, 0, 0, 0, 1475, 1474, 1, 0, 0,
		0, 1476, 229, 1, 0, 0, 0, 1477, 1479, 3, 232, 116, 0, 1478, 1477, 1, 0,
		0, 0, 1479, 1482, 1, 0, 0, 0, 1480, 1478, 1, 0, 0, 0, 1480, 1481, 1, 0,
		0, 0, 1481, 1483, 1, 0, 0, 0, 1482, 1480, 1, 0, 0, 0, 1483, 1484, 5, 45,
		0, 0, 1484, 1486, 3, 4, 2, 0, 1485, 1487, 3, 106, 53, 0, 1486, 1485, 1,
		0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1489, 1, 0, 0, 0, 1488, 1490, 3,
		234, 117, 0, 1489, 1488, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1492,
		1, 0, 0, 0, 1491, 1493, 3, 236, 118, 0, 1492, 1491, 1, 0, 0, 0, 1492, 1493,
		1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 1495, 3, 238, 119, 0, 1495, 231,
		1, 0, 0, 0, 1496, 1506, 3, 262, 131, 0, 1497, 1506, 5, 52, 0, 0, 1498,
		1506, 5, 51, 0, 0, 1499, 1506, 5, 50, 0, 0, 1500, 1506, 5, 18, 0, 0, 1501,
		1506, 5, 55, 0, 0, 1502, 1506, 5, 11, 0, 0, 1503, 1506, 5, 3, 0, 0, 1504,
		1506, 5, 56, 0, 0, 1505, 1496, 1, 0, 0, 0, 1505, 1497, 1, 0, 0, 0, 1505,
		1498, 1, 0, 0, 0, 1505, 1499, 1, 0, 0, 0, 1505, 1500, 1, 0, 0, 0, 1505,
		1501, 1, 0, 0, 0, 1505, 1502, 1, 0, 0, 0, 1505, 1503, 1, 0, 0, 0, 1505,
		1504, 1, 0, 0, 0, 1506, 233, 1, 0, 0, 0, 1507, 1508, 5, 34, 0, 0, 1508,
		1509, 3, 114, 57, 0, 1509, 235, 1, 0, 0, 0, 1510, 1511, 5, 7, 0, 0, 1511,
		1516, 3, 62, 31, 0, 1512, 1513, 5, 83, 0, 0, 1513, 1515, 3, 62, 31, 0,
		1514, 1512, 1, 0, 0, 0, 1515, 1518, 1, 0, 0, 0, 1516, 1514, 1, 0, 0, 0,
		1516, 1517, 1, 0, 0, 0, 1517, 237, 1, 0, 0, 0, 1518, 1516, 1, 0, 0, 0,
		1519, 1523, 5, 78, 0, 0, 1520, 1522, 3, 240, 120, 0, 1521, 1520, 1, 0,
		0, 0, 1522, 1525, 1, 0, 0, 0, 1523, 1521, 1, 0, 0, 0, 1523, 1524, 1, 0,
		0, 0, 1524, 1526, 1, 0, 0, 0, 1525, 1523, 1, 0, 0, 0, 1526, 1527, 5, 79,
		0, 0, 1527, 239, 1, 0, 0, 0, 1528, 1534, 3, 242, 121, 0, 1529, 1534, 3,
		246, 123, 0, 1530, 1534, 3, 100, 50, 0, 1531, 1534, 3, 228, 114, 0, 1532,
		1534, 5, 82, 0, 0, 1533, 1528, 1, 0, 0, 0, 1533, 1529, 1, 0, 0, 0, 1533,
		1530, 1, 0, 0, 0, 1533, 1531, 1, 0, 0, 0, 1533, 1532, 1, 0, 0, 0, 1534,
		241, 1, 0, 0, 0, 1535, 1537, 3, 244, 122, 0, 1536, 1535, 1, 0, 0, 0, 1537,
		1540, 1, 0, 0, 0, 1538, 1536, 1, 0, 0, 0, 1538, 1539, 1, 0, 0, 0, 1539,
		1541, 1, 0, 0, 0, 1540, 1538, 1, 0, 0, 0, 1541, 1542, 3, 136, 68, 0, 1542,
		1543, 3, 128, 64, 0, 1543, 1544, 5, 82, 0, 0, 1544, 243, 1, 0, 0, 0, 1545,
		1550, 3, 262, 131, 0, 1546, 1550, 5, 52, 0, 0, 1547, 1550, 5, 55, 0, 0,
		1548, 1550, 5, 35, 0, 0, 1549, 1545, 1, 0, 0, 0, 1549, 1546, 1, 0, 0, 0,
		1549, 1547, 1, 0, 0, 0, 1549, 1548, 1, 0, 0, 0, 1550, 245, 1, 0, 0, 0,
		1551, 1553, 3, 248, 124, 0, 1552, 1551, 1, 0, 0, 0, 1553, 1556, 1, 0, 0,
		0, 1554, 1552, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1557, 1, 0, 0,
		0, 1556, 1554, 1, 0, 0, 0, 1557, 1558, 3, 158, 79, 0, 1558, 1559, 3, 180,
		90, 0, 1559, 247, 1, 0, 0, 0, 1560, 1568, 3, 262, 131, 0, 1561, 1568, 5,
		52, 0, 0, 1562, 1568, 5, 50, 0, 0, 1563, 1568, 5, 18, 0, 0, 1564, 1568,
		5, 29, 0, 0, 1565, 1568, 5, 55, 0, 0, 1566, 1568, 5, 56, 0, 0, 1567, 1560,
		1, 0, 0, 0, 1567, 1561, 1, 0, 0, 0, 1567, 1562, 1, 0, 0, 0, 1567, 1563,
		1, 0, 0, 0, 1567, 1564, 1, 0, 0, 0, 1567, 1565, 1, 0, 0, 0, 1567, 1566,
		1, 0, 0, 0, 1568, 249, 1, 0, 0, 0, 1569, 1571, 3, 232, 116, 0, 1570, 1569,
		1, 0, 0, 0, 1571, 1574, 1, 0, 0, 0, 1572, 1570, 1, 0, 0, 0, 1572, 1573,
		1, 0, 0, 0, 1573, 1575, 1, 0, 0, 0, 1574, 1572, 1, 0, 0, 0, 1575, 1576,
		5, 86, 0, 0, 1576, 1577, 5, 45, 0, 0, 1577, 1578, 3, 4, 2, 0, 1578, 1579,
		3, 252, 126, 0, 1579, 251, 1, 0, 0, 0, 1580, 1584, 5, 78, 0, 0, 1581, 1583,
		3, 254, 127, 0, 1582, 1581, 1, 0, 0, 0, 1583, 1586, 1, 0, 0, 0, 1584, 1582,
		1, 0, 0, 0, 1584, 1585, 1, 0, 0, 0, 1585, 1587, 1, 0, 0, 0, 1586, 1584,
		1, 0, 0, 0, 1587, 1588, 5, 79, 0, 0, 1588, 253, 1, 0, 0, 0, 1589, 1595,
		3, 256, 128, 0, 1590, 1595, 3, 242, 121, 0, 1591, 1595, 3, 100, 50, 0,
		1592, 1595, 3, 228, 114, 0, 1593, 1595, 5, 82, 0, 0, 1594, 1589, 1, 0,
		0, 0, 1594, 1590, 1, 0, 0, 0, 1594, 1591, 1, 0, 0, 0, 1594, 1592, 1, 0,
		0, 0, 1594, 1593, 1, 0, 0, 0, 1595, 255, 1, 0, 0, 0, 1596, 1598, 3, 258,
		129, 0, 1597, 1596, 1, 0, 0, 0, 1598, 1601, 1, 0, 0, 0, 1599, 1597, 1,
		0, 0, 0, 1599, 1600, 1, 0, 0, 0, 1600, 1602, 1, 0, 0, 0, 1601, 1599, 1,
		0, 0, 0, 1602, 1603, 3, 136, 68, 0, 1603, 1604, 3, 2, 1, 0, 1604, 1605,
		5, 76, 0, 0, 1605, 1607, 5, 77, 0, 0, 1606, 1608, 3, 38, 19, 0, 1607, 1606,
		1, 0, 0, 0, 1607, 1608, 1, 0, 0, 0, 1608, 1610, 1, 0, 0, 0, 1609, 1611,
		3, 260, 130, 0, 1610, 1609, 1, 0, 0, 0, 1610, 1611, 1, 0, 0, 0, 1611, 1612,
		1, 0, 0, 0, 1612, 1613, 5, 82, 0, 0, 1613, 257, 1, 0, 0, 0, 1614, 1618,
		3, 262, 131, 0, 1615, 1618, 5, 52, 0, 0, 1616, 1618, 5, 18, 0, 0, 1617,
		1614, 1, 0, 0, 0, 1617, 1615, 1, 0, 0, 0, 1617, 1616, 1, 0, 0, 0, 1618,
		259, 1, 0, 0, 0, 1619, 1620, 5, 29, 0, 0, 1620, 1621, 3, 270, 135, 0, 1621,
		261, 1, 0, 0, 0, 1622, 1626, 3, 264, 132, 0, 1623, 1626, 3, 276, 138, 0,
		1624, 1626, 3, 278, 139, 0, 1625, 1622, 1, 0, 0, 0, 1625, 1623, 1, 0, 0,
		0, 1625, 1624, 1, 0, 0, 0, 1626, 263, 1, 0, 0, 0, 1627, 1628, 5, 86, 0,
		0, 1628, 1629, 3, 62, 31, 0, 1629, 1631, 5, 76, 0, 0, 1630, 1632, 3, 266,
		133, 0, 1631, 1630, 1, 0, 0, 0, 1631, 1632, 1, 0, 0, 0, 1632, 1633, 1,
		0, 0, 0, 1633, 1634, 5, 77, 0, 0, 1634, 265, 1, 0, 0, 0, 1635, 1640, 3,
		268, 134, 0, 1636, 1637, 5, 83, 0, 0, 1637, 1639, 3, 268, 134, 0, 1638,
		1636, 1, 0, 0, 0, 1639, 1642, 1, 0, 0, 0, 1640, 1638, 1, 0, 0, 0, 1640,
		1641, 1, 0, 0, 0, 1641, 267, 1, 0, 0, 0, 1642, 1640, 1, 0, 0, 0, 1643,
		1644, 3, 2, 1, 0, 1644, 1645, 5, 88, 0, 0, 1645, 1646, 3, 270, 135, 0,
		1646, 269, 1, 0, 0, 0, 1647, 1651, 3, 472, 236, 0, 1648, 1651, 3, 272,
		136, 0, 1649, 1651, 3, 262, 131, 0, 1650, 1647, 1, 0, 0, 0, 1650, 1648,
		1, 0, 0, 0, 1650, 1649, 1, 0, 0, 0, 1651, 271, 1, 0, 0, 0, 1652, 1654,
		5, 78, 0, 0, 1653, 1655, 3, 274, 137, 0, 1654, 1653, 1, 0, 0, 0, 1654,
		1655, 1, 0, 0, 0, 1655, 1657, 1, 0, 0, 0, 1656, 1658, 5, 83, 0, 0, 1657,
		1656, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0, 1659,
		1660, 5, 79, 0, 0, 1660, 273, 1, 0, 0, 0, 1661, 1666, 3, 270, 135, 0, 1662,
		1663, 5, 83, 0, 0, 1663, 1665, 3, 270, 135, 0, 1664, 1662, 1, 0, 0, 0,
		1665, 1668, 1, 0, 0, 0, 1666, 1664, 1, 0, 0, 0, 1666, 1667, 1, 0, 0, 0,
		1667, 275, 1, 0, 0, 0, 1668, 1666, 1, 0, 0, 0, 1669, 1670, 5, 86, 0, 0,
		1670, 1671, 3, 62, 31, 0, 1671, 277, 1, 0, 0, 0, 1672, 1673, 5, 86, 0,
		0, 1673, 1674, 3, 62, 31, 0, 1674, 1675, 5, 76, 0, 0, 1675, 1676, 3, 270,
		135, 0, 1676, 1677, 5, 77, 0, 0, 1677, 279, 1, 0, 0, 0, 1678, 1680, 5,
		78, 0, 0, 1679, 1681, 3, 282, 141, 0, 1680, 1679, 1, 0, 0, 0, 1680, 1681,
		1, 0, 0, 0, 1681, 1683, 1, 0, 0, 0, 1682, 1684, 5, 83, 0, 0, 1683, 1682,
		1, 0, 0, 0, 1683, 1684, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1686,
		5, 79, 0, 0, 1686, 281, 1, 0, 0, 0, 1687, 1692, 3, 134, 67, 0, 1688, 1689,
		5, 83, 0, 0, 1689, 1691, 3, 134, 67, 0, 1690, 1688, 1, 0, 0, 0, 1691, 1694,
		1, 0, 0, 0, 1692, 1690, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693, 283,
		1, 0, 0, 0, 1694, 1692, 1, 0, 0, 0, 1695, 1697, 5, 78, 0, 0, 1696, 1698,
		3, 286, 143, 0, 1697, 1696, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1699,
		1, 0, 0, 0, 1699, 1700, 5, 79, 0, 0, 1700, 285, 1, 0, 0, 0, 1701, 1705,
		3, 288, 144, 0, 1702, 1704, 3, 288, 144, 0, 1703, 1702, 1, 0, 0, 0, 1704,
		1707, 1, 0, 0, 0, 1705, 1703, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0, 1706,
		287, 1, 0, 0, 0, 1707, 1705, 1, 0, 0, 0, 1708, 1712, 3, 290, 145, 0, 1709,
		1712, 3, 296, 148, 0, 1710, 1712, 3, 298, 149, 0, 1711, 1708, 1, 0, 0,
		0, 1711, 1709, 1, 0, 0, 0, 1711, 1710, 1, 0, 0, 0, 1712, 289, 1, 0, 0,
		0, 1713, 1716, 3, 100, 50, 0, 1714, 1716, 3, 230, 115, 0, 1715, 1713, 1,
		0, 0, 0, 1715, 1714, 1, 0, 0, 0, 1716, 291, 1, 0, 0, 0, 1717, 1719, 3,
		172, 86, 0, 1718, 1717, 1, 0, 0, 0, 1719, 1722, 1, 0, 0, 0, 1720, 1718,
		1, 0, 0, 0, 1720, 1721, 1, 0, 0, 0, 1721, 1723, 1, 0, 0, 0, 1722, 1720,
		1, 0, 0, 0, 1723, 1725, 3, 294, 147, 0, 1724, 1726, 3, 128, 64, 0, 1725,
		1724, 1, 0, 0, 0, 1725, 1726, 1, 0, 0, 0, 1726, 293, 1, 0, 0, 0, 1727,
		1730, 3, 136, 68, 0, 1728, 1730, 5, 15, 0, 0, 1729, 1727, 1, 0, 0, 0, 1729,
		1728, 1, 0, 0, 0, 1730, 295, 1, 0, 0, 0, 1731, 1732, 3, 292, 146, 0, 1732,
		1733, 5, 82, 0, 0, 1733, 297, 1, 0, 0, 0, 1734, 1741, 3, 302, 151, 0, 1735,
		1741, 3, 306, 153, 0, 1736, 1741, 3, 314, 157, 0, 1737, 1741, 3, 316, 158,
		0, 1738, 1741, 3, 334, 167, 0, 1739, 1741, 3, 340, 170, 0, 1740, 1734,
		1, 0, 0, 0, 1740, 1735, 1, 0, 0, 0, 1740, 1736, 1, 0, 0, 0, 1740, 1737,
		1, 0, 0, 0, 1740, 1738, 1, 0, 0, 0, 1740, 1739, 1, 0, 0, 0, 1741, 299,
		1, 0, 0, 0, 1742, 1748, 3, 302, 151, 0, 1743, 1748, 3, 308, 154, 0, 1744,
		1748, 3, 318, 159, 0, 1745, 1748, 3, 336, 168, 0, 1746, 1748, 3, 342, 171,
		0, 1747, 1742, 1, 0, 0, 0, 1747, 1743, 1, 0, 0, 0, 1747, 1744, 1, 0, 0,
		0, 1747, 1745, 1, 0, 0, 0, 1747, 1746, 1, 0, 0, 0, 1748, 301, 1, 0, 0,
		0, 1749, 1763, 3, 284, 142, 0, 1750, 1763, 3, 304, 152, 0, 1751, 1763,
		3, 310, 155, 0, 1752, 1763, 3, 320, 160, 0, 1753, 1763, 3, 322, 161, 0,
		1754, 1763, 3, 338, 169, 0, 1755, 1763, 3, 358, 179, 0, 1756, 1763, 3,
		360, 180, 0, 1757, 1763, 3, 362, 181, 0, 1758, 1763, 3, 366, 183, 0, 1759,
		1763, 3, 364, 182, 0, 1760, 1763, 3, 368, 184, 0, 1761, 1763, 3, 390, 195,
		0, 1762, 1749, 1, 0, 0, 0, 1762, 1750, 1, 0, 0, 0, 1762, 1751, 1, 0, 0,
		0, 1762, 1752, 1, 0, 0, 0, 1762, 1753, 1, 0, 0, 0, 1762, 1754, 1, 0, 0,
		0, 1762, 1755, 1, 0, 0, 0, 1762, 1756, 1, 0, 0, 0, 1762, 1757, 1, 0, 0,
		0, 1762, 1758, 1, 0, 0, 0, 1762, 1759, 1, 0, 0, 0, 1762, 1760, 1, 0, 0,
		0, 1762, 1761, 1, 0, 0, 0, 1763, 303, 1, 0, 0, 0, 1764, 1765, 5, 82, 0,
		0, 1765, 305, 1, 0, 0, 0, 1766, 1767, 3, 2, 1, 0, 1767, 1768, 5, 94, 0,
		0, 1768, 1769, 3, 298, 149, 0, 1769, 307, 1, 0, 0, 0, 1770, 1771, 3, 2,
		1, 0, 1771, 1772, 5, 94, 0, 0, 1772, 1773, 3, 300, 150, 0, 1773, 309, 1,
		0, 0, 0, 1774, 1775, 3, 312, 156, 0, 1775, 1776, 5, 82, 0, 0, 1776, 311,
		1, 0, 0, 0, 1777, 1785, 3, 476, 238, 0, 1778, 1785, 3, 444, 222, 0, 1779,
		1785, 3, 446, 223, 0, 1780, 1785, 3, 438, 219, 0, 1781, 1785, 3, 440, 220,
		0, 1782, 1785, 3, 428, 214, 0, 1783, 1785, 3, 406, 203, 0, 1784, 1777,
		1, 0, 0, 0, 1784, 1778, 1, 0, 0, 0, 1784, 1779, 1, 0, 0, 0, 1784, 1780,
		1, 0, 0, 0, 1784, 1781, 1, 0, 0, 0, 1784, 1782, 1, 0, 0, 0, 1784, 1783,
		1, 0, 0, 0, 1785, 313, 1, 0, 0, 0, 1786, 1787, 5, 39, 0, 0, 1787, 1788,
		5, 76, 0, 0, 1788, 1789, 3, 396, 198, 0, 1789, 1790, 5, 77, 0, 0, 1790,
		1791, 3, 298, 149, 0, 1791, 315, 1, 0, 0, 0, 1792, 1793, 5, 39, 0, 0, 1793,
		1794, 5, 76, 0, 0, 1794, 1795, 3, 396, 198, 0, 1795, 1796, 5, 77, 0, 0,
		1796, 1797, 3, 300, 150, 0, 1797, 1798, 5, 32, 0, 0, 1798, 1799, 3, 298,
		149, 0, 1799, 317, 1, 0, 0, 0, 1800, 1801, 5, 39, 0, 0, 1801, 1802, 5,
		76, 0, 0, 1802, 1803, 3, 396, 198, 0, 1803, 1804, 5, 77, 0, 0, 1804, 1805,
		3, 300, 150, 0, 1805, 1806, 5, 32, 0, 0, 1806, 1807, 3, 300, 150, 0, 1807,
		319, 1, 0, 0, 0, 1808, 1809, 5, 19, 0, 0, 1809, 1812, 3, 396, 198, 0, 1810,
		1811, 5, 94, 0, 0, 1811, 1813, 3, 396, 198, 0, 1812, 1810, 1, 0, 0, 0,
		1812, 1813, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1815, 5, 82, 0, 0,
		1815, 321, 1, 0, 0, 0, 1816, 1817, 5, 58, 0, 0, 1817, 1818, 5, 76, 0, 0,
		1818, 1819, 3, 396, 198, 0, 1819, 1820, 5, 77, 0, 0, 1820, 1821, 3, 324,
		162, 0, 1821, 323, 1, 0, 0, 0, 1822, 1823, 5, 78, 0, 0, 1823, 1827, 3,
		326, 163, 0, 1824, 1826, 3, 326, 163, 0, 1825, 1824, 1, 0, 0, 0, 1826,
		1829, 1, 0, 0, 0, 1827, 1825, 1, 0, 0, 0, 1827, 1828, 1, 0, 0, 0, 1828,
		1830, 1, 0, 0, 0, 1829, 1827, 1, 0, 0, 0, 1830, 1831, 5, 79, 0, 0, 1831,
		1849, 1, 0, 0, 0, 1832, 1836, 5, 78, 0, 0, 1833, 1835, 3, 328, 164, 0,
		1834, 1833, 1, 0, 0, 0, 1835, 1838, 1, 0, 0, 0, 1836, 1834, 1, 0, 0, 0,
		1836, 1837, 1, 0, 0, 0, 1837, 1844, 1, 0, 0, 0, 1838, 1836, 1, 0, 0, 0,
		1839, 1840, 3, 330, 165, 0, 1840, 1841, 5, 94, 0, 0, 1841, 1843, 1, 0,
		0, 0, 1842, 1839, 1, 0, 0, 0, 1843, 1846, 1, 0, 0, 0, 1844, 1842, 1, 0,
		0, 0, 1844, 1845, 1, 0, 0, 0, 1845, 1847, 1, 0, 0, 0, 1846, 1844, 1, 0,
		0, 0, 1847, 1849, 5, 79, 0, 0, 1848, 1822, 1, 0, 0, 0, 1848, 1832, 1, 0,
		0, 0, 1849, 325, 1, 0, 0, 0, 1850, 1851, 3, 330, 165, 0, 1851, 1857, 5,
		95, 0, 0, 1852, 1853, 3, 396, 198, 0, 1853, 1854, 5, 82, 0, 0, 1854, 1858,
		1, 0, 0, 0, 1855, 1858, 3, 284, 142, 0, 1856, 1858, 3, 364, 182, 0, 1857,
		1852, 1, 0, 0, 0, 1857, 1855, 1, 0, 0, 0, 1857, 1856, 1, 0, 0, 0, 1858,
		327, 1, 0, 0, 0, 1859, 1860, 3, 330, 165, 0, 1860, 1866, 5, 94, 0, 0, 1861,
		1862, 3, 330, 165, 0, 1862, 1863, 5, 94, 0, 0, 1863, 1865, 1, 0, 0, 0,
		1864, 1861, 1, 0, 0, 0, 1865, 1868, 1, 0, 0, 0, 1866, 1864, 1, 0, 0, 0,
		1866, 1867, 1, 0, 0, 0, 1867, 1869, 1, 0, 0, 0, 1868, 1866, 1, 0, 0, 0,
		1869, 1870, 3, 286, 143, 0, 1870, 329, 1, 0, 0, 0, 1871, 1872, 5, 23, 0,
		0, 1872, 1877, 3, 332, 166, 0, 1873, 1874, 5, 83, 0, 0, 1874, 1876, 3,
		332, 166, 0, 1875, 1873, 1, 0, 0, 0, 1876, 1879, 1, 0, 0, 0, 1877, 1875,
		1, 0, 0, 0, 1877, 1878, 1, 0, 0, 0, 1878, 1882, 1, 0, 0, 0, 1879, 1877,
		1, 0, 0, 0, 1880, 1882, 5, 29, 0, 0, 1881, 1871, 1, 0, 0, 0, 1881, 1880,
		1, 0, 0, 0, 1882, 331, 1, 0, 0, 0, 1883, 1884, 3, 472, 236, 0, 1884, 333,
		1, 0, 0, 0, 1885, 1886, 5, 67, 0, 0, 1886, 1887, 5, 76, 0, 0, 1887, 1888,
		3, 396, 198, 0, 1888, 1889, 5, 77, 0, 0, 1889, 1890, 3, 298, 149, 0, 1890,
		335, 1, 0, 0, 0, 1891, 1892, 5, 67, 0, 0, 1892, 1893, 5, 76, 0, 0, 1893,
		1894, 3, 396, 198, 0, 1894, 1895, 5, 77, 0, 0, 1895, 1896, 3, 300, 150,
		0, 1896, 337, 1, 0, 0, 0, 1897, 1898, 5, 30, 0, 0, 1898, 1899, 3, 298,
		149, 0, 1899, 1900, 5, 67, 0, 0, 1900, 1901, 5, 76, 0, 0, 1901, 1902, 3,
		396, 198, 0, 1902, 1903, 5, 77, 0, 0, 1903, 1904, 5, 82, 0, 0, 1904, 339,
		1, 0, 0, 0, 1905, 1908, 3, 344, 172, 0, 1906, 1908, 3, 354, 177, 0, 1907,
		1905, 1, 0, 0, 0, 1907, 1906, 1, 0, 0, 0, 1908, 341, 1, 0, 0, 0, 1909,
		1912, 3, 346, 173, 0, 1910, 1912, 3, 356, 178, 0, 1911, 1909, 1, 0, 0,
		0, 1911, 1910, 1, 0, 0, 0, 1912, 343, 1, 0, 0, 0, 1913, 1914, 5, 38, 0,
		0, 1914, 1916, 5, 76, 0, 0, 1915, 1917, 3, 348, 174, 0, 1916, 1915, 1,
		0, 0, 0, 1916, 1917, 1, 0, 0, 0, 1917, 1918, 1, 0, 0, 0, 1918, 1920, 5,
		82, 0, 0, 1919, 1921, 3, 396, 198, 0, 1920, 1919, 1, 0, 0, 0, 1920, 1921,
		1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1924, 5, 82, 0, 0, 1923, 1925,
		3, 350, 175, 0, 1924, 1923, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 1926,
		1, 0, 0, 0, 1926, 1927, 5, 77, 0, 0, 1927, 1928, 3, 298, 149, 0, 1928,
		345, 1, 0, 0, 0, 1929, 1930, 5, 38, 0, 0, 1930, 1932, 5, 76, 0, 0, 1931,
		1933, 3, 348, 174, 0, 1932, 1931, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933,
		1934, 1, 0, 0, 0, 1934, 1936, 5, 82, 0, 0, 1935, 1937, 3, 396, 198, 0,
		1936, 1935, 1, 0, 0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1938, 1, 0, 0, 0,
		1938, 1940, 5, 82, 0, 0, 1939, 1941, 3, 350, 175, 0, 1940, 1939, 1, 0,
		0, 0, 1940, 1941, 1, 0, 0, 0, 1941, 1942, 1, 0, 0, 0, 1942, 1943, 5, 77,
		0, 0, 1943, 1944, 3, 300, 150, 0, 1944, 347, 1, 0, 0, 0, 1945, 1948, 3,
		352, 176, 0, 1946, 1948, 3, 292, 146, 0, 1947, 1945, 1, 0, 0, 0, 1947,
		1946, 1, 0, 0, 0, 1948, 349, 1, 0, 0, 0, 1949, 1950, 3, 352, 176, 0, 1950,
		351, 1, 0, 0, 0, 1951, 1956, 3, 312, 156, 0, 1952, 1953, 5, 83, 0, 0, 1953,
		1955, 3, 312, 156, 0, 1954, 1952, 1, 0, 0, 0, 1955, 1958, 1, 0, 0, 0, 1956,
		1954, 1, 0, 0, 0, 1956, 1957, 1, 0, 0, 0, 1957, 353, 1, 0, 0, 0, 1958,
		1956, 1, 0, 0, 0, 1959, 1960, 5, 38, 0, 0, 1960, 1961, 5, 76, 0, 0, 1961,
		1962, 3, 292, 146, 0, 1962, 1963, 5, 94, 0, 0, 1963, 1964, 3, 396, 198,
		0, 1964, 1965, 5, 77, 0, 0, 1965, 1966, 3, 298, 149, 0, 1966, 355, 1, 0,
		0, 0, 1967, 1968, 5, 38, 0, 0, 1968, 1969, 5, 76, 0, 0, 1969, 1970, 3,
		292, 146, 0, 1970, 1971, 5, 94, 0, 0, 1971, 1972, 3, 396, 198, 0, 1972,
		1973, 5, 77, 0, 0, 1973, 1974, 3, 300, 150, 0, 1974, 357, 1, 0, 0, 0, 1975,
		1977, 5, 21, 0, 0, 1976, 1978, 3, 2, 1, 0, 1977, 1976, 1, 0, 0, 0, 1977,
		1978, 1, 0, 0, 0, 1978, 1979, 1, 0, 0, 0, 1979, 1980, 5, 82, 0, 0, 1980,
		359, 1, 0, 0, 0, 1981, 1983, 5, 28, 0, 0, 1982, 1984, 3, 2, 1, 0, 1983,
		1982, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 1985, 1, 0, 0, 0, 1985,
		1986, 5, 82, 0, 0, 1986, 361, 1, 0, 0, 0, 1987, 1989, 5, 53, 0, 0, 1988,
		1990, 3, 396, 198, 0, 1989, 1988, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0, 1990,
		1991, 1, 0, 0, 0, 1991, 1992, 5, 82, 0, 0, 1992, 363, 1, 0, 0, 0, 1993,
		1994, 5, 61, 0, 0, 1994, 1995, 3, 396, 198, 0, 1995, 1996, 5, 82, 0, 0,
		1996, 365, 1, 0, 0, 0, 1997, 1998, 5, 59, 0, 0, 1998, 1999, 5, 76, 0, 0,
		1999, 2000, 3, 396, 198, 0, 2000, 2001, 5, 77, 0, 0, 2001, 2002, 3, 284,
		142, 0, 2002, 367, 1, 0, 0, 0, 2003, 2004, 5, 64, 0, 0, 2004, 2005, 3,
		284, 142, 0, 2005, 2006, 3, 370, 185, 0, 2006, 2020, 1, 0, 0, 0, 2007,
		2008, 5, 64, 0, 0, 2008, 2009, 3, 284, 142, 0, 2009, 2010, 3, 378, 189,
		0, 2010, 2020, 1, 0, 0, 0, 2011, 2012, 5, 64, 0, 0, 2012, 2014, 3, 284,
		142, 0, 2013, 2015, 3, 370, 185, 0, 2014, 2013, 1, 0, 0, 0, 2014, 2015,
		1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2017, 3, 378, 189, 0, 2017, 2020,
		1, 0, 0, 0, 2018, 2020, 3, 380, 190, 0, 2019, 2003, 1, 0, 0, 0, 2019, 2007,
		1, 0, 0, 0, 2019, 2011, 1, 0, 0, 0, 2019, 2018, 1, 0, 0, 0, 2020, 369,
		1, 0, 0, 0, 2021, 2025, 3, 372, 186, 0, 2022, 2024, 3, 372, 186, 0, 2023,
		2022, 1, 0, 0, 0, 2024, 2027, 1, 0, 0, 0, 2025, 2023, 1, 0, 0, 0, 2025,
		2026, 1, 0, 0, 0, 2026, 371, 1, 0, 0, 0, 2027, 2025, 1, 0, 0, 0, 2028,
		2029, 5, 24, 0, 0, 2029, 2030, 5, 76, 0, 0, 2030, 2031, 3, 374, 187, 0,
		2031, 2032, 5, 77, 0, 0, 2032, 2033, 3, 284, 142, 0, 2033, 373, 1, 0, 0,
		0, 2034, 2036, 3, 172, 86, 0, 2035, 2034, 1, 0, 0, 0, 2036, 2039, 1, 0,
		0, 0, 2037, 2035, 1, 0, 0, 0, 2037, 2038, 1, 0, 0, 0, 2038, 2040, 1, 0,
		0, 0, 2039, 2037, 1, 0, 0, 0, 2040, 2041, 3, 376, 188, 0, 2041, 2042, 3,
		132, 66, 0, 2042, 375, 1, 0, 0, 0, 2043, 2048, 3, 146, 73, 0, 2044, 2045,
		5, 109, 0, 0, 2045, 2047, 3, 30, 15, 0, 2046, 2044, 1, 0, 0, 0, 2047, 2050,
		1, 0, 0, 0, 2048, 2046, 1, 0, 0, 0, 2048, 2049, 1, 0, 0, 0, 2049, 377,
		1, 0, 0, 0, 2050, 2048, 1, 0, 0, 0, 2051, 2052, 5, 36, 0, 0, 2052, 2053,
		3, 284, 142, 0, 2053, 379, 1, 0, 0, 0, 2054, 2055, 5, 64, 0, 0, 2055, 2056,
		3, 382, 191, 0, 2056, 2058, 3, 284, 142, 0, 2057, 2059, 3, 370, 185, 0,
		2058, 2057, 1, 0, 0, 0, 2058, 2059, 1, 0, 0, 0, 2059, 2061, 1, 0, 0, 0,
		2060, 2062, 3, 378, 189, 0, 2061, 2060, 1, 0, 0, 0, 2061, 2062, 1, 0, 0,
		0, 2062, 381, 1, 0, 0, 0, 2063, 2064, 5, 76, 0, 0, 2064, 2066, 3, 384,
		192, 0, 2065, 2067, 5, 82, 0, 0, 2066, 2065, 1, 0, 0, 0, 2066, 2067, 1,
		0, 0, 0, 2067, 2068, 1, 0, 0, 0, 2068, 2069, 5, 77, 0, 0, 2069, 383, 1,
		0, 0, 0, 2070, 2075, 3, 386, 193, 0, 2071, 2072, 5, 82, 0, 0, 2072, 2074,
		3, 386, 193, 0, 2073, 2071, 1, 0, 0, 0, 2074, 2077, 1, 0, 0, 0, 2075, 2073,
		1, 0, 0, 0, 2075, 2076, 1, 0, 0, 0, 2076, 385, 1, 0, 0, 0, 2077, 2075,
		1, 0, 0, 0, 2078, 2081, 3, 292, 146, 0, 2079, 2081, 3, 388, 194, 0, 2080,
		2078, 1, 0, 0, 0, 2080, 2079, 1, 0, 0, 0, 2081, 387, 1, 0, 0, 0, 2082,
		2085, 3, 66, 33, 0, 2083, 2085, 3, 426, 213, 0, 2084, 2082, 1, 0, 0, 0,
		2084, 2083, 1, 0, 0, 0, 2085, 389, 1, 0, 0, 0, 2086, 2087, 5, 17, 0, 0,
		2087, 2088, 3, 396, 198, 0, 2088, 2089, 5, 82, 0, 0, 2089, 391, 1, 0, 0,
		0, 2090, 2091, 3, 394, 197, 0, 2091, 393, 1, 0, 0, 0, 2092, 2093, 3, 292,
		146, 0, 2093, 395, 1, 0, 0, 0, 2094, 2097, 3, 482, 241, 0, 2095, 2097,
		3, 474, 237, 0, 2096, 2094, 1, 0, 0, 0, 2096, 2095, 1, 0, 0, 0, 2097, 397,
		1, 0, 0, 0, 2098, 2101, 3, 400, 200, 0, 2099, 2101, 3, 414, 207, 0, 2100,
		2098, 1, 0, 0, 0, 2100, 2099, 1, 0, 0, 0, 2101, 399, 1, 0, 0, 0, 2102,
		2104, 3, 14, 7, 0, 2103, 2105, 3, 402, 201, 0, 2104, 2103, 1, 0, 0, 0,
		2104, 2105, 1, 0, 0, 0, 2105, 2320, 1, 0, 0, 0, 2106, 2108, 3, 404, 202,
		0, 2107, 2109, 3, 402, 201, 0, 2108, 2107, 1, 0, 0, 0, 2108, 2109, 1, 0,
		0, 0, 2109, 2320, 1, 0, 0, 0, 2110, 2112, 5, 60, 0, 0, 2111, 2113, 3, 402,
		201, 0, 2112, 2111, 1, 0, 0, 0, 2112, 2113, 1, 0, 0, 0, 2113, 2320, 1,
		0, 0, 0, 2114, 2115, 3, 62, 31, 0, 2115, 2116, 5, 84, 0, 0, 2116, 2118,
		5, 60, 0, 0, 2117, 2119, 3, 402, 201, 0, 2118, 2117, 1, 0, 0, 0, 2118,
		2119, 1, 0, 0, 0, 2119, 2320, 1, 0, 0, 0, 2120, 2121, 5, 76, 0, 0, 2121,
		2122, 3, 396, 198, 0, 2122, 2124, 5, 77, 0, 0, 2123, 2125, 3, 402, 201,
		0, 2124, 2123, 1, 0, 0, 0, 2124, 2125, 1, 0, 0, 0, 2125, 2320, 1, 0, 0,
		0, 2126, 2128, 3, 408, 204, 0, 2127, 2129, 3, 402, 201, 0, 2128, 2127,
		1, 0, 0, 0, 2128, 2129, 1, 0, 0, 0, 2129, 2320, 1, 0, 0, 0, 2130, 2131,
		3, 66, 33, 0, 2131, 2132, 5, 84, 0, 0, 2132, 2134, 3, 408, 204, 0, 2133,
		2135, 3, 402, 201, 0, 2134, 2133, 1, 0, 0, 0, 2134, 2135, 1, 0, 0, 0, 2135,
		2320, 1, 0, 0, 0, 2136, 2137, 3, 414, 207, 0, 2137, 2138, 5, 84, 0, 0,
		2138, 2140, 3, 408, 204, 0, 2139, 2141, 3, 402, 201, 0, 2140, 2139, 1,
		0, 0, 0, 2140, 2141, 1, 0, 0, 0, 2141, 2320, 1, 0, 0, 0, 2142, 2143, 3,
		414, 207, 0, 2143, 2144, 5, 84, 0, 0, 2144, 2146, 3, 2, 1, 0, 2145, 2147,
		3, 402, 201, 0, 2146, 2145, 1, 0, 0, 0, 2146, 2147, 1, 0, 0, 0, 2147, 2320,
		1, 0, 0, 0, 2148, 2149, 5, 57, 0, 0, 2149, 2150, 5, 84, 0, 0, 2150, 2152,
		3, 2, 1, 0, 2151, 2153, 3, 402, 201, 0, 2152, 2151, 1, 0, 0, 0, 2152, 2153,
		1, 0, 0, 0, 2153, 2320, 1, 0, 0, 0, 2154, 2155, 3, 62, 31, 0, 2155, 2156,
		5, 84, 0, 0, 2156, 2157, 5, 57, 0, 0, 2157, 2158, 5, 84, 0, 0, 2158, 2160,
		3, 2, 1, 0, 2159, 2161, 3, 402, 201, 0, 2160, 2159, 1, 0, 0, 0, 2160, 2161,
		1, 0, 0, 0, 2161, 2320, 1, 0, 0, 0, 2162, 2163, 3, 66, 33, 0, 2163, 2164,
		5, 80, 0, 0, 2164, 2165, 3, 396, 198, 0, 2165, 2167, 5, 81, 0, 0, 2166,
		2168, 3, 402, 201, 0, 2167, 2166, 1, 0, 0, 0, 2167, 2168, 1, 0, 0, 0, 2168,
		2320, 1, 0, 0, 0, 2169, 2170, 3, 418, 209, 0, 2170, 2171, 5, 80, 0, 0,
		2171, 2172, 3, 396, 198, 0, 2172, 2174, 5, 81, 0, 0, 2173, 2175, 3, 402,
		201, 0, 2174, 2173, 1, 0, 0, 0, 2174, 2175, 1, 0, 0, 0, 2175, 2320, 1,
		0, 0, 0, 2176, 2177, 3, 68, 34, 0, 2177, 2179, 5, 76, 0, 0, 2178, 2180,
		3, 430, 215, 0, 2179, 2178, 1, 0, 0, 0, 2179, 2180, 1, 0, 0, 0, 2180, 2181,
		1, 0, 0, 0, 2181, 2183, 5, 77, 0, 0, 2182, 2184, 3, 402, 201, 0, 2183,
		2182, 1, 0, 0, 0, 2183, 2184, 1, 0, 0, 0, 2184, 2320, 1, 0, 0, 0, 2185,
		2186, 3, 62, 31, 0, 2186, 2188, 5, 84, 0, 0, 2187, 2189, 3, 48, 24, 0,
		2188, 2187, 1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189, 2190, 1, 0, 0, 0,
		2190, 2191, 3, 2, 1, 0, 2191, 2193, 5, 76, 0, 0, 2192, 2194, 3, 430, 215,
		0, 2193, 2192, 1, 0, 0, 0, 2193, 2194, 1, 0, 0, 0, 2194, 2195, 1, 0, 0,
		0, 2195, 2197, 5, 77, 0, 0, 2196, 2198, 3, 402, 201, 0, 2197, 2196, 1,
		0, 0, 0, 2197, 2198, 1, 0, 0, 0, 2198, 2320, 1, 0, 0, 0, 2199, 2200, 3,
		66, 33, 0, 2200, 2202, 5, 84, 0, 0, 2201, 2203, 3, 48, 24, 0, 2202, 2201,
		1, 0, 0, 0, 2202, 2203, 1, 0, 0, 0, 2203, 2204, 1, 0, 0, 0, 2204, 2205,
		3, 2, 1, 0, 2205, 2207, 5, 76, 0, 0, 2206, 2208, 3, 430, 215, 0, 2207,
		2206, 1, 0, 0, 0, 2207, 2208, 1, 0, 0, 0, 2208, 2209, 1, 0, 0, 0, 2209,
		2211, 5, 77, 0, 0, 2210, 2212, 3, 402, 201, 0, 2211, 2210, 1, 0, 0, 0,
		2211, 2212, 1, 0, 0, 0, 2212, 2320, 1, 0, 0, 0, 2213, 2214, 3, 414, 207,
		0, 2214, 2216, 5, 84, 0, 0, 2215, 2217, 3, 48, 24, 0, 2216, 2215, 1, 0,
		0, 0, 2216, 2217, 1, 0, 0, 0, 2217, 2218, 1, 0, 0, 0, 2218, 2219, 3, 2,
		1, 0, 2219, 2221, 5, 76, 0, 0, 2220, 2222, 3, 430, 215, 0, 2221, 2220,
		1, 0, 0, 0, 2221, 2222, 1, 0, 0, 0, 2222, 2223, 1, 0, 0, 0, 2223, 2225,
		5, 77, 0, 0, 2224, 2226, 3, 402, 201, 0, 2225, 2224, 1, 0, 0, 0, 2225,
		2226, 1, 0, 0, 0, 2226, 2320, 1, 0, 0, 0, 2227, 2228, 5, 57, 0, 0, 2228,
		2230, 5, 84, 0, 0, 2229, 2231, 3, 48, 24, 0, 2230, 2229, 1, 0, 0, 0, 2230,
		2231, 1, 0, 0, 0, 2231, 2232, 1, 0, 0, 0, 2232, 2233, 3, 2, 1, 0, 2233,
		2235, 5, 76, 0, 0, 2234, 2236, 3, 430, 215, 0, 2235, 2234, 1, 0, 0, 0,
		2235, 2236, 1, 0, 0, 0, 2236, 2237, 1, 0, 0, 0, 2237, 2239, 5, 77, 0, 0,
		2238, 2240, 3, 402, 201, 0, 2239, 2238, 1, 0, 0, 0, 2239, 2240, 1, 0, 0,
		0, 2240, 2320, 1, 0, 0, 0, 2241, 2242, 3, 62, 31, 0, 2242, 2243, 5, 84,
		0, 0, 2243, 2244, 5, 57, 0, 0, 2244, 2246, 5, 84, 0, 0, 2245, 2247, 3,
		48, 24, 0, 2246, 2245, 1, 0, 0, 0, 2246, 2247, 1, 0, 0, 0, 2247, 2248,
		1, 0, 0, 0, 2248, 2249, 3, 2, 1, 0, 2249, 2251, 5, 76, 0, 0, 2250, 2252,
		3, 430, 215, 0, 2251, 2250, 1, 0, 0, 0, 2251, 2252, 1, 0, 0, 0, 2252, 2253,
		1, 0, 0, 0, 2253, 2255, 5, 77, 0, 0, 2254, 2256, 3, 402, 201, 0, 2255,
		2254, 1, 0, 0, 0, 2255, 2256, 1, 0, 0, 0, 2256, 2320, 1, 0, 0, 0, 2257,
		2258, 3, 66, 33, 0, 2258, 2260, 5, 87, 0, 0, 2259, 2261, 3, 48, 24, 0,
		2260, 2259, 1, 0, 0, 0, 2260, 2261, 1, 0, 0, 0, 2261, 2262, 1, 0, 0, 0,
		2262, 2264, 3, 2, 1, 0, 2263, 2265, 3, 402, 201, 0, 2264, 2263, 1, 0, 0,
		0, 2264, 2265, 1, 0, 0, 0, 2265, 2320, 1, 0, 0, 0, 2266, 2267, 3, 414,
		207, 0, 2267, 2269, 5, 87, 0, 0, 2268, 2270, 3, 48, 24, 0, 2269, 2268,
		1, 0, 0, 0, 2269, 2270, 1, 0, 0, 0, 2270, 2271, 1, 0, 0, 0, 2271, 2273,
		3, 2, 1, 0, 2272, 2274, 3, 402, 201, 0, 2273, 2272, 1, 0, 0, 0, 2273, 2274,
		1, 0, 0, 0, 2274, 2320, 1, 0, 0, 0, 2275, 2276, 3, 24, 12, 0, 2276, 2278,
		5, 87, 0, 0, 2277, 2279, 3, 48, 24, 0, 2278, 2277, 1, 0, 0, 0, 2278, 2279,
		1, 0, 0, 0, 2279, 2280, 1, 0, 0, 0, 2280, 2282, 3, 2, 1, 0, 2281, 2283,
		3, 402, 201, 0, 2282, 2281, 1, 0, 0, 0, 2282, 2283, 1, 0, 0, 0, 2283, 2320,
		1, 0, 0, 0, 2284, 2285, 5, 57, 0, 0, 2285, 2287, 5, 87, 0, 0, 2286, 2288,
		3, 48, 24, 0, 2287, 2286, 1, 0, 0, 0, 2287, 2288, 1, 0, 0, 0, 2288, 2289,
		1, 0, 0, 0, 2289, 2291, 3, 2, 1, 0, 2290, 2292, 3, 402, 201, 0, 2291, 2290,
		1, 0, 0, 0, 2291, 2292, 1, 0, 0, 0, 2292, 2320, 1, 0, 0, 0, 2293, 2294,
		3, 62, 31, 0, 2294, 2295, 5, 84, 0, 0, 2295, 2296, 5, 57, 0, 0, 2296, 2298,
		5, 87, 0, 0, 2297, 2299, 3, 48, 24, 0, 2298, 2297, 1, 0, 0, 0, 2298, 2299,
		1, 0, 0, 0, 2299, 2300, 1, 0, 0, 0, 2300, 2302, 3, 2, 1, 0, 2301, 2303,
		3, 402, 201, 0, 2302, 2301, 1, 0, 0, 0, 2302, 2303, 1, 0, 0, 0, 2303, 2320,
		1, 0, 0, 0, 2304, 2305, 3, 30, 15, 0, 2305, 2307, 5, 87, 0, 0, 2306, 2308,
		3, 48, 24, 0, 2307, 2306, 1, 0, 0, 0, 2307, 2308, 1, 0, 0, 0, 2308, 2309,
		1, 0, 0, 0, 2309, 2311, 5, 48, 0, 0, 2310, 2312, 3, 402, 201, 0, 2311,
		2310, 1, 0, 0, 0, 2311, 2312, 1, 0, 0, 0, 2312, 2320, 1, 0, 0, 0, 2313,
		2314, 3, 36, 18, 0, 2314, 2315, 5, 87, 0, 0, 2315, 2317, 5, 48, 0, 0, 2316,
		2318, 3, 402, 201, 0, 2317, 2316, 1, 0, 0, 0, 2317, 2318, 1, 0, 0, 0, 2318,
		2320, 1, 0, 0, 0, 2319, 2102, 1, 0, 0, 0, 2319, 2106, 1, 0, 0, 0, 2319,
		2110, 1, 0, 0, 0, 2319, 2114, 1, 0, 0, 0, 2319, 2120, 1, 0, 0, 0, 2319,
		2126, 1, 0, 0, 0, 2319, 2130, 1, 0, 0, 0, 2319, 2136, 1, 0, 0, 0, 2319,
		2142, 1, 0, 0, 0, 2319, 2148, 1, 0, 0, 0, 2319, 2154, 1, 0, 0, 0, 2319,
		2162, 1, 0, 0, 0, 2319, 2169, 1, 0, 0, 0, 2319, 2176, 1, 0, 0, 0, 2319,
		2185, 1, 0, 0, 0, 2319, 2199, 1, 0, 0, 0, 2319, 2213, 1, 0, 0, 0, 2319,
		2227, 1, 0, 0, 0, 2319, 2241, 1, 0, 0, 0, 2319, 2257, 1, 0, 0, 0, 2319,
		2266, 1, 0, 0, 0, 2319, 2275, 1, 0, 0, 0, 2319, 2284, 1, 0, 0, 0, 2319,
		2293, 1, 0, 0, 0, 2319, 2304, 1, 0, 0, 0, 2319, 2313, 1, 0, 0, 0, 2320,
		401, 1, 0, 0, 0, 2321, 2322, 5, 84, 0, 0, 2322, 2324, 3, 408, 204, 0, 2323,
		2325, 3, 402, 201, 0, 2324, 2323, 1, 0, 0, 0, 2324, 2325, 1, 0, 0, 0, 2325,
		2359, 1, 0, 0, 0, 2326, 2327, 5, 84, 0, 0, 2327, 2329, 3, 2, 1, 0, 2328,
		2330, 3, 402, 201, 0, 2329, 2328, 1, 0, 0, 0, 2329, 2330, 1, 0, 0, 0, 2330,
		2359, 1, 0, 0, 0, 2331, 2332, 5, 80, 0, 0, 2332, 2333, 3, 396, 198, 0,
		2333, 2335, 5, 81, 0, 0, 2334, 2336, 3, 402, 201, 0, 2335, 2334, 1, 0,
		0, 0, 2335, 2336, 1, 0, 0, 0, 2336, 2359, 1, 0, 0, 0, 2337, 2339, 5, 84,
		0, 0, 2338, 2340, 3, 48, 24, 0, 2339, 2338, 1, 0, 0, 0, 2339, 2340, 1,
		0, 0, 0, 2340, 2341, 1, 0, 0, 0, 2341, 2342, 3, 2, 1, 0, 2342, 2344, 5,
		76, 0, 0, 2343, 2345, 3, 430, 215, 0, 2344, 2343, 1, 0, 0, 0, 2344, 2345,
		1, 0, 0, 0, 2345, 2346, 1, 0, 0, 0, 2346, 2348, 5, 77, 0, 0, 2347, 2349,
		3, 402, 201, 0, 2348, 2347, 1, 0, 0, 0, 2348, 2349, 1, 0, 0, 0, 2349, 2359,
		1, 0, 0, 0, 2350, 2352, 5, 87, 0, 0, 2351, 2353, 3, 48, 24, 0, 2352, 2351,
		1, 0, 0, 0, 2352, 2353, 1, 0, 0, 0, 2353, 2354, 1, 0, 0, 0, 2354, 2356,
		3, 2, 1, 0, 2355, 2357, 3, 402, 201, 0, 2356, 2355, 1, 0, 0, 0, 2356, 2357,
		1, 0, 0, 0, 2357, 2359, 1, 0, 0, 0, 2358, 2321, 1, 0, 0, 0, 2358, 2326,
		1, 0, 0, 0, 2358, 2331, 1, 0, 0, 0, 2358, 2337, 1, 0, 0, 0, 2358, 2350,
		1, 0, 0, 0, 2359, 403, 1, 0, 0, 0, 2360, 2365, 3, 62, 31, 0, 2361, 2362,
		5, 80, 0, 0, 2362, 2364, 5, 81, 0, 0, 2363, 2361, 1, 0, 0, 0, 2364, 2367,
		1, 0, 0, 0, 2365, 2363, 1, 0, 0, 0, 2365, 2366, 1, 0, 0, 0, 2366, 2368,
		1, 0, 0, 0, 2367, 2365, 1, 0, 0, 0, 2368, 2369, 5, 84, 0, 0, 2369, 2370,
		5, 26, 0, 0, 2370, 2396, 1, 0, 0, 0, 2371, 2376, 3, 18, 9, 0, 2372, 2373,
		5, 80, 0, 0, 2373, 2375, 5, 81, 0, 0, 2374, 2372, 1, 0, 0, 0, 2375, 2378,
		1, 0, 0, 0, 2376, 2374, 1, 0, 0, 0, 2376, 2377, 1, 0, 0, 0, 2377, 2379,
		1, 0, 0, 0, 2378, 2376, 1, 0, 0, 0, 2379, 2380, 5, 84, 0, 0, 2380, 2381,
		5, 26, 0, 0, 2381, 2396, 1, 0, 0, 0, 2382, 2387, 5, 20, 0, 0, 2383, 2384,
		5, 80, 0, 0, 2384, 2386, 5, 81, 0, 0, 2385, 2383, 1, 0, 0, 0, 2386, 2389,
		1, 0, 0, 0, 2387, 2385, 1, 0, 0, 0, 2387, 2388, 1, 0, 0, 0, 2388, 2390,
		1, 0, 0, 0, 2389, 2387, 1, 0, 0, 0, 2390, 2391, 5, 84, 0, 0, 2391, 2396,
		5, 26, 0, 0, 2392, 2393, 5, 65, 0, 0, 2393, 2394, 5, 84, 0, 0, 2394, 2396,
		5, 26, 0, 0, 2395, 2360, 1, 0, 0, 0, 2395, 2371, 1, 0, 0, 0, 2395, 2382,
		1, 0, 0, 0, 2395, 2392, 1, 0, 0, 0, 2396, 405, 1, 0, 0, 0, 2397, 2407,
		3, 408, 204, 0, 2398, 2399, 3, 66, 33, 0, 2399, 2400, 5, 84, 0, 0, 2400,
		2401, 3, 408, 204, 0, 2401, 2407, 1, 0, 0, 0, 2402, 2403, 3, 398, 199,
		0, 2403, 2404, 5, 84, 0, 0, 2404, 2405, 3, 408, 204, 0, 2405, 2407, 1,
		0, 0, 0, 2406, 2397, 1, 0, 0, 0, 2406, 2398, 1, 0, 0, 0, 2406, 2402, 1,
		0, 0, 0, 2407, 407, 1, 0, 0, 0, 2408, 2410, 5, 48, 0, 0, 2409, 2411, 3,
		48, 24, 0, 2410, 2409, 1, 0, 0, 0, 2410, 2411, 1, 0, 0, 0, 2411, 2412,
		1, 0, 0, 0, 2412, 2413, 3, 410, 205, 0, 2413, 2415, 5, 76, 0, 0, 2414,
		2416, 3, 430, 215, 0, 2415, 2414, 1, 0, 0, 0, 2415, 2416, 1, 0, 0, 0, 2416,
		2417, 1, 0, 0, 0, 2417, 2419, 5, 77, 0, 0, 2418, 2420, 3, 118, 59, 0, 2419,
		2418, 1, 0, 0, 0, 2419, 2420, 1, 0, 0, 0, 2420, 409, 1, 0, 0, 0, 2421,
		2423, 3, 262, 131, 0, 2422, 2421, 1, 0, 0, 0, 2423, 2426, 1, 0, 0, 0, 2424,
		2422, 1, 0, 0, 0, 2424, 2425, 1, 0, 0, 0, 2425, 2427, 1, 0, 0, 0, 2426,
		2424, 1, 0, 0, 0, 2427, 2438, 3, 2, 1, 0, 2428, 2432, 5, 84, 0, 0, 2429,
		2431, 3, 262, 131, 0, 2430, 2429, 1, 0, 0, 0, 2431, 2434, 1, 0, 0, 0, 2432,
		2430, 1, 0, 0, 0, 2432, 2433, 1, 0, 0, 0, 2433, 2435, 1, 0, 0, 0, 2434,
		2432, 1, 0, 0, 0, 2435, 2437, 3, 2, 1, 0, 2436, 2428, 1, 0, 0, 0, 2437,
		2440, 1, 0, 0, 0, 2438, 2436, 1, 0, 0, 0, 2438, 2439, 1, 0, 0, 0, 2439,
		2442, 1, 0, 0, 0, 2440, 2438, 1, 0, 0, 0, 2441, 2443, 3, 412, 206, 0, 2442,
		2441, 1, 0, 0, 0, 2442, 2443, 1, 0, 0, 0, 2443, 411, 1, 0, 0, 0, 2444,
		2447, 3, 48, 24, 0, 2445, 2447, 5, 4, 0, 0, 2446, 2444, 1, 0, 0, 0, 2446,
		2445, 1, 0, 0, 0, 2447, 413, 1, 0, 0, 0, 2448, 2451, 3, 416, 208, 0, 2449,
		2451, 3, 418, 209, 0, 2450, 2448, 1, 0, 0, 0, 2450, 2449, 1, 0, 0, 0, 2451,
		415, 1, 0, 0, 0, 2452, 2453, 5, 48, 0, 0, 2453, 2454, 3, 16, 8, 0, 2454,
		2456, 3, 420, 210, 0, 2455, 2457, 3, 38, 19, 0, 2456, 2455, 1, 0, 0, 0,
		2456, 2457, 1, 0, 0, 0, 2457, 2465, 1, 0, 0, 0, 2458, 2459, 5, 48, 0, 0,
		2459, 2460, 3, 30, 15, 0, 2460, 2462, 3, 420, 210, 0, 2461, 2463, 3, 38,
		19, 0, 2462, 2461, 1, 0, 0, 0, 2462, 2463, 1, 0, 0, 0, 2463, 2465, 1, 0,
		0, 0, 2464, 2452, 1, 0, 0, 0, 2464, 2458, 1, 0, 0, 0, 2465, 417, 1, 0,
		0, 0, 2466, 2467, 5, 48, 0, 0, 2467, 2468, 3, 16, 8, 0, 2468, 2469, 3,
		38, 19, 0, 2469, 2470, 3, 280, 140, 0, 2470, 2477, 1, 0, 0, 0, 2471, 2472,
		5, 48, 0, 0, 2472, 2473, 3, 28, 14, 0, 2473, 2474, 3, 38, 19, 0, 2474,
		2475, 3, 280, 140, 0, 2475, 2477, 1, 0, 0, 0, 2476, 2466, 1, 0, 0, 0, 2476,
		2471, 1, 0, 0, 0, 2477, 419, 1, 0, 0, 0, 2478, 2482, 3, 422, 211, 0, 2479,
		2481, 3, 422, 211, 0, 2480, 2479, 1, 0, 0, 0, 2481, 2484, 1, 0, 0, 0, 2482,
		2480, 1, 0, 0, 0, 2482, 2483, 1, 0, 0, 0, 2483, 421, 1, 0, 0, 0, 2484,
		2482, 1, 0, 0, 0, 2485, 2487, 3, 262, 131, 0, 2486, 2485, 1, 0, 0, 0, 2487,
		2490, 1, 0, 0, 0, 2488, 2486, 1, 0, 0, 0, 2488, 2489, 1, 0, 0, 0, 2489,
		2491, 1, 0, 0, 0, 2490, 2488, 1, 0, 0, 0, 2491, 2492, 5, 80, 0, 0, 2492,
		2493, 3, 396, 198, 0, 2493, 2494, 5, 81, 0, 0, 2494, 423, 1, 0, 0, 0, 2495,
		2496, 3, 66, 33, 0, 2496, 2497, 5, 80, 0, 0, 2497, 2498, 3, 396, 198, 0,
		2498, 2499, 5, 81, 0, 0, 2499, 2511, 1, 0, 0, 0, 2500, 2501, 3, 400, 200,
		0, 2501, 2502, 5, 80, 0, 0, 2502, 2503, 3, 396, 198, 0, 2503, 2504, 5,
		81, 0, 0, 2504, 2511, 1, 0, 0, 0, 2505, 2506, 3, 418, 209, 0, 2506, 2507,
		5, 80, 0, 0, 2507, 2508, 3, 396, 198, 0, 2508, 2509, 5, 81, 0, 0, 2509,
		2511, 1, 0, 0, 0, 2510, 2495, 1, 0, 0, 0, 2510, 2500, 1, 0, 0, 0, 2510,
		2505, 1, 0, 0, 0, 2511, 425, 1, 0, 0, 0, 2512, 2513, 3, 398, 199, 0, 2513,
		2514, 5, 84, 0, 0, 2514, 2515, 3, 2, 1, 0, 2515, 2526, 1, 0, 0, 0, 2516,
		2517, 5, 57, 0, 0, 2517, 2518, 5, 84, 0, 0, 2518, 2526, 3, 2, 1, 0, 2519,
		2520, 3, 62, 31, 0, 2520, 2521, 5, 84, 0, 0, 2521, 2522, 5, 57, 0, 0, 2522,
		2523, 5, 84, 0, 0, 2523, 2524, 3, 2, 1, 0, 2524, 2526, 1, 0, 0, 0, 2525,
		2512, 1, 0, 0, 0, 2525, 2516, 1, 0, 0, 0, 2525, 2519, 1, 0, 0, 0, 2526,
		427, 1, 0, 0, 0, 2527, 2528, 3, 68, 34, 0, 2528, 2530, 5, 76, 0, 0, 2529,
		2531, 3, 430, 215, 0, 2530, 2529, 1, 0, 0, 0, 2530, 2531, 1, 0, 0, 0, 2531,
		2532, 1, 0, 0, 0, 2532, 2533, 5, 77, 0, 0, 2533, 2597, 1, 0, 0, 0, 2534,
		2535, 3, 62, 31, 0, 2535, 2537, 5, 84, 0, 0, 2536, 2538, 3, 48, 24, 0,
		2537, 2536, 1, 0, 0, 0, 2537, 2538, 1, 0, 0, 0, 2538, 2539, 1, 0, 0, 0,
		2539, 2540, 3, 2, 1, 0, 2540, 2542, 5, 76, 0, 0, 2541, 2543, 3, 430, 215,
		0, 2542, 2541, 1, 0, 0, 0, 2542, 2543, 1, 0, 0, 0, 2543, 2544, 1, 0, 0,
		0, 2544, 2545, 5, 77, 0, 0, 2545, 2597, 1, 0, 0, 0, 2546, 2547, 3, 66,
		33, 0, 2547, 2549, 5, 84, 0, 0, 2548, 2550, 3, 48, 24, 0, 2549, 2548, 1,
		0, 0, 0, 2549, 2550, 1, 0, 0, 0, 2550, 2551, 1, 0, 0, 0, 2551, 2552, 3,
		2, 1, 0, 2552, 2554, 5, 76, 0, 0, 2553, 2555, 3, 430, 215, 0, 2554, 2553,
		1, 0, 0, 0, 2554, 2555, 1, 0, 0, 0, 2555, 2556, 1, 0, 0, 0, 2556, 2557,
		5, 77, 0, 0, 2557, 2597, 1, 0, 0, 0, 2558, 2559, 3, 398, 199, 0, 2559,
		2561, 5, 84, 0, 0, 2560, 2562, 3, 48, 24, 0, 2561, 2560, 1, 0, 0, 0, 2561,
		2562, 1, 0, 0, 0, 2562, 2563, 1, 0, 0, 0, 2563, 2564, 3, 2, 1, 0, 2564,
		2566, 5, 76, 0, 0, 2565, 2567, 3, 430, 215, 0, 2566, 2565, 1, 0, 0, 0,
		2566, 2567, 1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2569, 5, 77, 0, 0,
		2569, 2597, 1, 0, 0, 0, 2570, 2571, 5, 57, 0, 0, 2571, 2573, 5, 84, 0,
		0, 2572, 2574, 3, 48, 24, 0, 2573, 2572, 1, 0, 0, 0, 2573, 2574, 1, 0,
		0, 0, 2574, 2575, 1, 0, 0, 0, 2575, 2576, 3, 2, 1, 0, 2576, 2578, 5, 76,
		0, 0, 2577, 2579, 3, 430, 215, 0, 2578, 2577, 1, 0, 0, 0, 2578, 2579, 1,
		0, 0, 0, 2579, 2580, 1, 0, 0, 0, 2580, 2581, 5, 77, 0, 0, 2581, 2597, 1,
		0, 0, 0, 2582, 2583, 3, 62, 31, 0, 2583, 2584, 5, 84, 0, 0, 2584, 2585,
		5, 57, 0, 0, 2585, 2587, 5, 84, 0, 0, 2586, 2588, 3, 48, 24, 0, 2587, 2586,
		1, 0, 0, 0, 2587, 2588, 1, 0, 0, 0, 2588, 2589, 1, 0, 0, 0, 2589, 2590,
		3, 2, 1, 0, 2590, 2592, 5, 76, 0, 0, 2591, 2593, 3, 430, 215, 0, 2592,
		2591, 1, 0, 0, 0, 2592, 2593, 1, 0, 0, 0, 2593, 2594, 1, 0, 0, 0, 2594,
		2595, 5, 77, 0, 0, 2595, 2597, 1, 0, 0, 0, 2596, 2527, 1, 0, 0, 0, 2596,
		2534, 1, 0, 0, 0, 2596, 2546, 1, 0, 0, 0, 2596, 2558, 1, 0, 0, 0, 2596,
		2570, 1, 0, 0, 0, 2596, 2582, 1, 0, 0, 0, 2597, 429, 1, 0, 0, 0, 2598,
		2603, 3, 396, 198, 0, 2599, 2600, 5, 83, 0, 0, 2600, 2602, 3, 396, 198,
		0, 2601, 2599, 1, 0, 0, 0, 2602, 2605, 1, 0, 0, 0, 2603, 2601, 1, 0, 0,
		0, 2603, 2604, 1, 0, 0, 0, 2604, 431, 1, 0, 0, 0, 2605, 2603, 1, 0, 0,
		0, 2606, 2607, 3, 66, 33, 0, 2607, 2609, 5, 87, 0, 0, 2608, 2610, 3, 48,
		24, 0, 2609, 2608, 1, 0, 0, 0, 2609, 2610, 1, 0, 0, 0, 2610, 2611, 1, 0,
		0, 0, 2611, 2612, 3, 2, 1, 0, 2612, 2654, 1, 0, 0, 0, 2613, 2614, 3, 398,
		199, 0, 2614, 2616, 5, 87, 0, 0, 2615, 2617, 3, 48, 24, 0, 2616, 2615,
		1, 0, 0, 0, 2616, 2617, 1, 0, 0, 0, 2617, 2618, 1, 0, 0, 0, 2618, 2619,
		3, 2, 1, 0, 2619, 2654, 1, 0, 0, 0, 2620, 2621, 3, 24, 12, 0, 2621, 2623,
		5, 87, 0, 0, 2622, 2624, 3, 48, 24, 0, 2623, 2622, 1, 0, 0, 0, 2623, 2624,
		1, 0, 0, 0, 2624, 2625, 1, 0, 0, 0, 2625, 2626, 3, 2, 1, 0, 2626, 2654,
		1, 0, 0, 0, 2627, 2628, 5, 57, 0, 0, 2628, 2630, 5, 87, 0, 0, 2629, 2631,
		3, 48, 24, 0, 2630, 2629, 1, 0, 0, 0, 2630, 2631, 1, 0, 0, 0, 2631, 2632,
		1, 0, 0, 0, 2632, 2654, 3, 2, 1, 0, 2633, 2634, 3, 62, 31, 0, 2634, 2635,
		5, 84, 0, 0, 2635, 2636, 5, 57, 0, 0, 2636, 2638, 5, 87, 0, 0, 2637, 2639,
		3, 48, 24, 0, 2638, 2637, 1, 0, 0, 0, 2638, 2639, 1, 0, 0, 0, 2639, 2640,
		1, 0, 0, 0, 2640, 2641, 3, 2, 1, 0, 2641, 2654, 1, 0, 0, 0, 2642, 2643,
		3, 30, 15, 0, 2643, 2645, 5, 87, 0, 0, 2644, 2646, 3, 48, 24, 0, 2645,
		2644, 1, 0, 0, 0, 2645, 2646, 1, 0, 0, 0, 2646, 2647, 1, 0, 0, 0, 2647,
		2648, 5, 48, 0, 0, 2648, 2654, 1, 0, 0, 0, 2649, 2650, 3, 36, 18, 0, 2650,
		2651, 5, 87, 0, 0, 2651, 2652, 5, 48, 0, 0, 2652, 2654, 1, 0, 0, 0, 2653,
		2606, 1, 0, 0, 0, 2653, 2613, 1, 0, 0, 0, 2653, 2620, 1, 0, 0, 0, 2653,
		2627, 1, 0, 0, 0, 2653, 2633, 1, 0, 0, 0, 2653, 2642, 1, 0, 0, 0, 2653,
		2649, 1, 0, 0, 0, 2654, 433, 1, 0, 0, 0, 2655, 2657, 3, 398, 199, 0, 2656,
		2658, 3, 436, 218, 0, 2657, 2656, 1, 0, 0, 0, 2657, 2658, 1, 0, 0, 0, 2658,
		2664, 1, 0, 0, 0, 2659, 2661, 3, 66, 33, 0, 2660, 2662, 3, 436, 218, 0,
		2661, 2660, 1, 0, 0, 0, 2661, 2662, 1, 0, 0, 0, 2662, 2664, 1, 0, 0, 0,
		2663, 2655, 1, 0, 0, 0, 2663, 2659, 1, 0, 0, 0, 2664, 435, 1, 0, 0, 0,
		2665, 2667, 5, 102, 0, 0, 2666, 2668, 3, 436, 218, 0, 2667, 2666, 1, 0,
		0, 0, 2667, 2668, 1, 0, 0, 0, 2668, 2674, 1, 0, 0, 0, 2669, 2671, 5, 103,
		0, 0, 2670, 2672, 3, 436, 218, 0, 2671, 2670, 1, 0, 0, 0, 2671, 2672, 1,
		0, 0, 0, 2672, 2674, 1, 0, 0, 0, 2673, 2665, 1, 0, 0, 0, 2673, 2669, 1,
		0, 0, 0, 2674, 437, 1, 0, 0, 0, 2675, 2676, 3, 434, 217, 0, 2676, 2677,
		5, 102, 0, 0, 2677, 439, 1, 0, 0, 0, 2678, 2679, 3, 434, 217, 0, 2679,
		2680, 5, 103, 0, 0, 2680, 441, 1, 0, 0, 0, 2681, 2689, 3, 444, 222, 0,
		2682, 2689, 3, 446, 223, 0, 2683, 2684, 5, 104, 0, 0, 2684, 2689, 3, 442,
		221, 0, 2685, 2686, 5, 105, 0, 0, 2686, 2689, 3, 442, 221, 0, 2687, 2689,
		3, 448, 224, 0, 2688, 2681, 1, 0, 0, 0, 2688, 2682, 1, 0, 0, 0, 2688, 2683,
		1, 0, 0, 0, 2688, 2685, 1, 0, 0, 0, 2688, 2687, 1, 0, 0, 0, 2689, 443,
		1, 0, 0, 0, 2690, 2691, 5, 102, 0, 0, 2691, 2692, 3, 442, 221, 0, 2692,
		445, 1, 0, 0, 0, 2693, 2694, 5, 103, 0, 0, 2694, 2695, 3, 442, 221, 0,
		2695, 447, 1, 0, 0, 0, 2696, 2704, 3, 434, 217, 0, 2697, 2698, 5, 92, 0,
		0, 2698, 2704, 3, 442, 221, 0, 2699, 2700, 5, 91, 0, 0, 2700, 2704, 3,
		442, 221, 0, 2701, 2704, 3, 450, 225, 0, 2702, 2704, 3, 494, 247, 0, 2703,
		2696, 1, 0, 0, 0, 2703, 2697, 1, 0, 0, 0, 2703, 2699, 1, 0, 0, 0, 2703,
		2701, 1, 0, 0, 0, 2703, 2702, 1, 0, 0, 0, 2704, 449, 1, 0, 0, 0, 2705,
		2706, 5, 76, 0, 0, 2706, 2707, 3, 16, 8, 0, 2707, 2708, 5, 77, 0, 0, 2708,
		2709, 3, 442, 221, 0, 2709, 2733, 1, 0, 0, 0, 2710, 2711, 5, 76, 0, 0,
		2711, 2715, 3, 24, 12, 0, 2712, 2714, 3, 46, 23, 0, 2713, 2712, 1, 0, 0,
		0, 2714, 2717, 1, 0, 0, 0, 2715, 2713, 1, 0, 0, 0, 2715, 2716, 1, 0, 0,
		0, 2716, 2718, 1, 0, 0, 0, 2717, 2715, 1, 0, 0, 0, 2718, 2719, 5, 77, 0,
		0, 2719, 2720, 3, 448, 224, 0, 2720, 2733, 1, 0, 0, 0, 2721, 2722, 5, 76,
		0, 0, 2722, 2726, 3, 24, 12, 0, 2723, 2725, 3, 46, 23, 0, 2724, 2723, 1,
		0, 0, 0, 2725, 2728, 1, 0, 0, 0, 2726, 2724, 1, 0, 0, 0, 2726, 2727, 1,
		0, 0, 0, 2727, 2729, 1, 0, 0, 0, 2728, 2726, 1, 0, 0, 0, 2729, 2730, 5,
		77, 0, 0, 2730, 2731, 3, 482, 241, 0, 2731, 2733, 1, 0, 0, 0, 2732, 2705,
		1, 0, 0, 0, 2732, 2710, 1, 0, 0, 0, 2732, 2721, 1, 0, 0, 0, 2733, 451,
		1, 0, 0, 0, 2734, 2735, 6, 226, -1, 0, 2735, 2736, 3, 442, 221, 0, 2736,
		2748, 1, 0, 0, 0, 2737, 2738, 10, 3, 0, 0, 2738, 2739, 5, 106, 0, 0, 2739,
		2747, 3, 442, 221, 0, 2740, 2741, 10, 2, 0, 0, 2741, 2742, 5, 107, 0, 0,
		2742, 2747, 3, 442, 221, 0, 2743, 2744, 10, 1, 0, 0, 2744, 2745, 5, 111,
		0, 0, 2745, 2747, 3, 442, 221, 0, 2746, 2737, 1, 0, 0, 0, 2746, 2740, 1,
		0, 0, 0, 2746, 2743, 1, 0, 0, 0, 2747, 2750, 1, 0, 0, 0, 2748, 2746, 1,
		0, 0, 0, 2748, 2749, 1, 0, 0, 0, 2749, 453, 1, 0, 0, 0, 2750, 2748, 1,
		0, 0, 0, 2751, 2752, 6, 227, -1, 0, 2752, 2753, 3, 452, 226, 0, 2753, 2762,
		1, 0, 0, 0, 2754, 2755, 10, 2, 0, 0, 2755, 2756, 5, 104, 0, 0, 2756, 2761,
		3, 452, 226, 0, 2757, 2758, 10, 1, 0, 0, 2758, 2759, 5, 105, 0, 0, 2759,
		2761, 3, 452, 226, 0, 2760, 2754, 1, 0, 0, 0, 2760, 2757, 1, 0, 0, 0, 2761,
		2764, 1, 0, 0, 0, 2762, 2760, 1, 0, 0, 0, 2762, 2763, 1, 0, 0, 0, 2763,
		455, 1, 0, 0, 0, 2764, 2762, 1, 0, 0, 0, 2765, 2766, 6, 228, -1, 0, 2766,
		2767, 3, 454, 227, 0, 2767, 2783, 1, 0, 0, 0, 2768, 2769, 10, 3, 0, 0,
		2769, 2770, 5, 90, 0, 0, 2770, 2771, 5, 90, 0, 0, 2771, 2782, 3, 454, 227,
		0, 2772, 2773, 10, 2, 0, 0, 2773, 2774, 5, 89, 0, 0, 2774, 2775, 5, 89,
		0, 0, 2775, 2782, 3, 454, 227, 0, 2776, 2777, 10, 1, 0, 0, 2777, 2778,
		5, 89, 0, 0, 2778, 2779, 5, 89, 0, 0, 2779, 2780, 5, 89, 0, 0, 2780, 2782,
		3, 454, 227, 0, 2781, 2768, 1, 0, 0, 0, 2781, 2772, 1, 0, 0, 0, 2781, 2776,
		1, 0, 0, 0, 2782, 2785, 1, 0, 0, 0, 2783, 2781, 1, 0, 0, 0, 2783, 2784,
		1, 0, 0, 0, 2784, 457, 1, 0, 0, 0, 2785, 2783, 1, 0, 0, 0, 2786, 2787,
		6, 229, -1, 0, 2787, 2788, 3, 456, 228, 0, 2788, 2809, 1, 0, 0, 0, 2789,
		2790, 10, 5, 0, 0, 2790, 2791, 5, 90, 0, 0, 2791, 2808, 3, 456, 228, 0,
		2792, 2793, 10, 4, 0, 0, 2793, 2794, 5, 89, 0, 0, 2794, 2808, 3, 456, 228,
		0, 2795, 2796, 10, 3, 0, 0, 2796, 2797, 5, 97, 0, 0, 2797, 2808, 3, 456,
		228, 0, 2798, 2799, 10, 2, 0, 0, 2799, 2800, 5, 98, 0, 0, 2800, 2808, 3,
		456, 228, 0, 2801, 2802, 10, 1, 0, 0, 2802, 2805, 5, 43, 0, 0, 2803, 2806,
		3, 24, 12, 0, 2804, 2806, 3, 392, 196, 0, 2805, 2803, 1, 0, 0, 0, 2805,
		2804, 1, 0, 0, 0, 2806, 2808, 1, 0, 0, 0, 2807, 2789, 1, 0, 0, 0, 2807,
		2792, 1, 0, 0, 0, 2807, 2795, 1, 0, 0, 0, 2807, 2798, 1, 0, 0, 0, 2807,
		2801, 1, 0, 0, 0, 2808, 2811, 1, 0, 0, 0, 2809, 2807, 1, 0, 0, 0, 2809,
		2810, 1, 0, 0, 0, 2810, 459, 1, 0, 0, 0, 2811, 2809, 1, 0, 0, 0, 2812,
		2813, 6, 230, -1, 0, 2813, 2814, 3, 458, 229, 0, 2814, 2823, 1, 0, 0, 0,
		2815, 2816, 10, 2, 0, 0, 2816, 2817, 5, 96, 0, 0, 2817, 2822, 3, 458, 229,
		0, 2818, 2819, 10, 1, 0, 0, 2819, 2820, 5, 99, 0, 0, 2820, 2822, 3, 458,
		229, 0, 2821, 2815, 1, 0, 0, 0, 2821, 2818, 1, 0, 0, 0, 2822, 2825, 1,
		0, 0, 0, 2823, 2821, 1, 0, 0, 0, 2823, 2824, 1, 0, 0, 0, 2824, 461, 1,
		0, 0, 0, 2825, 2823, 1, 0, 0, 0, 2826, 2827, 6, 231, -1, 0, 2827, 2828,
		3, 460, 230, 0, 2828, 2834, 1, 0, 0, 0, 2829, 2830, 10, 1, 0, 0, 2830,
		2831, 5, 108, 0, 0, 2831, 2833, 3, 460, 230, 0, 2832, 2829, 1, 0, 0, 0,
		2833, 2836, 1, 0, 0, 0, 2834, 2832, 1, 0, 0, 0, 2834, 2835, 1, 0, 0, 0,
		2835, 463, 1, 0, 0, 0, 2836, 2834, 1, 0, 0, 0, 2837, 2838, 6, 232, -1,
		0, 2838, 2839, 3, 462, 231, 0, 2839, 2845, 1, 0, 0, 0, 2840, 2841, 10,
		1, 0, 0, 2841, 2842, 5, 110, 0, 0, 2842, 2844, 3, 462, 231, 0, 2843, 2840,
		1, 0, 0, 0, 2844, 2847, 1, 0, 0, 0, 2845, 2843, 1, 0, 0, 0, 2845, 2846,
		1, 0, 0, 0, 2846, 465, 1, 0, 0, 0, 2847, 2845, 1, 0, 0, 0, 2848, 2849,
		6, 233, -1, 0, 2849, 2850, 3, 464, 232, 0, 2850, 2856, 1, 0, 0, 0, 2851,
		2852, 10, 1, 0, 0, 2852, 2853, 5, 109, 0, 0, 2853, 2855, 3, 464, 232, 0,
		2854, 2851, 1, 0, 0, 0, 2855, 2858, 1, 0, 0, 0, 2856, 2854, 1, 0, 0, 0,
		2856, 2857, 1, 0, 0, 0, 2857, 467, 1, 0, 0, 0, 2858, 2856, 1, 0, 0, 0,
		2859, 2860, 6, 234, -1, 0, 2860, 2861, 3, 466, 233, 0, 2861, 2867, 1, 0,
		0, 0, 2862, 2863, 10, 1, 0, 0, 2863, 2864, 5, 100, 0, 0, 2864, 2866, 3,
		466, 233, 0, 2865, 2862, 1, 0, 0, 0, 2866, 2869, 1, 0, 0, 0, 2867, 2865,
		1, 0, 0, 0, 2867, 2868, 1, 0, 0, 0, 2868, 469, 1, 0, 0, 0, 2869, 2867,
		1, 0, 0, 0, 2870, 2871, 6, 235, -1, 0, 2871, 2872, 3, 468, 234, 0, 2872,
		2878, 1, 0, 0, 0, 2873, 2874, 10, 1, 0, 0, 2874, 2875, 5, 101, 0, 0, 2875,
		2877, 3, 468, 234, 0, 2876, 2873, 1, 0, 0, 0, 2877, 2880, 1, 0, 0, 0, 2878,
		2876, 1, 0, 0, 0, 2878, 2879, 1, 0, 0, 0, 2879, 471, 1, 0, 0, 0, 2880,
		2878, 1, 0, 0, 0, 2881, 2895, 3, 470, 235, 0, 2882, 2883, 3, 470, 235,
		0, 2883, 2884, 5, 93, 0, 0, 2884, 2885, 3, 396, 198, 0, 2885, 2886, 5,
		94, 0, 0, 2886, 2887, 3, 472, 236, 0, 2887, 2895, 1, 0, 0, 0, 2888, 2889,
		3, 470, 235, 0, 2889, 2890, 5, 93, 0, 0, 2890, 2891, 3, 396, 198, 0, 2891,
		2892, 5, 94, 0, 0, 2892, 2893, 3, 482, 241, 0, 2893, 2895, 1, 0, 0, 0,
		2894, 2881, 1, 0, 0, 0, 2894, 2882, 1, 0, 0, 0, 2894, 2888, 1, 0, 0, 0,
		2895, 473, 1, 0, 0, 0, 2896, 2899, 3, 472, 236, 0, 2897, 2899, 3, 476,
		238, 0, 2898, 2896, 1, 0, 0, 0, 2898, 2897, 1, 0, 0, 0, 2899, 475, 1, 0,
		0, 0, 2900, 2901, 3, 478, 239, 0, 2901, 2902, 3, 480, 240, 0, 2902, 2903,
		3, 396, 198, 0, 2903, 477, 1, 0, 0, 0, 2904, 2908, 3, 66, 33, 0, 2905,
		2908, 3, 426, 213, 0, 2906, 2908, 3, 424, 212, 0, 2907, 2904, 1, 0, 0,
		0, 2907, 2905, 1, 0, 0, 0, 2907, 2906, 1, 0, 0, 0, 2908, 479, 1, 0, 0,
		0, 2909, 2910, 7, 8, 0, 0, 2910, 481, 1, 0, 0, 0, 2911, 2912, 3, 484, 242,
		0, 2912, 2913, 5, 95, 0, 0, 2913, 2914, 3, 492, 246, 0, 2914, 483, 1, 0,
		0, 0, 2915, 2917, 5, 76, 0, 0, 2916, 2918, 3, 486, 243, 0, 2917, 2916,
		1, 0, 0, 0, 2917, 2918, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919, 2922,
		5, 77, 0, 0, 2920, 2922, 3, 2, 1, 0, 2921, 2915, 1, 0, 0, 0, 2921, 2920,
		1, 0, 0, 0, 2922, 485, 1, 0, 0, 0, 2923, 2928, 3, 488, 244, 0, 2924, 2925,
		5, 83, 0, 0, 2925, 2927, 3, 488, 244, 0, 2926, 2924, 1, 0, 0, 0, 2927,
		2930, 1, 0, 0, 0, 2928, 2926, 1, 0, 0, 0, 2928, 2929, 1, 0, 0, 0, 2929,
		2940, 1, 0, 0, 0, 2930, 2928, 1, 0, 0, 0, 2931, 2936, 3, 2, 1, 0, 2932,
		2933, 5, 83, 0, 0, 2933, 2935, 3, 2, 1, 0, 2934, 2932, 1, 0, 0, 0, 2935,
		2938, 1, 0, 0, 0, 2936, 2934, 1, 0, 0, 0, 2936, 2937, 1, 0, 0, 0, 2937,
		2940, 1, 0, 0, 0, 2938, 2936, 1, 0, 0, 0, 2939, 2923, 1, 0, 0, 0, 2939,
		2931, 1, 0, 0, 0, 2940, 487, 1, 0, 0, 0, 2941, 2943, 3, 172, 86, 0, 2942,
		2941, 1, 0, 0, 0, 2943, 2946, 1, 0, 0, 0, 2944, 2942, 1, 0, 0, 0, 2944,
		2945, 1, 0, 0, 0, 2945, 2947, 1, 0, 0, 0, 2946, 2944, 1, 0, 0, 0, 2947,
		2948, 3, 490, 245, 0, 2948, 2949, 3, 132, 66, 0, 2949, 2952, 1, 0, 0, 0,
		2950, 2952, 3, 170, 85, 0, 2951, 2944, 1, 0, 0, 0, 2951, 2950, 1, 0, 0,
		0, 2952, 489, 1, 0, 0, 0, 2953, 2956, 3, 136, 68, 0, 2954, 2956, 5, 15,
		0, 0, 2955, 2953, 1, 0, 0, 0, 2955, 2954, 1, 0, 0, 0, 2956, 491, 1, 0,
		0, 0, 2957, 2960, 3, 396, 198, 0, 2958, 2960, 3, 284, 142, 0, 2959, 2957,
		1, 0, 0, 0, 2959, 2958, 1, 0, 0, 0, 2960, 493, 1, 0, 0, 0, 2961, 2962,
		5, 58, 0, 0, 2962, 2963, 5, 76, 0, 0, 2963, 2964, 3, 396, 198, 0, 2964,
		2965, 5, 77, 0, 0, 2965, 2966, 3, 324, 162, 0, 2966, 495, 1, 0, 0, 0, 2967,
		2968, 3, 396, 198, 0, 2968, 497, 1, 0, 0, 0, 363, 503, 507, 511, 524, 529,
		533, 542, 548, 553, 556, 561, 566, 571, 574, 579, 584, 591, 596, 603, 608,
		610, 617, 631, 636, 644, 651, 657, 662, 672, 675, 689, 694, 699, 704, 710,
		715, 720, 725, 730, 735, 744, 748, 751, 756, 762, 768, 776, 785, 796, 825,
		830, 834, 842, 849, 858, 872, 875, 887, 890, 906, 911, 918, 923, 929, 932,
		935, 938, 952, 963, 977, 986, 993, 1002, 1009, 1014, 1029, 1036, 1042,
		1046, 1050, 1054, 1058, 1063, 1070, 1073, 1077, 1080, 1086, 1091, 1094,
		1098, 1102, 1108, 1113, 1115, 1124, 1131, 1147, 1153, 1156, 1161, 1165,
		1172, 1175, 1179, 1184, 1191, 1200, 1206, 1213, 1218, 1225, 1233, 1243,
		1248, 1252, 1262, 1267, 1275, 1278, 1285, 1288, 1296, 1299, 1304, 1309,
		1315, 1319, 1324, 1329, 1334, 1340, 1346, 1349, 1352, 1361, 1367, 1373,
		1376, 1379, 1387, 1393, 1399, 1403, 1409, 1418, 1424, 1431, 1436, 1443,
		1455, 1462, 1467, 1475, 1480, 1486, 1489, 1492, 1505, 1516, 1523, 1533,
		1538, 1549, 1554, 1567, 1572, 1584, 1594, 1599, 1607, 1610, 1617, 1625,
		1631, 1640, 1650, 1654, 1657, 1666, 1680, 1683, 1692, 1697, 1705, 1711,
		1715, 1720, 1725, 1729, 1740, 1747, 1762, 1784, 1812, 1827, 1836, 1844,
		1848, 1857, 1866, 1877, 1881, 1907, 1911, 1916, 1920, 1924, 1932, 1936,
		1940, 1947, 1956, 1977, 1983, 1989, 2014, 2019, 2025, 2037, 2048, 2058,
		2061, 2066, 2075, 2080, 2084, 2096, 2100, 2104, 2108, 2112, 2118, 2124,
		2128, 2134, 2140, 2146, 2152, 2160, 2167, 2174, 2179, 2183, 2188, 2193,
		2197, 2202, 2207, 2211, 2216, 2221, 2225, 2230, 2235, 2239, 2246, 2251,
		2255, 2260, 2264, 2269, 2273, 2278, 2282, 2287, 2291, 2298, 2302, 2307,
		2311, 2317, 2319, 2324, 2329, 2335, 2339, 2344, 2348, 2352, 2356, 2358,
		2365, 2376, 2387, 2395, 2406, 2410, 2415, 2419, 2424, 2432, 2438, 2442,
		2446, 2450, 2456, 2462, 2464, 2476, 2482, 2488, 2510, 2525, 2530, 2537,
		2542, 2549, 2554, 2561, 2566, 2573, 2578, 2587, 2592, 2596, 2603, 2609,
		2616, 2623, 2630, 2638, 2645, 2653, 2657, 2661, 2663, 2667, 2671, 2673,
		2688, 2703, 2715, 2726, 2732, 2746, 2748, 2760, 2762, 2781, 2783, 2805,
		2807, 2809, 2821, 2823, 2834, 2845, 2856, 2867, 2878, 2894, 2898, 2907,
		2917, 2921, 2928, 2936, 2939, 2944, 2951, 2955, 2959,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// Java20ParserInit initializes any static state used to implement Java20Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewJava20Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Java20ParserInit() {
	staticData := &Java20ParserParserStaticData
	staticData.once.Do(java20parserParserInit)
}

// NewJava20Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewJava20Parser(input antlr.TokenStream) *Java20Parser {
	Java20ParserInit()
	this := new(Java20Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &Java20ParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Java20Parser.g4"

	return this
}

// Java20Parser tokens.
const (
	Java20ParserEOF                  = antlr.TokenEOF
	Java20ParserEXPORTS              = 1
	Java20ParserMODULE               = 2
	Java20ParserNONSEALED            = 3
	Java20ParserOACA                 = 4
	Java20ParserOPEN                 = 5
	Java20ParserOPENS                = 6
	Java20ParserPERMITS              = 7
	Java20ParserPROVIDES             = 8
	Java20ParserRECORD               = 9
	Java20ParserREQUIRES             = 10
	Java20ParserSEALED               = 11
	Java20ParserTO                   = 12
	Java20ParserTRANSITIVE           = 13
	Java20ParserUSES                 = 14
	Java20ParserVAR                  = 15
	Java20ParserWITH                 = 16
	Java20ParserYIELD                = 17
	Java20ParserABSTRACT             = 18
	Java20ParserASSERT               = 19
	Java20ParserBOOLEAN              = 20
	Java20ParserBREAK                = 21
	Java20ParserBYTE                 = 22
	Java20ParserCASE                 = 23
	Java20ParserCATCH                = 24
	Java20ParserCHAR                 = 25
	Java20ParserCLASS                = 26
	Java20ParserCONST                = 27
	Java20ParserCONTINUE             = 28
	Java20ParserDEFAULT              = 29
	Java20ParserDO                   = 30
	Java20ParserDOUBLE               = 31
	Java20ParserELSE                 = 32
	Java20ParserENUM                 = 33
	Java20ParserEXTENDS              = 34
	Java20ParserFINAL                = 35
	Java20ParserFINALLY              = 36
	Java20ParserFLOAT                = 37
	Java20ParserFOR                  = 38
	Java20ParserIF                   = 39
	Java20ParserGOTO                 = 40
	Java20ParserIMPLEMENTS           = 41
	Java20ParserIMPORT               = 42
	Java20ParserINSTANCEOF           = 43
	Java20ParserINT                  = 44
	Java20ParserINTERFACE            = 45
	Java20ParserLONG                 = 46
	Java20ParserNATIVE               = 47
	Java20ParserNEW                  = 48
	Java20ParserPACKAGE              = 49
	Java20ParserPRIVATE              = 50
	Java20ParserPROTECTED            = 51
	Java20ParserPUBLIC               = 52
	Java20ParserRETURN               = 53
	Java20ParserSHORT                = 54
	Java20ParserSTATIC               = 55
	Java20ParserSTRICTFP             = 56
	Java20ParserSUPER                = 57
	Java20ParserSWITCH               = 58
	Java20ParserSYNCHRONIZED         = 59
	Java20ParserTHIS                 = 60
	Java20ParserTHROW                = 61
	Java20ParserTHROWS               = 62
	Java20ParserTRANSIENT            = 63
	Java20ParserTRY                  = 64
	Java20ParserVOID                 = 65
	Java20ParserVOLATILE             = 66
	Java20ParserWHILE                = 67
	Java20ParserUNDER_SCORE          = 68
	Java20ParserIntegerLiteral       = 69
	Java20ParserFloatingPointLiteral = 70
	Java20ParserBooleanLiteral       = 71
	Java20ParserCharacterLiteral     = 72
	Java20ParserStringLiteral        = 73
	Java20ParserTextBlock            = 74
	Java20ParserNullLiteral          = 75
	Java20ParserLPAREN               = 76
	Java20ParserRPAREN               = 77
	Java20ParserLBRACE               = 78
	Java20ParserRBRACE               = 79
	Java20ParserLBRACK               = 80
	Java20ParserRBRACK               = 81
	Java20ParserSEMI                 = 82
	Java20ParserCOMMA                = 83
	Java20ParserDOT                  = 84
	Java20ParserELLIPSIS             = 85
	Java20ParserAT                   = 86
	Java20ParserCOLONCOLON           = 87
	Java20ParserASSIGN               = 88
	Java20ParserGT                   = 89
	Java20ParserLT                   = 90
	Java20ParserBANG                 = 91
	Java20ParserTILDE                = 92
	Java20ParserQUESTION             = 93
	Java20ParserCOLON                = 94
	Java20ParserARROW                = 95
	Java20ParserEQUAL                = 96
	Java20ParserLE                   = 97
	Java20ParserGE                   = 98
	Java20ParserNOTEQUAL             = 99
	Java20ParserAND                  = 100
	Java20ParserOR                   = 101
	Java20ParserINC                  = 102
	Java20ParserDEC                  = 103
	Java20ParserADD                  = 104
	Java20ParserSUB                  = 105
	Java20ParserMUL                  = 106
	Java20ParserDIV                  = 107
	Java20ParserBITAND               = 108
	Java20ParserBITOR                = 109
	Java20ParserCARET                = 110
	Java20ParserMOD                  = 111
	Java20ParserADD_ASSIGN           = 112
	Java20ParserSUB_ASSIGN           = 113
	Java20ParserMUL_ASSIGN           = 114
	Java20ParserDIV_ASSIGN           = 115
	Java20ParserAND_ASSIGN           = 116
	Java20ParserOR_ASSIGN            = 117
	Java20ParserXOR_ASSIGN           = 118
	Java20ParserMOD_ASSIGN           = 119
	Java20ParserLSHIFT_ASSIGN        = 120
	Java20ParserRSHIFT_ASSIGN        = 121
	Java20ParserURSHIFT_ASSIGN       = 122
	Java20ParserIdentifier           = 123
	Java20ParserWS                   = 124
	Java20ParserCOMMENT              = 125
	Java20ParserLINE_COMMENT         = 126
)

// Java20Parser rules.
const (
	Java20ParserRULE_start_                                               = 0
	Java20ParserRULE_identifier                                           = 1
	Java20ParserRULE_typeIdentifier                                       = 2
	Java20ParserRULE_unqualifiedMethodIdentifier                          = 3
	Java20ParserRULE_contextualKeyword                                    = 4
	Java20ParserRULE_contextualKeywordMinusForTypeIdentifier              = 5
	Java20ParserRULE_contextualKeywordMinusForUnqualifiedMethodIdentifier = 6
	Java20ParserRULE_literal                                              = 7
	Java20ParserRULE_primitiveType                                        = 8
	Java20ParserRULE_numericType                                          = 9
	Java20ParserRULE_integralType                                         = 10
	Java20ParserRULE_floatingPointType                                    = 11
	Java20ParserRULE_referenceType                                        = 12
	Java20ParserRULE_coit                                                 = 13
	Java20ParserRULE_classOrInterfaceType                                 = 14
	Java20ParserRULE_classType                                            = 15
	Java20ParserRULE_interfaceType                                        = 16
	Java20ParserRULE_typeVariable                                         = 17
	Java20ParserRULE_arrayType                                            = 18
	Java20ParserRULE_dims                                                 = 19
	Java20ParserRULE_typeParameter                                        = 20
	Java20ParserRULE_typeParameterModifier                                = 21
	Java20ParserRULE_typeBound                                            = 22
	Java20ParserRULE_additionalBound                                      = 23
	Java20ParserRULE_typeArguments                                        = 24
	Java20ParserRULE_typeArgumentList                                     = 25
	Java20ParserRULE_typeArgument                                         = 26
	Java20ParserRULE_wildcard                                             = 27
	Java20ParserRULE_wildcardBounds                                       = 28
	Java20ParserRULE_moduleName                                           = 29
	Java20ParserRULE_packageName                                          = 30
	Java20ParserRULE_typeName                                             = 31
	Java20ParserRULE_packageOrTypeName                                    = 32
	Java20ParserRULE_expressionName                                       = 33
	Java20ParserRULE_methodName                                           = 34
	Java20ParserRULE_ambiguousName                                        = 35
	Java20ParserRULE_compilationUnit                                      = 36
	Java20ParserRULE_ordinaryCompilationUnit                              = 37
	Java20ParserRULE_modularCompilationUnit                               = 38
	Java20ParserRULE_packageDeclaration                                   = 39
	Java20ParserRULE_packageModifier                                      = 40
	Java20ParserRULE_importDeclaration                                    = 41
	Java20ParserRULE_singleTypeImportDeclaration                          = 42
	Java20ParserRULE_typeImportOnDemandDeclaration                        = 43
	Java20ParserRULE_singleStaticImportDeclaration                        = 44
	Java20ParserRULE_staticImportOnDemandDeclaration                      = 45
	Java20ParserRULE_topLevelClassOrInterfaceDeclaration                  = 46
	Java20ParserRULE_moduleDeclaration                                    = 47
	Java20ParserRULE_moduleDirective                                      = 48
	Java20ParserRULE_requiresModifier                                     = 49
	Java20ParserRULE_classDeclaration                                     = 50
	Java20ParserRULE_normalClassDeclaration                               = 51
	Java20ParserRULE_classModifier                                        = 52
	Java20ParserRULE_typeParameters                                       = 53
	Java20ParserRULE_typeParameterList                                    = 54
	Java20ParserRULE_classExtends                                         = 55
	Java20ParserRULE_classImplements                                      = 56
	Java20ParserRULE_interfaceTypeList                                    = 57
	Java20ParserRULE_classPermits                                         = 58
	Java20ParserRULE_classBody                                            = 59
	Java20ParserRULE_classBodyDeclaration                                 = 60
	Java20ParserRULE_classMemberDeclaration                               = 61
	Java20ParserRULE_fieldDeclaration                                     = 62
	Java20ParserRULE_fieldModifier                                        = 63
	Java20ParserRULE_variableDeclaratorList                               = 64
	Java20ParserRULE_variableDeclarator                                   = 65
	Java20ParserRULE_variableDeclaratorId                                 = 66
	Java20ParserRULE_variableInitializer                                  = 67
	Java20ParserRULE_unannType                                            = 68
	Java20ParserRULE_unannPrimitiveType                                   = 69
	Java20ParserRULE_unannReferenceType                                   = 70
	Java20ParserRULE_unannClassOrInterfaceType                            = 71
	Java20ParserRULE_uCOIT                                                = 72
	Java20ParserRULE_unannClassType                                       = 73
	Java20ParserRULE_unannInterfaceType                                   = 74
	Java20ParserRULE_unannTypeVariable                                    = 75
	Java20ParserRULE_unannArrayType                                       = 76
	Java20ParserRULE_methodDeclaration                                    = 77
	Java20ParserRULE_methodModifier                                       = 78
	Java20ParserRULE_methodHeader                                         = 79
	Java20ParserRULE_result                                               = 80
	Java20ParserRULE_methodDeclarator                                     = 81
	Java20ParserRULE_receiverParameter                                    = 82
	Java20ParserRULE_formalParameterList                                  = 83
	Java20ParserRULE_formalParameter                                      = 84
	Java20ParserRULE_variableArityParameter                               = 85
	Java20ParserRULE_variableModifier                                     = 86
	Java20ParserRULE_throwsT                                              = 87
	Java20ParserRULE_exceptionTypeList                                    = 88
	Java20ParserRULE_exceptionType                                        = 89
	Java20ParserRULE_methodBody                                           = 90
	Java20ParserRULE_instanceInitializer                                  = 91
	Java20ParserRULE_staticInitializer                                    = 92
	Java20ParserRULE_constructorDeclaration                               = 93
	Java20ParserRULE_constructorModifier                                  = 94
	Java20ParserRULE_constructorDeclarator                                = 95
	Java20ParserRULE_simpleTypeName                                       = 96
	Java20ParserRULE_constructorBody                                      = 97
	Java20ParserRULE_explicitConstructorInvocation                        = 98
	Java20ParserRULE_enumDeclaration                                      = 99
	Java20ParserRULE_enumBody                                             = 100
	Java20ParserRULE_enumConstantList                                     = 101
	Java20ParserRULE_enumConstant                                         = 102
	Java20ParserRULE_enumConstantModifier                                 = 103
	Java20ParserRULE_enumBodyDeclarations                                 = 104
	Java20ParserRULE_recordDeclaration                                    = 105
	Java20ParserRULE_recordHeader                                         = 106
	Java20ParserRULE_recordComponentList                                  = 107
	Java20ParserRULE_recordComponent                                      = 108
	Java20ParserRULE_variableArityRecordComponent                         = 109
	Java20ParserRULE_recordComponentModifier                              = 110
	Java20ParserRULE_recordBody                                           = 111
	Java20ParserRULE_recordBodyDeclaration                                = 112
	Java20ParserRULE_compactConstructorDeclaration                        = 113
	Java20ParserRULE_interfaceDeclaration                                 = 114
	Java20ParserRULE_normalInterfaceDeclaration                           = 115
	Java20ParserRULE_interfaceModifier                                    = 116
	Java20ParserRULE_interfaceExtends                                     = 117
	Java20ParserRULE_interfacePermits                                     = 118
	Java20ParserRULE_interfaceBody                                        = 119
	Java20ParserRULE_interfaceMemberDeclaration                           = 120
	Java20ParserRULE_constantDeclaration                                  = 121
	Java20ParserRULE_constantModifier                                     = 122
	Java20ParserRULE_interfaceMethodDeclaration                           = 123
	Java20ParserRULE_interfaceMethodModifier                              = 124
	Java20ParserRULE_annotationInterfaceDeclaration                       = 125
	Java20ParserRULE_annotationInterfaceBody                              = 126
	Java20ParserRULE_annotationInterfaceMemberDeclaration                 = 127
	Java20ParserRULE_annotationInterfaceElementDeclaration                = 128
	Java20ParserRULE_annotationInterfaceElementModifier                   = 129
	Java20ParserRULE_defaultValue                                         = 130
	Java20ParserRULE_annotation                                           = 131
	Java20ParserRULE_normalAnnotation                                     = 132
	Java20ParserRULE_elementValuePairList                                 = 133
	Java20ParserRULE_elementValuePair                                     = 134
	Java20ParserRULE_elementValue                                         = 135
	Java20ParserRULE_elementValueArrayInitializer                         = 136
	Java20ParserRULE_elementValueList                                     = 137
	Java20ParserRULE_markerAnnotation                                     = 138
	Java20ParserRULE_singleElementAnnotation                              = 139
	Java20ParserRULE_arrayInitializer                                     = 140
	Java20ParserRULE_variableInitializerList                              = 141
	Java20ParserRULE_block                                                = 142
	Java20ParserRULE_blockStatements                                      = 143
	Java20ParserRULE_blockStatement                                       = 144
	Java20ParserRULE_localClassOrInterfaceDeclaration                     = 145
	Java20ParserRULE_localVariableDeclaration                             = 146
	Java20ParserRULE_localVariableType                                    = 147
	Java20ParserRULE_localVariableDeclarationStatement                    = 148
	Java20ParserRULE_statement                                            = 149
	Java20ParserRULE_statementNoShortIf                                   = 150
	Java20ParserRULE_statementWithoutTrailingSubstatement                 = 151
	Java20ParserRULE_emptyStatement_                                      = 152
	Java20ParserRULE_labeledStatement                                     = 153
	Java20ParserRULE_labeledStatementNoShortIf                            = 154
	Java20ParserRULE_expressionStatement                                  = 155
	Java20ParserRULE_statementExpression                                  = 156
	Java20ParserRULE_ifThenStatement                                      = 157
	Java20ParserRULE_ifThenElseStatement                                  = 158
	Java20ParserRULE_ifThenElseStatementNoShortIf                         = 159
	Java20ParserRULE_assertStatement                                      = 160
	Java20ParserRULE_switchStatement                                      = 161
	Java20ParserRULE_switchBlock                                          = 162
	Java20ParserRULE_switchRule                                           = 163
	Java20ParserRULE_switchBlockStatementGroup                            = 164
	Java20ParserRULE_switchLabel                                          = 165
	Java20ParserRULE_caseConstant                                         = 166
	Java20ParserRULE_whileStatement                                       = 167
	Java20ParserRULE_whileStatementNoShortIf                              = 168
	Java20ParserRULE_doStatement                                          = 169
	Java20ParserRULE_forStatement                                         = 170
	Java20ParserRULE_forStatementNoShortIf                                = 171
	Java20ParserRULE_basicForStatement                                    = 172
	Java20ParserRULE_basicForStatementNoShortIf                           = 173
	Java20ParserRULE_forInit                                              = 174
	Java20ParserRULE_forUpdate                                            = 175
	Java20ParserRULE_statementExpressionList                              = 176
	Java20ParserRULE_enhancedForStatement                                 = 177
	Java20ParserRULE_enhancedForStatementNoShortIf                        = 178
	Java20ParserRULE_breakStatement                                       = 179
	Java20ParserRULE_continueStatement                                    = 180
	Java20ParserRULE_returnStatement                                      = 181
	Java20ParserRULE_throwStatement                                       = 182
	Java20ParserRULE_synchronizedStatement                                = 183
	Java20ParserRULE_tryStatement                                         = 184
	Java20ParserRULE_catches                                              = 185
	Java20ParserRULE_catchClause                                          = 186
	Java20ParserRULE_catchFormalParameter                                 = 187
	Java20ParserRULE_catchType                                            = 188
	Java20ParserRULE_finallyBlock                                         = 189
	Java20ParserRULE_tryWithResourcesStatement                            = 190
	Java20ParserRULE_resourceSpecification                                = 191
	Java20ParserRULE_resourceList                                         = 192
	Java20ParserRULE_resource                                             = 193
	Java20ParserRULE_variableAccess                                       = 194
	Java20ParserRULE_yieldStatement                                       = 195
	Java20ParserRULE_pattern                                              = 196
	Java20ParserRULE_typePattern                                          = 197
	Java20ParserRULE_expression                                           = 198
	Java20ParserRULE_primary                                              = 199
	Java20ParserRULE_primaryNoNewArray                                    = 200
	Java20ParserRULE_pNNA                                                 = 201
	Java20ParserRULE_classLiteral                                         = 202
	Java20ParserRULE_classInstanceCreationExpression                      = 203
	Java20ParserRULE_unqualifiedClassInstanceCreationExpression           = 204
	Java20ParserRULE_classOrInterfaceTypeToInstantiate                    = 205
	Java20ParserRULE_typeArgumentsOrDiamond                               = 206
	Java20ParserRULE_arrayCreationExpression                              = 207
	Java20ParserRULE_arrayCreationExpressionWithoutInitializer            = 208
	Java20ParserRULE_arrayCreationExpressionWithInitializer               = 209
	Java20ParserRULE_dimExprs                                             = 210
	Java20ParserRULE_dimExpr                                              = 211
	Java20ParserRULE_arrayAccess                                          = 212
	Java20ParserRULE_fieldAccess                                          = 213
	Java20ParserRULE_methodInvocation                                     = 214
	Java20ParserRULE_argumentList                                         = 215
	Java20ParserRULE_methodReference                                      = 216
	Java20ParserRULE_postfixExpression                                    = 217
	Java20ParserRULE_pfE                                                  = 218
	Java20ParserRULE_postIncrementExpression                              = 219
	Java20ParserRULE_postDecrementExpression                              = 220
	Java20ParserRULE_unaryExpression                                      = 221
	Java20ParserRULE_preIncrementExpression                               = 222
	Java20ParserRULE_preDecrementExpression                               = 223
	Java20ParserRULE_unaryExpressionNotPlusMinus                          = 224
	Java20ParserRULE_castExpression                                       = 225
	Java20ParserRULE_multiplicativeExpression                             = 226
	Java20ParserRULE_additiveExpression                                   = 227
	Java20ParserRULE_shiftExpression                                      = 228
	Java20ParserRULE_relationalExpression                                 = 229
	Java20ParserRULE_equalityExpression                                   = 230
	Java20ParserRULE_andExpression                                        = 231
	Java20ParserRULE_exclusiveOrExpression                                = 232
	Java20ParserRULE_inclusiveOrExpression                                = 233
	Java20ParserRULE_conditionalAndExpression                             = 234
	Java20ParserRULE_conditionalOrExpression                              = 235
	Java20ParserRULE_conditionalExpression                                = 236
	Java20ParserRULE_assignmentExpression                                 = 237
	Java20ParserRULE_assignment                                           = 238
	Java20ParserRULE_leftHandSide                                         = 239
	Java20ParserRULE_assignmentOperator                                   = 240
	Java20ParserRULE_lambdaExpression                                     = 241
	Java20ParserRULE_lambdaParameters                                     = 242
	Java20ParserRULE_lambdaParameterList                                  = 243
	Java20ParserRULE_lambdaParameter                                      = 244
	Java20ParserRULE_lambdaParameterType                                  = 245
	Java20ParserRULE_lambdaBody                                           = 246
	Java20ParserRULE_switchExpression                                     = 247
	Java20ParserRULE_constantExpression                                   = 248
)

// IStart_Context is an interface to support dynamic dispatch.
type IStart_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompilationUnit() ICompilationUnitContext
	EOF() antlr.TerminalNode

	// IsStart_Context differentiates from other interfaces.
	IsStart_Context()
}

type Start_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_Context() *Start_Context {
	var p = new(Start_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_start_
	return p
}

func InitEmptyStart_Context(p *Start_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_start_
}

func (*Start_Context) IsStart_Context() {}

func NewStart_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_Context {
	var p = new(Start_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_start_

	return p
}

func (s *Start_Context) GetParser() antlr.Parser { return s.parser }

func (s *Start_Context) CompilationUnit() ICompilationUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilationUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilationUnitContext)
}

func (s *Start_Context) EOF() antlr.TerminalNode {
	return s.GetToken(Java20ParserEOF, 0)
}

func (s *Start_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStart_(s)
	}
}

func (s *Start_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStart_(s)
	}
}

func (p *Java20Parser) Start_() (localctx IStart_Context) {
	localctx = NewStart_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Java20ParserRULE_start_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.CompilationUnit()
	}
	{
		p.SetState(499)
		p.Match(Java20ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ContextualKeyword() IContextualKeywordContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(Java20ParserIdentifier, 0)
}

func (s *IdentifierContext) ContextualKeyword() IContextualKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextualKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextualKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *Java20Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Java20ParserRULE_identifier)
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(501)
			p.Match(Java20ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.ContextualKeyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ContextualKeywordMinusForTypeIdentifier() IContextualKeywordMinusForTypeIdentifierContext

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(Java20ParserIdentifier, 0)
}

func (s *TypeIdentifierContext) ContextualKeywordMinusForTypeIdentifier() IContextualKeywordMinusForTypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextualKeywordMinusForTypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextualKeywordMinusForTypeIdentifierContext)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (p *Java20Parser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Java20ParserRULE_typeIdentifier)
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.Match(Java20ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPROVIDES, Java20ParserREQUIRES, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(506)
			p.ContextualKeywordMinusForTypeIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnqualifiedMethodIdentifierContext is an interface to support dynamic dispatch.
type IUnqualifiedMethodIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ContextualKeywordMinusForUnqualifiedMethodIdentifier() IContextualKeywordMinusForUnqualifiedMethodIdentifierContext

	// IsUnqualifiedMethodIdentifierContext differentiates from other interfaces.
	IsUnqualifiedMethodIdentifierContext()
}

type UnqualifiedMethodIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnqualifiedMethodIdentifierContext() *UnqualifiedMethodIdentifierContext {
	var p = new(UnqualifiedMethodIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unqualifiedMethodIdentifier
	return p
}

func InitEmptyUnqualifiedMethodIdentifierContext(p *UnqualifiedMethodIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unqualifiedMethodIdentifier
}

func (*UnqualifiedMethodIdentifierContext) IsUnqualifiedMethodIdentifierContext() {}

func NewUnqualifiedMethodIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnqualifiedMethodIdentifierContext {
	var p = new(UnqualifiedMethodIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unqualifiedMethodIdentifier

	return p
}

func (s *UnqualifiedMethodIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnqualifiedMethodIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(Java20ParserIdentifier, 0)
}

func (s *UnqualifiedMethodIdentifierContext) ContextualKeywordMinusForUnqualifiedMethodIdentifier() IContextualKeywordMinusForUnqualifiedMethodIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextualKeywordMinusForUnqualifiedMethodIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextualKeywordMinusForUnqualifiedMethodIdentifierContext)
}

func (s *UnqualifiedMethodIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnqualifiedMethodIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnqualifiedMethodIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnqualifiedMethodIdentifier(s)
	}
}

func (s *UnqualifiedMethodIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnqualifiedMethodIdentifier(s)
	}
}

func (p *Java20Parser) UnqualifiedMethodIdentifier() (localctx IUnqualifiedMethodIdentifierContext) {
	localctx = NewUnqualifiedMethodIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Java20ParserRULE_unqualifiedMethodIdentifier)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(509)
			p.Match(Java20ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(510)
			p.ContextualKeywordMinusForUnqualifiedMethodIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextualKeywordContext is an interface to support dynamic dispatch.
type IContextualKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORTS() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	NONSEALED() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPENS() antlr.TerminalNode
	PERMITS() antlr.TerminalNode
	PROVIDES() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	REQUIRES() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	TO() antlr.TerminalNode
	TRANSITIVE() antlr.TerminalNode
	USES() antlr.TerminalNode
	VAR() antlr.TerminalNode
	WITH() antlr.TerminalNode
	YIELD() antlr.TerminalNode

	// IsContextualKeywordContext differentiates from other interfaces.
	IsContextualKeywordContext()
}

type ContextualKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextualKeywordContext() *ContextualKeywordContext {
	var p = new(ContextualKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_contextualKeyword
	return p
}

func InitEmptyContextualKeywordContext(p *ContextualKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_contextualKeyword
}

func (*ContextualKeywordContext) IsContextualKeywordContext() {}

func NewContextualKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextualKeywordContext {
	var p = new(ContextualKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_contextualKeyword

	return p
}

func (s *ContextualKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextualKeywordContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXPORTS, 0)
}

func (s *ContextualKeywordContext) MODULE() antlr.TerminalNode {
	return s.GetToken(Java20ParserMODULE, 0)
}

func (s *ContextualKeywordContext) NONSEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserNONSEALED, 0)
}

func (s *ContextualKeywordContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPEN, 0)
}

func (s *ContextualKeywordContext) OPENS() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPENS, 0)
}

func (s *ContextualKeywordContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(Java20ParserPERMITS, 0)
}

func (s *ContextualKeywordContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROVIDES, 0)
}

func (s *ContextualKeywordContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Java20ParserRECORD, 0)
}

func (s *ContextualKeywordContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(Java20ParserREQUIRES, 0)
}

func (s *ContextualKeywordContext) SEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEALED, 0)
}

func (s *ContextualKeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(Java20ParserTO, 0)
}

func (s *ContextualKeywordContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(Java20ParserTRANSITIVE, 0)
}

func (s *ContextualKeywordContext) USES() antlr.TerminalNode {
	return s.GetToken(Java20ParserUSES, 0)
}

func (s *ContextualKeywordContext) VAR() antlr.TerminalNode {
	return s.GetToken(Java20ParserVAR, 0)
}

func (s *ContextualKeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(Java20ParserWITH, 0)
}

func (s *ContextualKeywordContext) YIELD() antlr.TerminalNode {
	return s.GetToken(Java20ParserYIELD, 0)
}

func (s *ContextualKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextualKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextualKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterContextualKeyword(s)
	}
}

func (s *ContextualKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitContextualKeyword(s)
	}
}

func (p *Java20Parser) ContextualKeyword() (localctx IContextualKeywordContext) {
	localctx = NewContextualKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Java20ParserRULE_contextualKeyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262126) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextualKeywordMinusForTypeIdentifierContext is an interface to support dynamic dispatch.
type IContextualKeywordMinusForTypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORTS() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	NONSEALED() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPENS() antlr.TerminalNode
	PROVIDES() antlr.TerminalNode
	REQUIRES() antlr.TerminalNode
	TO() antlr.TerminalNode
	TRANSITIVE() antlr.TerminalNode
	USES() antlr.TerminalNode
	WITH() antlr.TerminalNode

	// IsContextualKeywordMinusForTypeIdentifierContext differentiates from other interfaces.
	IsContextualKeywordMinusForTypeIdentifierContext()
}

type ContextualKeywordMinusForTypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextualKeywordMinusForTypeIdentifierContext() *ContextualKeywordMinusForTypeIdentifierContext {
	var p = new(ContextualKeywordMinusForTypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_contextualKeywordMinusForTypeIdentifier
	return p
}

func InitEmptyContextualKeywordMinusForTypeIdentifierContext(p *ContextualKeywordMinusForTypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_contextualKeywordMinusForTypeIdentifier
}

func (*ContextualKeywordMinusForTypeIdentifierContext) IsContextualKeywordMinusForTypeIdentifierContext() {
}

func NewContextualKeywordMinusForTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextualKeywordMinusForTypeIdentifierContext {
	var p = new(ContextualKeywordMinusForTypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_contextualKeywordMinusForTypeIdentifier

	return p
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextualKeywordMinusForTypeIdentifierContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXPORTS, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) MODULE() antlr.TerminalNode {
	return s.GetToken(Java20ParserMODULE, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) NONSEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserNONSEALED, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPEN, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) OPENS() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPENS, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROVIDES, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(Java20ParserREQUIRES, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) TO() antlr.TerminalNode {
	return s.GetToken(Java20ParserTO, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(Java20ParserTRANSITIVE, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) USES() antlr.TerminalNode {
	return s.GetToken(Java20ParserUSES, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(Java20ParserWITH, 0)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterContextualKeywordMinusForTypeIdentifier(s)
	}
}

func (s *ContextualKeywordMinusForTypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitContextualKeywordMinusForTypeIdentifier(s)
	}
}

func (p *Java20Parser) ContextualKeywordMinusForTypeIdentifier() (localctx IContextualKeywordMinusForTypeIdentifierContext) {
	localctx = NewContextualKeywordMinusForTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Java20ParserRULE_contextualKeywordMinusForTypeIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&95598) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContextualKeywordMinusForUnqualifiedMethodIdentifierContext is an interface to support dynamic dispatch.
type IContextualKeywordMinusForUnqualifiedMethodIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORTS() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	NONSEALED() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPENS() antlr.TerminalNode
	PERMITS() antlr.TerminalNode
	PROVIDES() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	REQUIRES() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	TO() antlr.TerminalNode
	TRANSITIVE() antlr.TerminalNode
	USES() antlr.TerminalNode
	VAR() antlr.TerminalNode
	WITH() antlr.TerminalNode

	// IsContextualKeywordMinusForUnqualifiedMethodIdentifierContext differentiates from other interfaces.
	IsContextualKeywordMinusForUnqualifiedMethodIdentifierContext()
}

type ContextualKeywordMinusForUnqualifiedMethodIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextualKeywordMinusForUnqualifiedMethodIdentifierContext() *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext {
	var p = new(ContextualKeywordMinusForUnqualifiedMethodIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_contextualKeywordMinusForUnqualifiedMethodIdentifier
	return p
}

func InitEmptyContextualKeywordMinusForUnqualifiedMethodIdentifierContext(p *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_contextualKeywordMinusForUnqualifiedMethodIdentifier
}

func (*ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) IsContextualKeywordMinusForUnqualifiedMethodIdentifierContext() {
}

func NewContextualKeywordMinusForUnqualifiedMethodIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext {
	var p = new(ContextualKeywordMinusForUnqualifiedMethodIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_contextualKeywordMinusForUnqualifiedMethodIdentifier

	return p
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXPORTS, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) MODULE() antlr.TerminalNode {
	return s.GetToken(Java20ParserMODULE, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) NONSEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserNONSEALED, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPEN, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) OPENS() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPENS, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(Java20ParserPERMITS, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROVIDES, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Java20ParserRECORD, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(Java20ParserREQUIRES, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEALED, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) TO() antlr.TerminalNode {
	return s.GetToken(Java20ParserTO, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(Java20ParserTRANSITIVE, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) USES() antlr.TerminalNode {
	return s.GetToken(Java20ParserUSES, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(Java20ParserVAR, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(Java20ParserWITH, 0)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterContextualKeywordMinusForUnqualifiedMethodIdentifier(s)
	}
}

func (s *ContextualKeywordMinusForUnqualifiedMethodIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitContextualKeywordMinusForUnqualifiedMethodIdentifier(s)
	}
}

func (p *Java20Parser) ContextualKeywordMinusForUnqualifiedMethodIdentifier() (localctx IContextualKeywordMinusForUnqualifiedMethodIdentifierContext) {
	localctx = NewContextualKeywordMinusForUnqualifiedMethodIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Java20ParserRULE_contextualKeywordMinusForUnqualifiedMethodIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&131054) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	FloatingPointLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	CharacterLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	TextBlock() antlr.TerminalNode
	NullLiteral() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(Java20ParserIntegerLiteral, 0)
}

func (s *LiteralContext) FloatingPointLiteral() antlr.TerminalNode {
	return s.GetToken(Java20ParserFloatingPointLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(Java20ParserBooleanLiteral, 0)
}

func (s *LiteralContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(Java20ParserCharacterLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(Java20ParserStringLiteral, 0)
}

func (s *LiteralContext) TextBlock() antlr.TerminalNode {
	return s.GetToken(Java20ParserTextBlock, 0)
}

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(Java20ParserNullLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *Java20Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Java20ParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericType() INumericTypeContext
	BOOLEAN() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) NumericType() INumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *PrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Java20ParserBOOLEAN, 0)
}

func (s *PrimitiveTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *PrimitiveTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *Java20Parser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Java20ParserRULE_primitiveType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(521)
			p.Annotation()
		}

		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserSHORT:
		{
			p.SetState(527)
			p.NumericType()
		}

	case Java20ParserBOOLEAN:
		{
			p.SetState(528)
			p.Match(Java20ParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericTypeContext is an interface to support dynamic dispatch.
type INumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegralType() IIntegralTypeContext
	FloatingPointType() IFloatingPointTypeContext

	// IsNumericTypeContext differentiates from other interfaces.
	IsNumericTypeContext()
}

type NumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericTypeContext() *NumericTypeContext {
	var p = new(NumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_numericType
	return p
}

func InitEmptyNumericTypeContext(p *NumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_numericType
}

func (*NumericTypeContext) IsNumericTypeContext() {}

func NewNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericTypeContext {
	var p = new(NumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_numericType

	return p
}

func (s *NumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericTypeContext) IntegralType() IIntegralTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegralTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegralTypeContext)
}

func (s *NumericTypeContext) FloatingPointType() IFloatingPointTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatingPointTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatingPointTypeContext)
}

func (s *NumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterNumericType(s)
	}
}

func (s *NumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitNumericType(s)
	}
}

func (p *Java20Parser) NumericType() (localctx INumericTypeContext) {
	localctx = NewNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Java20ParserRULE_numericType)
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserBYTE, Java20ParserCHAR, Java20ParserINT, Java20ParserLONG, Java20ParserSHORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(531)
			p.IntegralType()
		}

	case Java20ParserDOUBLE, Java20ParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(532)
			p.FloatingPointType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntegralTypeContext is an interface to support dynamic dispatch.
type IIntegralTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BYTE() antlr.TerminalNode
	SHORT() antlr.TerminalNode
	INT() antlr.TerminalNode
	LONG() antlr.TerminalNode
	CHAR() antlr.TerminalNode

	// IsIntegralTypeContext differentiates from other interfaces.
	IsIntegralTypeContext()
}

type IntegralTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegralTypeContext() *IntegralTypeContext {
	var p = new(IntegralTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_integralType
	return p
}

func InitEmptyIntegralTypeContext(p *IntegralTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_integralType
}

func (*IntegralTypeContext) IsIntegralTypeContext() {}

func NewIntegralTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegralTypeContext {
	var p = new(IntegralTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_integralType

	return p
}

func (s *IntegralTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegralTypeContext) BYTE() antlr.TerminalNode {
	return s.GetToken(Java20ParserBYTE, 0)
}

func (s *IntegralTypeContext) SHORT() antlr.TerminalNode {
	return s.GetToken(Java20ParserSHORT, 0)
}

func (s *IntegralTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(Java20ParserINT, 0)
}

func (s *IntegralTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(Java20ParserLONG, 0)
}

func (s *IntegralTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(Java20ParserCHAR, 0)
}

func (s *IntegralTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegralTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegralTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterIntegralType(s)
	}
}

func (s *IntegralTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitIntegralType(s)
	}
}

func (p *Java20Parser) IntegralType() (localctx IIntegralTypeContext) {
	localctx = NewIntegralTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Java20ParserRULE_integralType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18102359477452800) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatingPointTypeContext is an interface to support dynamic dispatch.
type IFloatingPointTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode

	// IsFloatingPointTypeContext differentiates from other interfaces.
	IsFloatingPointTypeContext()
}

type FloatingPointTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatingPointTypeContext() *FloatingPointTypeContext {
	var p = new(FloatingPointTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_floatingPointType
	return p
}

func InitEmptyFloatingPointTypeContext(p *FloatingPointTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_floatingPointType
}

func (*FloatingPointTypeContext) IsFloatingPointTypeContext() {}

func NewFloatingPointTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatingPointTypeContext {
	var p = new(FloatingPointTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_floatingPointType

	return p
}

func (s *FloatingPointTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatingPointTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(Java20ParserFLOAT, 0)
}

func (s *FloatingPointTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOUBLE, 0)
}

func (s *FloatingPointTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingPointTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatingPointTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterFloatingPointType(s)
	}
}

func (s *FloatingPointTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitFloatingPointType(s)
	}
}

func (p *Java20Parser) FloatingPointType() (localctx IFloatingPointTypeContext) {
	localctx = NewFloatingPointTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Java20ParserRULE_floatingPointType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(537)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Java20ParserDOUBLE || _la == Java20ParserFLOAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceTypeContext is an interface to support dynamic dispatch.
type IReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOrInterfaceType() IClassOrInterfaceTypeContext
	TypeVariable() ITypeVariableContext
	ArrayType() IArrayTypeContext

	// IsReferenceTypeContext differentiates from other interfaces.
	IsReferenceTypeContext()
}

type ReferenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceTypeContext() *ReferenceTypeContext {
	var p = new(ReferenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_referenceType
	return p
}

func InitEmptyReferenceTypeContext(p *ReferenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_referenceType
}

func (*ReferenceTypeContext) IsReferenceTypeContext() {}

func NewReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceTypeContext {
	var p = new(ReferenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_referenceType

	return p
}

func (s *ReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ReferenceTypeContext) TypeVariable() ITypeVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *ReferenceTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterReferenceType(s)
	}
}

func (s *ReferenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitReferenceType(s)
	}
}

func (p *Java20Parser) ReferenceType() (localctx IReferenceTypeContext) {
	localctx = NewReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Java20ParserRULE_referenceType)
	p.SetState(542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(539)
			p.ClassOrInterfaceType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(540)
			p.TypeVariable()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(541)
			p.ArrayType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICoitContext is an interface to support dynamic dispatch.
type ICoitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	TypeArguments() ITypeArgumentsContext
	Coit() ICoitContext

	// IsCoitContext differentiates from other interfaces.
	IsCoitContext()
}

type CoitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoitContext() *CoitContext {
	var p = new(CoitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_coit
	return p
}

func InitEmptyCoitContext(p *CoitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_coit
}

func (*CoitContext) IsCoitContext() {}

func NewCoitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CoitContext {
	var p = new(CoitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_coit

	return p
}

func (s *CoitContext) GetParser() antlr.Parser { return s.parser }

func (s *CoitContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *CoitContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *CoitContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *CoitContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *CoitContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *CoitContext) Coit() ICoitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoitContext)
}

func (s *CoitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CoitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCoit(s)
	}
}

func (s *CoitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCoit(s)
	}
}

func (p *Java20Parser) Coit() (localctx ICoitContext) {
	localctx = NewCoitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Java20ParserRULE_coit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(Java20ParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(545)
			p.Annotation()
		}

		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(551)
		p.TypeIdentifier()
	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(552)
			p.TypeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(555)
			p.Coit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	PackageName() IPackageNameContext
	DOT() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	TypeArguments() ITypeArgumentsContext
	Coit() ICoitContext

	// IsClassOrInterfaceTypeContext differentiates from other interfaces.
	IsClassOrInterfaceTypeContext()
}

type ClassOrInterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeContext() *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classOrInterfaceType
	return p
}

func InitEmptyClassOrInterfaceTypeContext(p *ClassOrInterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classOrInterfaceType
}

func (*ClassOrInterfaceTypeContext) IsClassOrInterfaceTypeContext() {}

func NewClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classOrInterfaceType

	return p
}

func (s *ClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassOrInterfaceTypeContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *ClassOrInterfaceTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ClassOrInterfaceTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassOrInterfaceTypeContext) Coit() ICoitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICoitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICoitContext)
}

func (s *ClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassOrInterfaceType(s)
	}
}

func (p *Java20Parser) ClassOrInterfaceType() (localctx IClassOrInterfaceTypeContext) {
	localctx = NewClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Java20ParserRULE_classOrInterfaceType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(561)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(558)
			p.PackageName()
		}
		{
			p.SetState(559)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(563)
			p.Annotation()
		}

		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(569)
		p.TypeIdentifier()
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(570)
			p.TypeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(573)
			p.Coit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	TypeArguments() ITypeArgumentsContext
	PackageName() IPackageNameContext
	DOT() antlr.TerminalNode
	ClassOrInterfaceType() IClassOrInterfaceTypeContext

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classType
	return p
}

func InitEmptyClassTypeContext(p *ClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classType
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassTypeContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *ClassTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ClassTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (p *Java20Parser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Java20ParserRULE_classType)
	var _la int

	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(576)
				p.Annotation()
			}

			p.SetState(581)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(582)
			p.TypeIdentifier()
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(583)
				p.TypeArguments()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(586)
			p.PackageName()
		}
		{
			p.SetState(587)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(588)
				p.Annotation()
			}

			p.SetState(593)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(594)
			p.TypeIdentifier()
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(595)
				p.TypeArguments()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(598)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(599)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(600)
				p.Annotation()
			}

			p.SetState(605)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(606)
			p.TypeIdentifier()
		}
		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(607)
				p.TypeArguments()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassType() IClassTypeContext

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (p *Java20Parser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Java20ParserRULE_interfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.ClassType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeVariableContext is an interface to support dynamic dispatch.
type ITypeVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsTypeVariableContext differentiates from other interfaces.
	IsTypeVariableContext()
}

type TypeVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeVariableContext() *TypeVariableContext {
	var p = new(TypeVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeVariable
	return p
}

func InitEmptyTypeVariableContext(p *TypeVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeVariable
}

func (*TypeVariableContext) IsTypeVariableContext() {}

func NewTypeVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeVariableContext {
	var p = new(TypeVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeVariable

	return p
}

func (s *TypeVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeVariableContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeVariableContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeVariableContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeVariable(s)
	}
}

func (s *TypeVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeVariable(s)
	}
}

func (p *Java20Parser) TypeVariable() (localctx ITypeVariableContext) {
	localctx = NewTypeVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Java20ParserRULE_typeVariable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(614)
			p.Annotation()
		}

		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(620)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	Dims() IDimsContext
	ClassType() IClassTypeContext
	TypeVariable() ITypeVariableContext

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ArrayTypeContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *ArrayTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *ArrayTypeContext) TypeVariable() ITypeVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (p *Java20Parser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Java20ParserRULE_arrayType)
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(622)
			p.PrimitiveType()
		}
		{
			p.SetState(623)
			p.Dims()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(625)
			p.ClassType()
		}
		{
			p.SetState(626)
			p.Dims()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(628)
			p.TypeVariable()
		}
		{
			p.SetState(629)
			p.Dims()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDimsContext is an interface to support dynamic dispatch.
type IDimsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsDimsContext differentiates from other interfaces.
	IsDimsContext()
}

type DimsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimsContext() *DimsContext {
	var p = new(DimsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_dims
	return p
}

func InitEmptyDimsContext(p *DimsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_dims
}

func (*DimsContext) IsDimsContext() {}

func NewDimsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimsContext {
	var p = new(DimsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_dims

	return p
}

func (s *DimsContext) GetParser() antlr.Parser { return s.parser }

func (s *DimsContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserLBRACK)
}

func (s *DimsContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACK, i)
}

func (s *DimsContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserRBRACK)
}

func (s *DimsContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACK, i)
}

func (s *DimsContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *DimsContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *DimsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterDims(s)
	}
}

func (s *DimsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitDims(s)
	}
}

func (p *Java20Parser) Dims() (localctx IDimsContext) {
	localctx = NewDimsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Java20ParserRULE_dims)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(633)
			p.Annotation()
		}

		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(639)
		p.Match(Java20ParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(640)
		p.Match(Java20ParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(644)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == Java20ParserAT {
				{
					p.SetState(641)
					p.Annotation()
				}

				p.SetState(646)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(647)
				p.Match(Java20ParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(648)
				p.Match(Java20ParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	AllTypeParameterModifier() []ITypeParameterModifierContext
	TypeParameterModifier(i int) ITypeParameterModifierContext
	TypeBound() ITypeBoundContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeParameterContext) AllTypeParameterModifier() []ITypeParameterModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterModifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterModifierContext); ok {
			tst[i] = t.(ITypeParameterModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterContext) TypeParameterModifier(i int) ITypeParameterModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifierContext)
}

func (s *TypeParameterContext) TypeBound() ITypeBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeBoundContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *Java20Parser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Java20ParserRULE_typeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(654)
			p.TypeParameterModifier()
		}

		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(660)
		p.TypeIdentifier()
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserEXTENDS {
		{
			p.SetState(661)
			p.TypeBound()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterModifierContext is an interface to support dynamic dispatch.
type ITypeParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext

	// IsTypeParameterModifierContext differentiates from other interfaces.
	IsTypeParameterModifierContext()
}

type TypeParameterModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifierContext() *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameterModifier
	return p
}

func InitEmptyTypeParameterModifierContext(p *TypeParameterModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameterModifier
}

func (*TypeParameterModifierContext) IsTypeParameterModifierContext() {}

func NewTypeParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeParameterModifier

	return p
}

func (s *TypeParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeParameterModifier(s)
	}
}

func (s *TypeParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeParameterModifier(s)
	}
}

func (p *Java20Parser) TypeParameterModifier() (localctx ITypeParameterModifierContext) {
	localctx = NewTypeParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Java20ParserRULE_typeParameterModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.Annotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeBoundContext is an interface to support dynamic dispatch.
type ITypeBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTENDS() antlr.TerminalNode
	TypeVariable() ITypeVariableContext
	ClassOrInterfaceType() IClassOrInterfaceTypeContext
	AllAdditionalBound() []IAdditionalBoundContext
	AdditionalBound(i int) IAdditionalBoundContext

	// IsTypeBoundContext differentiates from other interfaces.
	IsTypeBoundContext()
}

type TypeBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBoundContext() *TypeBoundContext {
	var p = new(TypeBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeBound
	return p
}

func InitEmptyTypeBoundContext(p *TypeBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeBound
}

func (*TypeBoundContext) IsTypeBoundContext() {}

func NewTypeBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBoundContext {
	var p = new(TypeBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeBound

	return p
}

func (s *TypeBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBoundContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXTENDS, 0)
}

func (s *TypeBoundContext) TypeVariable() ITypeVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *TypeBoundContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *TypeBoundContext) AllAdditionalBound() []IAdditionalBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditionalBoundContext); ok {
			len++
		}
	}

	tst := make([]IAdditionalBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditionalBoundContext); ok {
			tst[i] = t.(IAdditionalBoundContext)
			i++
		}
	}

	return tst
}

func (s *TypeBoundContext) AdditionalBound(i int) IAdditionalBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditionalBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditionalBoundContext)
}

func (s *TypeBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeBound(s)
	}
}

func (s *TypeBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeBound(s)
	}
}

func (p *Java20Parser) TypeBound() (localctx ITypeBoundContext) {
	localctx = NewTypeBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Java20ParserRULE_typeBound)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(Java20ParserEXTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(667)
			p.TypeVariable()
		}

	case 2:
		{
			p.SetState(668)
			p.ClassOrInterfaceType()
		}
		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserBITAND {
			{
				p.SetState(669)
				p.AdditionalBound()
			}

			p.SetState(674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditionalBoundContext is an interface to support dynamic dispatch.
type IAdditionalBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BITAND() antlr.TerminalNode
	InterfaceType() IInterfaceTypeContext

	// IsAdditionalBoundContext differentiates from other interfaces.
	IsAdditionalBoundContext()
}

type AdditionalBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalBoundContext() *AdditionalBoundContext {
	var p = new(AdditionalBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_additionalBound
	return p
}

func InitEmptyAdditionalBoundContext(p *AdditionalBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_additionalBound
}

func (*AdditionalBoundContext) IsAdditionalBoundContext() {}

func NewAdditionalBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalBoundContext {
	var p = new(AdditionalBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_additionalBound

	return p
}

func (s *AdditionalBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalBoundContext) BITAND() antlr.TerminalNode {
	return s.GetToken(Java20ParserBITAND, 0)
}

func (s *AdditionalBoundContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *AdditionalBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAdditionalBound(s)
	}
}

func (s *AdditionalBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAdditionalBound(s)
	}
}

func (p *Java20Parser) AdditionalBound() (localctx IAdditionalBoundContext) {
	localctx = NewAdditionalBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Java20ParserRULE_additionalBound)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Match(Java20ParserBITAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(678)
		p.InterfaceType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	TypeArgumentList() ITypeArgumentListContext
	GT() antlr.TerminalNode

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArguments
	return p
}

func InitEmptyTypeArgumentsContext(p *TypeArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArguments
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(Java20ParserLT, 0)
}

func (s *TypeArgumentsContext) TypeArgumentList() ITypeArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentListContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(Java20ParserGT, 0)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *Java20Parser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Java20ParserRULE_typeArguments)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(Java20ParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(681)
		p.TypeArgumentList()
	}
	{
		p.SetState(682)
		p.Match(Java20ParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentListContext is an interface to support dynamic dispatch.
type ITypeArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeArgument() []ITypeArgumentContext
	TypeArgument(i int) ITypeArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeArgumentListContext differentiates from other interfaces.
	IsTypeArgumentListContext()
}

type TypeArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentListContext() *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArgumentList
	return p
}

func InitEmptyTypeArgumentListContext(p *TypeArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArgumentList
}

func (*TypeArgumentListContext) IsTypeArgumentListContext() {}

func NewTypeArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentListContext {
	var p = new(TypeArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeArgumentList

	return p
}

func (s *TypeArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentListContext) AllTypeArgument() []ITypeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentContext); ok {
			tst[i] = t.(ITypeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentListContext) TypeArgument(i int) ITypeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *TypeArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *TypeArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeArgumentList(s)
	}
}

func (s *TypeArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeArgumentList(s)
	}
}

func (p *Java20Parser) TypeArgumentList() (localctx ITypeArgumentListContext) {
	localctx = NewTypeArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Java20ParserRULE_typeArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.TypeArgument()
	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(685)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(686)
			p.TypeArgument()
		}

		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferenceType() IReferenceTypeContext
	Wildcard() IWildcardContext

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArgument
	return p
}

func InitEmptyTypeArgumentContext(p *TypeArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArgument
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) ReferenceType() IReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *TypeArgumentContext) Wildcard() IWildcardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcardContext)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (p *Java20Parser) TypeArgument() (localctx ITypeArgumentContext) {
	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Java20ParserRULE_typeArgument)
	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(692)
			p.ReferenceType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(693)
			p.Wildcard()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildcardContext is an interface to support dynamic dispatch.
type IWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUESTION() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	WildcardBounds() IWildcardBoundsContext

	// IsWildcardContext differentiates from other interfaces.
	IsWildcardContext()
}

type WildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardContext() *WildcardContext {
	var p = new(WildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_wildcard
	return p
}

func InitEmptyWildcardContext(p *WildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_wildcard
}

func (*WildcardContext) IsWildcardContext() {}

func NewWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardContext {
	var p = new(WildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_wildcard

	return p
}

func (s *WildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(Java20ParserQUESTION, 0)
}

func (s *WildcardContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *WildcardContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *WildcardContext) WildcardBounds() IWildcardBoundsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcardBoundsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcardBoundsContext)
}

func (s *WildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterWildcard(s)
	}
}

func (s *WildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitWildcard(s)
	}
}

func (p *Java20Parser) Wildcard() (localctx IWildcardContext) {
	localctx = NewWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Java20ParserRULE_wildcard)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(696)
			p.Annotation()
		}

		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(702)
		p.Match(Java20ParserQUESTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserEXTENDS || _la == Java20ParserSUPER {
		{
			p.SetState(703)
			p.WildcardBounds()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildcardBoundsContext is an interface to support dynamic dispatch.
type IWildcardBoundsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTENDS() antlr.TerminalNode
	ReferenceType() IReferenceTypeContext
	SUPER() antlr.TerminalNode

	// IsWildcardBoundsContext differentiates from other interfaces.
	IsWildcardBoundsContext()
}

type WildcardBoundsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardBoundsContext() *WildcardBoundsContext {
	var p = new(WildcardBoundsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_wildcardBounds
	return p
}

func InitEmptyWildcardBoundsContext(p *WildcardBoundsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_wildcardBounds
}

func (*WildcardBoundsContext) IsWildcardBoundsContext() {}

func NewWildcardBoundsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardBoundsContext {
	var p = new(WildcardBoundsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_wildcardBounds

	return p
}

func (s *WildcardBoundsContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardBoundsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXTENDS, 0)
}

func (s *WildcardBoundsContext) ReferenceType() IReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *WildcardBoundsContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUPER, 0)
}

func (s *WildcardBoundsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardBoundsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardBoundsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterWildcardBounds(s)
	}
}

func (s *WildcardBoundsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitWildcardBounds(s)
	}
}

func (p *Java20Parser) WildcardBounds() (localctx IWildcardBoundsContext) {
	localctx = NewWildcardBoundsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Java20ParserRULE_wildcardBounds)
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserEXTENDS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(706)
			p.Match(Java20ParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(707)
			p.ReferenceType()
		}

	case Java20ParserSUPER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(708)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(709)
			p.ReferenceType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleNameContext is an interface to support dynamic dispatch.
type IModuleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	ModuleName() IModuleNameContext

	// IsModuleNameContext differentiates from other interfaces.
	IsModuleNameContext()
}

type ModuleNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleNameContext() *ModuleNameContext {
	var p = new(ModuleNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_moduleName
	return p
}

func InitEmptyModuleNameContext(p *ModuleNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_moduleName
}

func (*ModuleNameContext) IsModuleNameContext() {}

func NewModuleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleNameContext {
	var p = new(ModuleNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_moduleName

	return p
}

func (s *ModuleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModuleNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ModuleNameContext) ModuleName() IModuleNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleNameContext)
}

func (s *ModuleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterModuleName(s)
	}
}

func (s *ModuleNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitModuleName(s)
	}
}

func (p *Java20Parser) ModuleName() (localctx IModuleNameContext) {
	localctx = NewModuleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Java20ParserRULE_moduleName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Identifier()
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserDOT {
		{
			p.SetState(713)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(714)
			p.ModuleName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageNameContext is an interface to support dynamic dispatch.
type IPackageNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	PackageName() IPackageNameContext

	// IsPackageNameContext differentiates from other interfaces.
	IsPackageNameContext()
}

type PackageNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageNameContext() *PackageNameContext {
	var p = new(PackageNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageName
	return p
}

func InitEmptyPackageNameContext(p *PackageNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageName
}

func (*PackageNameContext) IsPackageNameContext() {}

func NewPackageNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageNameContext {
	var p = new(PackageNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_packageName

	return p
}

func (s *PackageNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *PackageNameContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *PackageNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPackageName(s)
	}
}

func (s *PackageNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPackageName(s)
	}
}

func (p *Java20Parser) PackageName() (localctx IPackageNameContext) {
	localctx = NewPackageNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Java20ParserRULE_packageName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.Identifier()
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(718)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)
			p.PackageName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageName() IPackageNameContext
	DOT() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeName
	return p
}

func InitEmptyTypeNameContext(p *TypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeName
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *TypeNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *TypeNameContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *Java20Parser) TypeName() (localctx ITypeNameContext) {
	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Java20ParserRULE_typeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.PackageName()
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(723)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(724)
			p.TypeIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageOrTypeNameContext is an interface to support dynamic dispatch.
type IPackageOrTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	PackageOrTypeName() IPackageOrTypeNameContext

	// IsPackageOrTypeNameContext differentiates from other interfaces.
	IsPackageOrTypeNameContext()
}

type PackageOrTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageOrTypeNameContext() *PackageOrTypeNameContext {
	var p = new(PackageOrTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageOrTypeName
	return p
}

func InitEmptyPackageOrTypeNameContext(p *PackageOrTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageOrTypeName
}

func (*PackageOrTypeNameContext) IsPackageOrTypeNameContext() {}

func NewPackageOrTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageOrTypeNameContext {
	var p = new(PackageOrTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_packageOrTypeName

	return p
}

func (s *PackageOrTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageOrTypeNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageOrTypeNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *PackageOrTypeNameContext) PackageOrTypeName() IPackageOrTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageOrTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageOrTypeNameContext)
}

func (s *PackageOrTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageOrTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageOrTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPackageOrTypeName(s)
	}
}

func (s *PackageOrTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPackageOrTypeName(s)
	}
}

func (p *Java20Parser) PackageOrTypeName() (localctx IPackageOrTypeNameContext) {
	localctx = NewPackageOrTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Java20ParserRULE_packageOrTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(727)
		p.Identifier()
	}
	p.SetState(730)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(728)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.PackageOrTypeName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionNameContext is an interface to support dynamic dispatch.
type IExpressionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AmbiguousName() IAmbiguousNameContext
	DOT() antlr.TerminalNode

	// IsExpressionNameContext differentiates from other interfaces.
	IsExpressionNameContext()
}

type ExpressionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionNameContext() *ExpressionNameContext {
	var p = new(ExpressionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_expressionName
	return p
}

func InitEmptyExpressionNameContext(p *ExpressionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_expressionName
}

func (*ExpressionNameContext) IsExpressionNameContext() {}

func NewExpressionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionNameContext {
	var p = new(ExpressionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_expressionName

	return p
}

func (s *ExpressionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionNameContext) AmbiguousName() IAmbiguousNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmbiguousNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmbiguousNameContext)
}

func (s *ExpressionNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ExpressionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterExpressionName(s)
	}
}

func (s *ExpressionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitExpressionName(s)
	}
}

func (p *Java20Parser) ExpressionName() (localctx IExpressionNameContext) {
	localctx = NewExpressionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Java20ParserRULE_expressionName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(735)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(732)
			p.AmbiguousName()
		}
		{
			p.SetState(733)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(737)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodNameContext is an interface to support dynamic dispatch.
type IMethodNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnqualifiedMethodIdentifier() IUnqualifiedMethodIdentifierContext

	// IsMethodNameContext differentiates from other interfaces.
	IsMethodNameContext()
}

type MethodNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodNameContext() *MethodNameContext {
	var p = new(MethodNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodName
	return p
}

func InitEmptyMethodNameContext(p *MethodNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodName
}

func (*MethodNameContext) IsMethodNameContext() {}

func NewMethodNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodNameContext {
	var p = new(MethodNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodName

	return p
}

func (s *MethodNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodNameContext) UnqualifiedMethodIdentifier() IUnqualifiedMethodIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnqualifiedMethodIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedMethodIdentifierContext)
}

func (s *MethodNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodName(s)
	}
}

func (s *MethodNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodName(s)
	}
}

func (p *Java20Parser) MethodName() (localctx IMethodNameContext) {
	localctx = NewMethodNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Java20ParserRULE_methodName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.UnqualifiedMethodIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAmbiguousNameContext is an interface to support dynamic dispatch.
type IAmbiguousNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	AmbiguousName() IAmbiguousNameContext

	// IsAmbiguousNameContext differentiates from other interfaces.
	IsAmbiguousNameContext()
}

type AmbiguousNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmbiguousNameContext() *AmbiguousNameContext {
	var p = new(AmbiguousNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ambiguousName
	return p
}

func InitEmptyAmbiguousNameContext(p *AmbiguousNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ambiguousName
}

func (*AmbiguousNameContext) IsAmbiguousNameContext() {}

func NewAmbiguousNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmbiguousNameContext {
	var p = new(AmbiguousNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_ambiguousName

	return p
}

func (s *AmbiguousNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AmbiguousNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AmbiguousNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *AmbiguousNameContext) AmbiguousName() IAmbiguousNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmbiguousNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmbiguousNameContext)
}

func (s *AmbiguousNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmbiguousNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmbiguousNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAmbiguousName(s)
	}
}

func (s *AmbiguousNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAmbiguousName(s)
	}
}

func (p *Java20Parser) AmbiguousName() (localctx IAmbiguousNameContext) {
	localctx = NewAmbiguousNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Java20ParserRULE_ambiguousName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Identifier()
	}
	p.SetState(744)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(742)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(743)
			p.AmbiguousName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OrdinaryCompilationUnit() IOrdinaryCompilationUnitContext
	ModularCompilationUnit() IModularCompilationUnitContext

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_compilationUnit
	return p
}

func InitEmptyCompilationUnitContext(p *CompilationUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_compilationUnit
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) OrdinaryCompilationUnit() IOrdinaryCompilationUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrdinaryCompilationUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrdinaryCompilationUnitContext)
}

func (s *CompilationUnitContext) ModularCompilationUnit() IModularCompilationUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModularCompilationUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModularCompilationUnitContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *Java20Parser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Java20ParserRULE_compilationUnit)
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(746)
			p.OrdinaryCompilationUnit()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.ModularCompilationUnit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrdinaryCompilationUnitContext is an interface to support dynamic dispatch.
type IOrdinaryCompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageDeclaration() IPackageDeclarationContext
	AllImportDeclaration() []IImportDeclarationContext
	ImportDeclaration(i int) IImportDeclarationContext
	AllTopLevelClassOrInterfaceDeclaration() []ITopLevelClassOrInterfaceDeclarationContext
	TopLevelClassOrInterfaceDeclaration(i int) ITopLevelClassOrInterfaceDeclarationContext

	// IsOrdinaryCompilationUnitContext differentiates from other interfaces.
	IsOrdinaryCompilationUnitContext()
}

type OrdinaryCompilationUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdinaryCompilationUnitContext() *OrdinaryCompilationUnitContext {
	var p = new(OrdinaryCompilationUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ordinaryCompilationUnit
	return p
}

func InitEmptyOrdinaryCompilationUnitContext(p *OrdinaryCompilationUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ordinaryCompilationUnit
}

func (*OrdinaryCompilationUnitContext) IsOrdinaryCompilationUnitContext() {}

func NewOrdinaryCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrdinaryCompilationUnitContext {
	var p = new(OrdinaryCompilationUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_ordinaryCompilationUnit

	return p
}

func (s *OrdinaryCompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *OrdinaryCompilationUnitContext) PackageDeclaration() IPackageDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *OrdinaryCompilationUnitContext) AllImportDeclaration() []IImportDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclarationContext); ok {
			tst[i] = t.(IImportDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *OrdinaryCompilationUnitContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *OrdinaryCompilationUnitContext) AllTopLevelClassOrInterfaceDeclaration() []ITopLevelClassOrInterfaceDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopLevelClassOrInterfaceDeclarationContext); ok {
			len++
		}
	}

	tst := make([]ITopLevelClassOrInterfaceDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopLevelClassOrInterfaceDeclarationContext); ok {
			tst[i] = t.(ITopLevelClassOrInterfaceDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *OrdinaryCompilationUnitContext) TopLevelClassOrInterfaceDeclaration(i int) ITopLevelClassOrInterfaceDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopLevelClassOrInterfaceDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopLevelClassOrInterfaceDeclarationContext)
}

func (s *OrdinaryCompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrdinaryCompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrdinaryCompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterOrdinaryCompilationUnit(s)
	}
}

func (s *OrdinaryCompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitOrdinaryCompilationUnit(s)
	}
}

func (p *Java20Parser) OrdinaryCompilationUnit() (localctx IOrdinaryCompilationUnitContext) {
	localctx = NewOrdinaryCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Java20ParserRULE_ordinaryCompilationUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(750)
			p.PackageDeclaration()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserIMPORT {
		{
			p.SetState(753)
			p.ImportDeclaration()
		}

		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&116002917793925640) != 0) || _la == Java20ParserSEMI || _la == Java20ParserAT {
		{
			p.SetState(759)
			p.TopLevelClassOrInterfaceDeclaration()
		}

		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModularCompilationUnitContext is an interface to support dynamic dispatch.
type IModularCompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModuleDeclaration() IModuleDeclarationContext
	AllImportDeclaration() []IImportDeclarationContext
	ImportDeclaration(i int) IImportDeclarationContext

	// IsModularCompilationUnitContext differentiates from other interfaces.
	IsModularCompilationUnitContext()
}

type ModularCompilationUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModularCompilationUnitContext() *ModularCompilationUnitContext {
	var p = new(ModularCompilationUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_modularCompilationUnit
	return p
}

func InitEmptyModularCompilationUnitContext(p *ModularCompilationUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_modularCompilationUnit
}

func (*ModularCompilationUnitContext) IsModularCompilationUnitContext() {}

func NewModularCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModularCompilationUnitContext {
	var p = new(ModularCompilationUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_modularCompilationUnit

	return p
}

func (s *ModularCompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *ModularCompilationUnitContext) ModuleDeclaration() IModuleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationContext)
}

func (s *ModularCompilationUnitContext) AllImportDeclaration() []IImportDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclarationContext); ok {
			tst[i] = t.(IImportDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ModularCompilationUnitContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ModularCompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModularCompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModularCompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterModularCompilationUnit(s)
	}
}

func (s *ModularCompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitModularCompilationUnit(s)
	}
}

func (p *Java20Parser) ModularCompilationUnit() (localctx IModularCompilationUnitContext) {
	localctx = NewModularCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Java20ParserRULE_modularCompilationUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserIMPORT {
		{
			p.SetState(765)
			p.ImportDeclaration()
		}

		p.SetState(770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(771)
		p.ModuleDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKAGE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	SEMI() antlr.TerminalNode
	AllPackageModifier() []IPackageModifierContext
	PackageModifier(i int) IPackageModifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageDeclaration
	return p
}

func InitEmptyPackageDeclarationContext(p *PackageDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageDeclaration
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(Java20ParserPACKAGE, 0)
}

func (s *PackageDeclarationContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PackageDeclarationContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *PackageDeclarationContext) AllPackageModifier() []IPackageModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackageModifierContext); ok {
			len++
		}
	}

	tst := make([]IPackageModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackageModifierContext); ok {
			tst[i] = t.(IPackageModifierContext)
			i++
		}
	}

	return tst
}

func (s *PackageDeclarationContext) PackageModifier(i int) IPackageModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageModifierContext)
}

func (s *PackageDeclarationContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserDOT)
}

func (s *PackageDeclarationContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, i)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPackageDeclaration(s)
	}
}

func (p *Java20Parser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Java20ParserRULE_packageDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(773)
			p.PackageModifier()
		}

		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(779)
		p.Match(Java20ParserPACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(780)
		p.Identifier()
	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserDOT {
		{
			p.SetState(781)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(782)
			p.Identifier()
		}

		p.SetState(787)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(788)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageModifierContext is an interface to support dynamic dispatch.
type IPackageModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext

	// IsPackageModifierContext differentiates from other interfaces.
	IsPackageModifierContext()
}

type PackageModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageModifierContext() *PackageModifierContext {
	var p = new(PackageModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageModifier
	return p
}

func InitEmptyPackageModifierContext(p *PackageModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_packageModifier
}

func (*PackageModifierContext) IsPackageModifierContext() {}

func NewPackageModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageModifierContext {
	var p = new(PackageModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_packageModifier

	return p
}

func (s *PackageModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PackageModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPackageModifier(s)
	}
}

func (s *PackageModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPackageModifier(s)
	}
}

func (p *Java20Parser) PackageModifier() (localctx IPackageModifierContext) {
	localctx = NewPackageModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Java20ParserRULE_packageModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Annotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleTypeImportDeclaration() ISingleTypeImportDeclarationContext
	TypeImportOnDemandDeclaration() ITypeImportOnDemandDeclarationContext
	SingleStaticImportDeclaration() ISingleStaticImportDeclarationContext
	StaticImportOnDemandDeclaration() IStaticImportOnDemandDeclarationContext

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_importDeclaration
	return p
}

func InitEmptyImportDeclarationContext(p *ImportDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_importDeclaration
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) SingleTypeImportDeclaration() ISingleTypeImportDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTypeImportDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTypeImportDeclarationContext)
}

func (s *ImportDeclarationContext) TypeImportOnDemandDeclaration() ITypeImportOnDemandDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeImportOnDemandDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeImportOnDemandDeclarationContext)
}

func (s *ImportDeclarationContext) SingleStaticImportDeclaration() ISingleStaticImportDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStaticImportDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStaticImportDeclarationContext)
}

func (s *ImportDeclarationContext) StaticImportOnDemandDeclaration() IStaticImportOnDemandDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticImportOnDemandDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticImportOnDemandDeclarationContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *Java20Parser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Java20ParserRULE_importDeclaration)
	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(792)
			p.SingleTypeImportDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(793)
			p.TypeImportOnDemandDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(794)
			p.SingleStaticImportDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(795)
			p.StaticImportOnDemandDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTypeImportDeclarationContext is an interface to support dynamic dispatch.
type ISingleTypeImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	TypeName() ITypeNameContext
	SEMI() antlr.TerminalNode

	// IsSingleTypeImportDeclarationContext differentiates from other interfaces.
	IsSingleTypeImportDeclarationContext()
}

type SingleTypeImportDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTypeImportDeclarationContext() *SingleTypeImportDeclarationContext {
	var p = new(SingleTypeImportDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_singleTypeImportDeclaration
	return p
}

func InitEmptySingleTypeImportDeclarationContext(p *SingleTypeImportDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_singleTypeImportDeclaration
}

func (*SingleTypeImportDeclarationContext) IsSingleTypeImportDeclarationContext() {}

func NewSingleTypeImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeImportDeclarationContext {
	var p = new(SingleTypeImportDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_singleTypeImportDeclaration

	return p
}

func (s *SingleTypeImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java20ParserIMPORT, 0)
}

func (s *SingleTypeImportDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SingleTypeImportDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *SingleTypeImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSingleTypeImportDeclaration(s)
	}
}

func (s *SingleTypeImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSingleTypeImportDeclaration(s)
	}
}

func (p *Java20Parser) SingleTypeImportDeclaration() (localctx ISingleTypeImportDeclarationContext) {
	localctx = NewSingleTypeImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Java20ParserRULE_singleTypeImportDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(Java20ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(799)
		p.TypeName()
	}
	{
		p.SetState(800)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeImportOnDemandDeclarationContext is an interface to support dynamic dispatch.
type ITypeImportOnDemandDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	PackageOrTypeName() IPackageOrTypeNameContext
	DOT() antlr.TerminalNode
	MUL() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsTypeImportOnDemandDeclarationContext differentiates from other interfaces.
	IsTypeImportOnDemandDeclarationContext()
}

type TypeImportOnDemandDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeImportOnDemandDeclarationContext() *TypeImportOnDemandDeclarationContext {
	var p = new(TypeImportOnDemandDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeImportOnDemandDeclaration
	return p
}

func InitEmptyTypeImportOnDemandDeclarationContext(p *TypeImportOnDemandDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeImportOnDemandDeclaration
}

func (*TypeImportOnDemandDeclarationContext) IsTypeImportOnDemandDeclarationContext() {}

func NewTypeImportOnDemandDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeImportOnDemandDeclarationContext {
	var p = new(TypeImportOnDemandDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeImportOnDemandDeclaration

	return p
}

func (s *TypeImportOnDemandDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeImportOnDemandDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java20ParserIMPORT, 0)
}

func (s *TypeImportOnDemandDeclarationContext) PackageOrTypeName() IPackageOrTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageOrTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageOrTypeNameContext)
}

func (s *TypeImportOnDemandDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *TypeImportOnDemandDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(Java20ParserMUL, 0)
}

func (s *TypeImportOnDemandDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *TypeImportOnDemandDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeImportOnDemandDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeImportOnDemandDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeImportOnDemandDeclaration(s)
	}
}

func (s *TypeImportOnDemandDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeImportOnDemandDeclaration(s)
	}
}

func (p *Java20Parser) TypeImportOnDemandDeclaration() (localctx ITypeImportOnDemandDeclarationContext) {
	localctx = NewTypeImportOnDemandDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Java20ParserRULE_typeImportOnDemandDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Match(Java20ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(803)
		p.PackageOrTypeName()
	}
	{
		p.SetState(804)
		p.Match(Java20ParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(805)
		p.Match(Java20ParserMUL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(806)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStaticImportDeclarationContext is an interface to support dynamic dispatch.
type ISingleStaticImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	TypeName() ITypeNameContext
	DOT() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode

	// IsSingleStaticImportDeclarationContext differentiates from other interfaces.
	IsSingleStaticImportDeclarationContext()
}

type SingleStaticImportDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStaticImportDeclarationContext() *SingleStaticImportDeclarationContext {
	var p = new(SingleStaticImportDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_singleStaticImportDeclaration
	return p
}

func InitEmptySingleStaticImportDeclarationContext(p *SingleStaticImportDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_singleStaticImportDeclaration
}

func (*SingleStaticImportDeclarationContext) IsSingleStaticImportDeclarationContext() {}

func NewSingleStaticImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStaticImportDeclarationContext {
	var p = new(SingleStaticImportDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_singleStaticImportDeclaration

	return p
}

func (s *SingleStaticImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStaticImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java20ParserIMPORT, 0)
}

func (s *SingleStaticImportDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *SingleStaticImportDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SingleStaticImportDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *SingleStaticImportDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleStaticImportDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *SingleStaticImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStaticImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStaticImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSingleStaticImportDeclaration(s)
	}
}

func (s *SingleStaticImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSingleStaticImportDeclaration(s)
	}
}

func (p *Java20Parser) SingleStaticImportDeclaration() (localctx ISingleStaticImportDeclarationContext) {
	localctx = NewSingleStaticImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Java20ParserRULE_singleStaticImportDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.Match(Java20ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(809)
		p.Match(Java20ParserSTATIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(810)
		p.TypeName()
	}
	{
		p.SetState(811)
		p.Match(Java20ParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(812)
		p.Identifier()
	}
	{
		p.SetState(813)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStaticImportOnDemandDeclarationContext is an interface to support dynamic dispatch.
type IStaticImportOnDemandDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	TypeName() ITypeNameContext
	DOT() antlr.TerminalNode
	MUL() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsStaticImportOnDemandDeclarationContext differentiates from other interfaces.
	IsStaticImportOnDemandDeclarationContext()
}

type StaticImportOnDemandDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticImportOnDemandDeclarationContext() *StaticImportOnDemandDeclarationContext {
	var p = new(StaticImportOnDemandDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_staticImportOnDemandDeclaration
	return p
}

func InitEmptyStaticImportOnDemandDeclarationContext(p *StaticImportOnDemandDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_staticImportOnDemandDeclaration
}

func (*StaticImportOnDemandDeclarationContext) IsStaticImportOnDemandDeclarationContext() {}

func NewStaticImportOnDemandDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticImportOnDemandDeclarationContext {
	var p = new(StaticImportOnDemandDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_staticImportOnDemandDeclaration

	return p
}

func (s *StaticImportOnDemandDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticImportOnDemandDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Java20ParserIMPORT, 0)
}

func (s *StaticImportOnDemandDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *StaticImportOnDemandDeclarationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *StaticImportOnDemandDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *StaticImportOnDemandDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(Java20ParserMUL, 0)
}

func (s *StaticImportOnDemandDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *StaticImportOnDemandDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticImportOnDemandDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticImportOnDemandDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStaticImportOnDemandDeclaration(s)
	}
}

func (s *StaticImportOnDemandDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStaticImportOnDemandDeclaration(s)
	}
}

func (p *Java20Parser) StaticImportOnDemandDeclaration() (localctx IStaticImportOnDemandDeclarationContext) {
	localctx = NewStaticImportOnDemandDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Java20ParserRULE_staticImportOnDemandDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(815)
		p.Match(Java20ParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(816)
		p.Match(Java20ParserSTATIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(817)
		p.TypeName()
	}
	{
		p.SetState(818)
		p.Match(Java20ParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(819)
		p.Match(Java20ParserMUL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(820)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopLevelClassOrInterfaceDeclarationContext is an interface to support dynamic dispatch.
type ITopLevelClassOrInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	SEMI() antlr.TerminalNode

	// IsTopLevelClassOrInterfaceDeclarationContext differentiates from other interfaces.
	IsTopLevelClassOrInterfaceDeclarationContext()
}

type TopLevelClassOrInterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopLevelClassOrInterfaceDeclarationContext() *TopLevelClassOrInterfaceDeclarationContext {
	var p = new(TopLevelClassOrInterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_topLevelClassOrInterfaceDeclaration
	return p
}

func InitEmptyTopLevelClassOrInterfaceDeclarationContext(p *TopLevelClassOrInterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_topLevelClassOrInterfaceDeclaration
}

func (*TopLevelClassOrInterfaceDeclarationContext) IsTopLevelClassOrInterfaceDeclarationContext() {}

func NewTopLevelClassOrInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopLevelClassOrInterfaceDeclarationContext {
	var p = new(TopLevelClassOrInterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_topLevelClassOrInterfaceDeclaration

	return p
}

func (s *TopLevelClassOrInterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TopLevelClassOrInterfaceDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TopLevelClassOrInterfaceDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TopLevelClassOrInterfaceDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *TopLevelClassOrInterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopLevelClassOrInterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopLevelClassOrInterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTopLevelClassOrInterfaceDeclaration(s)
	}
}

func (s *TopLevelClassOrInterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTopLevelClassOrInterfaceDeclaration(s)
	}
}

func (p *Java20Parser) TopLevelClassOrInterfaceDeclaration() (localctx ITopLevelClassOrInterfaceDeclarationContext) {
	localctx = NewTopLevelClassOrInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Java20ParserRULE_topLevelClassOrInterfaceDeclaration)
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(822)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(823)
			p.InterfaceDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(824)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleDeclarationContext is an interface to support dynamic dispatch.
type IModuleDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODULE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	OPEN() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllModuleDirective() []IModuleDirectiveContext
	ModuleDirective(i int) IModuleDirectiveContext

	// IsModuleDeclarationContext differentiates from other interfaces.
	IsModuleDeclarationContext()
}

type ModuleDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclarationContext() *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_moduleDeclaration
	return p
}

func InitEmptyModuleDeclarationContext(p *ModuleDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_moduleDeclaration
}

func (*ModuleDeclarationContext) IsModuleDeclarationContext() {}

func NewModuleDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_moduleDeclaration

	return p
}

func (s *ModuleDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclarationContext) MODULE() antlr.TerminalNode {
	return s.GetToken(Java20ParserMODULE, 0)
}

func (s *ModuleDeclarationContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDeclarationContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModuleDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *ModuleDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *ModuleDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModuleDeclarationContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPEN, 0)
}

func (s *ModuleDeclarationContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserDOT)
}

func (s *ModuleDeclarationContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, i)
}

func (s *ModuleDeclarationContext) AllModuleDirective() []IModuleDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IModuleDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleDirectiveContext); ok {
			tst[i] = t.(IModuleDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDeclarationContext) ModuleDirective(i int) IModuleDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDirectiveContext)
}

func (s *ModuleDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterModuleDeclaration(s)
	}
}

func (s *ModuleDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitModuleDeclaration(s)
	}
}

func (p *Java20Parser) ModuleDeclaration() (localctx IModuleDeclarationContext) {
	localctx = NewModuleDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Java20ParserRULE_moduleDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(827)
			p.Annotation()
		}

		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserOPEN {
		{
			p.SetState(833)
			p.Match(Java20ParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(836)
		p.Match(Java20ParserMODULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(837)
		p.Identifier()
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserDOT {
		{
			p.SetState(838)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(839)
			p.Identifier()
		}

		p.SetState(844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(845)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17730) != 0 {
		{
			p.SetState(846)
			p.ModuleDirective()
		}

		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(852)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleDirectiveContext is an interface to support dynamic dispatch.
type IModuleDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REQUIRES() antlr.TerminalNode
	AllModuleName() []IModuleNameContext
	ModuleName(i int) IModuleNameContext
	SEMI() antlr.TerminalNode
	AllRequiresModifier() []IRequiresModifierContext
	RequiresModifier(i int) IRequiresModifierContext
	EXPORTS() antlr.TerminalNode
	PackageName() IPackageNameContext
	TO() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	OPENS() antlr.TerminalNode
	USES() antlr.TerminalNode
	AllTypeName() []ITypeNameContext
	TypeName(i int) ITypeNameContext
	PROVIDES() antlr.TerminalNode
	WITH() antlr.TerminalNode

	// IsModuleDirectiveContext differentiates from other interfaces.
	IsModuleDirectiveContext()
}

type ModuleDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDirectiveContext() *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_moduleDirective
	return p
}

func InitEmptyModuleDirectiveContext(p *ModuleDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_moduleDirective
}

func (*ModuleDirectiveContext) IsModuleDirectiveContext() {}

func NewModuleDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_moduleDirective

	return p
}

func (s *ModuleDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDirectiveContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(Java20ParserREQUIRES, 0)
}

func (s *ModuleDirectiveContext) AllModuleName() []IModuleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleNameContext); ok {
			len++
		}
	}

	tst := make([]IModuleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleNameContext); ok {
			tst[i] = t.(IModuleNameContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) ModuleName(i int) IModuleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleNameContext)
}

func (s *ModuleDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ModuleDirectiveContext) AllRequiresModifier() []IRequiresModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRequiresModifierContext); ok {
			len++
		}
	}

	tst := make([]IRequiresModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRequiresModifierContext); ok {
			tst[i] = t.(IRequiresModifierContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) RequiresModifier(i int) IRequiresModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiresModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiresModifierContext)
}

func (s *ModuleDirectiveContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXPORTS, 0)
}

func (s *ModuleDirectiveContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *ModuleDirectiveContext) TO() antlr.TerminalNode {
	return s.GetToken(Java20ParserTO, 0)
}

func (s *ModuleDirectiveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *ModuleDirectiveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *ModuleDirectiveContext) OPENS() antlr.TerminalNode {
	return s.GetToken(Java20ParserOPENS, 0)
}

func (s *ModuleDirectiveContext) USES() antlr.TerminalNode {
	return s.GetToken(Java20ParserUSES, 0)
}

func (s *ModuleDirectiveContext) AllTypeName() []ITypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNameContext); ok {
			len++
		}
	}

	tst := make([]ITypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNameContext); ok {
			tst[i] = t.(ITypeNameContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) TypeName(i int) ITypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ModuleDirectiveContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROVIDES, 0)
}

func (s *ModuleDirectiveContext) WITH() antlr.TerminalNode {
	return s.GetToken(Java20ParserWITH, 0)
}

func (s *ModuleDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterModuleDirective(s)
	}
}

func (s *ModuleDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitModuleDirective(s)
	}
}

func (p *Java20Parser) ModuleDirective() (localctx IModuleDirectiveContext) {
	localctx = NewModuleDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Java20ParserRULE_moduleDirective)
	var _la int

	var _alt int

	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserREQUIRES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(854)
			p.Match(Java20ParserREQUIRES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(855)
					p.RequiresModifier()
				}

			}
			p.SetState(860)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(861)
			p.ModuleName()
		}
		{
			p.SetState(862)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserEXPORTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.Match(Java20ParserEXPORTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(865)
			p.PackageName()
		}
		p.SetState(875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserTO {
			{
				p.SetState(866)
				p.Match(Java20ParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(867)
				p.ModuleName()
			}
			p.SetState(872)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == Java20ParserCOMMA {
				{
					p.SetState(868)
					p.Match(Java20ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(869)
					p.ModuleName()
				}

				p.SetState(874)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(877)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserOPENS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(879)
			p.Match(Java20ParserOPENS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(880)
			p.PackageName()
		}
		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserTO {
			{
				p.SetState(881)
				p.Match(Java20ParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(882)
				p.ModuleName()
			}
			p.SetState(887)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == Java20ParserCOMMA {
				{
					p.SetState(883)
					p.Match(Java20ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(884)
					p.ModuleName()
				}

				p.SetState(889)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(892)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserUSES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(894)
			p.Match(Java20ParserUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(895)
			p.TypeName()
		}
		{
			p.SetState(896)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPROVIDES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(898)
			p.Match(Java20ParserPROVIDES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(899)
			p.TypeName()
		}
		{
			p.SetState(900)
			p.Match(Java20ParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(901)
			p.TypeName()
		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserCOMMA {
			{
				p.SetState(902)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(903)
				p.TypeName()
			}

			p.SetState(908)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(909)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequiresModifierContext is an interface to support dynamic dispatch.
type IRequiresModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRANSITIVE() antlr.TerminalNode
	STATIC() antlr.TerminalNode

	// IsRequiresModifierContext differentiates from other interfaces.
	IsRequiresModifierContext()
}

type RequiresModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiresModifierContext() *RequiresModifierContext {
	var p = new(RequiresModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_requiresModifier
	return p
}

func InitEmptyRequiresModifierContext(p *RequiresModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_requiresModifier
}

func (*RequiresModifierContext) IsRequiresModifierContext() {}

func NewRequiresModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiresModifierContext {
	var p = new(RequiresModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_requiresModifier

	return p
}

func (s *RequiresModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiresModifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(Java20ParserTRANSITIVE, 0)
}

func (s *RequiresModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *RequiresModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiresModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiresModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRequiresModifier(s)
	}
}

func (s *RequiresModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRequiresModifier(s)
	}
}

func (p *Java20Parser) RequiresModifier() (localctx IRequiresModifierContext) {
	localctx = NewRequiresModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Java20ParserRULE_requiresModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Java20ParserTRANSITIVE || _la == Java20ParserSTATIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NormalClassDeclaration() INormalClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	RecordDeclaration() IRecordDeclarationContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) NormalClassDeclaration() INormalClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalClassDeclarationContext)
}

func (s *ClassDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *ClassDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *Java20Parser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Java20ParserRULE_classDeclaration)
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.NormalClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(916)
			p.EnumDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(917)
			p.RecordDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalClassDeclarationContext is an interface to support dynamic dispatch.
type INormalClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	ClassBody() IClassBodyContext
	AllClassModifier() []IClassModifierContext
	ClassModifier(i int) IClassModifierContext
	TypeParameters() ITypeParametersContext
	ClassExtends() IClassExtendsContext
	ClassImplements() IClassImplementsContext
	ClassPermits() IClassPermitsContext

	// IsNormalClassDeclarationContext differentiates from other interfaces.
	IsNormalClassDeclarationContext()
}

type NormalClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalClassDeclarationContext() *NormalClassDeclarationContext {
	var p = new(NormalClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_normalClassDeclaration
	return p
}

func InitEmptyNormalClassDeclarationContext(p *NormalClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_normalClassDeclaration
}

func (*NormalClassDeclarationContext) IsNormalClassDeclarationContext() {}

func NewNormalClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalClassDeclarationContext {
	var p = new(NormalClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_normalClassDeclaration

	return p
}

func (s *NormalClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Java20ParserCLASS, 0)
}

func (s *NormalClassDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *NormalClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *NormalClassDeclarationContext) AllClassModifier() []IClassModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassModifierContext); ok {
			tst[i] = t.(IClassModifierContext)
			i++
		}
	}

	return tst
}

func (s *NormalClassDeclarationContext) ClassModifier(i int) IClassModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *NormalClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *NormalClassDeclarationContext) ClassExtends() IClassExtendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassExtendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassExtendsContext)
}

func (s *NormalClassDeclarationContext) ClassImplements() IClassImplementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsContext)
}

func (s *NormalClassDeclarationContext) ClassPermits() IClassPermitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPermitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPermitsContext)
}

func (s *NormalClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterNormalClassDeclaration(s)
	}
}

func (s *NormalClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitNormalClassDeclaration(s)
	}
}

func (p *Java20Parser) NormalClassDeclaration() (localctx INormalClassDeclarationContext) {
	localctx = NewNormalClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Java20ParserRULE_normalClassDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&115967724764792840) != 0) || _la == Java20ParserAT {
		{
			p.SetState(920)
			p.ClassModifier()
		}

		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(926)
		p.Match(Java20ParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(927)
		p.TypeIdentifier()
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLT {
		{
			p.SetState(928)
			p.TypeParameters()
		}

	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserEXTENDS {
		{
			p.SetState(931)
			p.ClassExtends()
		}

	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserIMPLEMENTS {
		{
			p.SetState(934)
			p.ClassImplements()
		}

	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserPERMITS {
		{
			p.SetState(937)
			p.ClassPermits()
		}

	}
	{
		p.SetState(940)
		p.ClassBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassModifierContext is an interface to support dynamic dispatch.
type IClassModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	NONSEALED() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode

	// IsClassModifierContext differentiates from other interfaces.
	IsClassModifierContext()
}

type ClassModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassModifierContext() *ClassModifierContext {
	var p = new(ClassModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classModifier
	return p
}

func InitEmptyClassModifierContext(p *ClassModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classModifier
}

func (*ClassModifierContext) IsClassModifierContext() {}

func NewClassModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassModifierContext {
	var p = new(ClassModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classModifier

	return p
}

func (s *ClassModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *ClassModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROTECTED, 0)
}

func (s *ClassModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java20ParserPRIVATE, 0)
}

func (s *ClassModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java20ParserABSTRACT, 0)
}

func (s *ClassModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *ClassModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java20ParserFINAL, 0)
}

func (s *ClassModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEALED, 0)
}

func (s *ClassModifierContext) NONSEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserNONSEALED, 0)
}

func (s *ClassModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTRICTFP, 0)
}

func (s *ClassModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassModifier(s)
	}
}

func (s *ClassModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassModifier(s)
	}
}

func (p *Java20Parser) ClassModifier() (localctx IClassModifierContext) {
	localctx = NewClassModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Java20ParserRULE_classModifier)
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(942)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(943)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(944)
			p.Match(Java20ParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(945)
			p.Match(Java20ParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserABSTRACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(946)
			p.Match(Java20ParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(947)
			p.Match(Java20ParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserFINAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(948)
			p.Match(Java20ParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSEALED:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(949)
			p.Match(Java20ParserSEALED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserNONSEALED:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(950)
			p.Match(Java20ParserNONSEALED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(951)
			p.Match(Java20ParserSTRICTFP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	TypeParameterList() ITypeParameterListContext
	GT() antlr.TerminalNode

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameters
	return p
}

func InitEmptyTypeParametersContext(p *TypeParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameters
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(Java20ParserLT, 0)
}

func (s *TypeParametersContext) TypeParameterList() ITypeParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListContext)
}

func (s *TypeParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(Java20ParserGT, 0)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *Java20Parser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Java20ParserRULE_typeParameters)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.Match(Java20ParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(955)
		p.TypeParameterList()
	}
	{
		p.SetState(956)
		p.Match(Java20ParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterListContext is an interface to support dynamic dispatch.
type ITypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeParameterListContext differentiates from other interfaces.
	IsTypeParameterListContext()
}

type TypeParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListContext() *TypeParameterListContext {
	var p = new(TypeParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameterList
	return p
}

func InitEmptyTypeParameterListContext(p *TypeParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeParameterList
}

func (*TypeParameterListContext) IsTypeParameterListContext() {}

func NewTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListContext {
	var p = new(TypeParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeParameterList

	return p
}

func (s *TypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterListContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *TypeParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *TypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeParameterList(s)
	}
}

func (s *TypeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeParameterList(s)
	}
}

func (p *Java20Parser) TypeParameterList() (localctx ITypeParameterListContext) {
	localctx = NewTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Java20ParserRULE_typeParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)
		p.TypeParameter()
	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(959)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(960)
			p.TypeParameter()
		}

		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassExtendsContext is an interface to support dynamic dispatch.
type IClassExtendsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTENDS() antlr.TerminalNode
	ClassType() IClassTypeContext

	// IsClassExtendsContext differentiates from other interfaces.
	IsClassExtendsContext()
}

type ClassExtendsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassExtendsContext() *ClassExtendsContext {
	var p = new(ClassExtendsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classExtends
	return p
}

func InitEmptyClassExtendsContext(p *ClassExtendsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classExtends
}

func (*ClassExtendsContext) IsClassExtendsContext() {}

func NewClassExtendsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassExtendsContext {
	var p = new(ClassExtendsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classExtends

	return p
}

func (s *ClassExtendsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassExtendsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXTENDS, 0)
}

func (s *ClassExtendsContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *ClassExtendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExtendsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassExtendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassExtends(s)
	}
}

func (s *ClassExtendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassExtends(s)
	}
}

func (p *Java20Parser) ClassExtends() (localctx IClassExtendsContext) {
	localctx = NewClassExtendsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Java20ParserRULE_classExtends)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(966)
		p.Match(Java20ParserEXTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(967)
		p.ClassType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplementsContext is an interface to support dynamic dispatch.
type IClassImplementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTS() antlr.TerminalNode
	InterfaceTypeList() IInterfaceTypeListContext

	// IsClassImplementsContext differentiates from other interfaces.
	IsClassImplementsContext()
}

type ClassImplementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplementsContext() *ClassImplementsContext {
	var p = new(ClassImplementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classImplements
	return p
}

func InitEmptyClassImplementsContext(p *ClassImplementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classImplements
}

func (*ClassImplementsContext) IsClassImplementsContext() {}

func NewClassImplementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplementsContext {
	var p = new(ClassImplementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classImplements

	return p
}

func (s *ClassImplementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplementsContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(Java20ParserIMPLEMENTS, 0)
}

func (s *ClassImplementsContext) InterfaceTypeList() IInterfaceTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeListContext)
}

func (s *ClassImplementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassImplements(s)
	}
}

func (s *ClassImplementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassImplements(s)
	}
}

func (p *Java20Parser) ClassImplements() (localctx IClassImplementsContext) {
	localctx = NewClassImplementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Java20ParserRULE_classImplements)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(Java20ParserIMPLEMENTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(970)
		p.InterfaceTypeList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeListContext is an interface to support dynamic dispatch.
type IInterfaceTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceType() []IInterfaceTypeContext
	InterfaceType(i int) IInterfaceTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInterfaceTypeListContext differentiates from other interfaces.
	IsInterfaceTypeListContext()
}

type InterfaceTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeListContext() *InterfaceTypeListContext {
	var p = new(InterfaceTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceTypeList
	return p
}

func InitEmptyInterfaceTypeListContext(p *InterfaceTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceTypeList
}

func (*InterfaceTypeListContext) IsInterfaceTypeListContext() {}

func NewInterfaceTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeListContext {
	var p = new(InterfaceTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceTypeList

	return p
}

func (s *InterfaceTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeListContext) AllInterfaceType() []IInterfaceTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceTypeContext); ok {
			tst[i] = t.(IInterfaceTypeContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeListContext) InterfaceType(i int) IInterfaceTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *InterfaceTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *InterfaceTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *InterfaceTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceTypeList(s)
	}
}

func (s *InterfaceTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceTypeList(s)
	}
}

func (p *Java20Parser) InterfaceTypeList() (localctx IInterfaceTypeListContext) {
	localctx = NewInterfaceTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Java20ParserRULE_interfaceTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(972)
		p.InterfaceType()
	}
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(973)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(974)
			p.InterfaceType()
		}

		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPermitsContext is an interface to support dynamic dispatch.
type IClassPermitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERMITS() antlr.TerminalNode
	AllTypeName() []ITypeNameContext
	TypeName(i int) ITypeNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClassPermitsContext differentiates from other interfaces.
	IsClassPermitsContext()
}

type ClassPermitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPermitsContext() *ClassPermitsContext {
	var p = new(ClassPermitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classPermits
	return p
}

func InitEmptyClassPermitsContext(p *ClassPermitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classPermits
}

func (*ClassPermitsContext) IsClassPermitsContext() {}

func NewClassPermitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPermitsContext {
	var p = new(ClassPermitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classPermits

	return p
}

func (s *ClassPermitsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPermitsContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(Java20ParserPERMITS, 0)
}

func (s *ClassPermitsContext) AllTypeName() []ITypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNameContext); ok {
			len++
		}
	}

	tst := make([]ITypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNameContext); ok {
			tst[i] = t.(ITypeNameContext)
			i++
		}
	}

	return tst
}

func (s *ClassPermitsContext) TypeName(i int) ITypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ClassPermitsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *ClassPermitsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *ClassPermitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPermitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPermitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassPermits(s)
	}
}

func (s *ClassPermitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassPermits(s)
	}
}

func (p *Java20Parser) ClassPermits() (localctx IClassPermitsContext) {
	localctx = NewClassPermitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Java20ParserRULE_classPermits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.Match(Java20ParserPERMITS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(981)
		p.TypeName()
	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(982)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.TypeName()
		}

		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *Java20Parser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Java20ParserRULE_classBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8512665130203873298) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230376187502595) != 0) {
		{
			p.SetState(990)
			p.ClassBodyDeclaration()
		}

		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(996)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassMemberDeclaration() IClassMemberDeclarationContext
	InstanceInitializer() IInstanceInitializerContext
	StaticInitializer() IStaticInitializerContext
	ConstructorDeclaration() IConstructorDeclarationContext

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classBodyDeclaration
	return p
}

func InitEmptyClassBodyDeclarationContext(p *ClassBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classBodyDeclaration
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) ClassMemberDeclaration() IClassMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) InstanceInitializer() IInstanceInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceInitializerContext)
}

func (s *ClassBodyDeclarationContext) StaticInitializer() IStaticInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticInitializerContext)
}

func (s *ClassBodyDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (p *Java20Parser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Java20ParserRULE_classBodyDeclaration)
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(998)
			p.ClassMemberDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(999)
			p.InstanceInitializer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1000)
			p.StaticInitializer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1001)
			p.ConstructorDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMemberDeclarationContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldDeclaration() IFieldDeclarationContext
	MethodDeclaration() IMethodDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	SEMI() antlr.TerminalNode

	// IsClassMemberDeclarationContext differentiates from other interfaces.
	IsClassMemberDeclarationContext()
}

type ClassMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationContext() *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classMemberDeclaration
	return p
}

func InitEmptyClassMemberDeclarationContext(p *ClassMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classMemberDeclaration
}

func (*ClassMemberDeclarationContext) IsClassMemberDeclarationContext() {}

func NewClassMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classMemberDeclaration

	return p
}

func (s *ClassMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *ClassMemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *ClassMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *ClassMemberDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ClassMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassMemberDeclaration(s)
	}
}

func (s *ClassMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassMemberDeclaration(s)
	}
}

func (p *Java20Parser) ClassMemberDeclaration() (localctx IClassMemberDeclarationContext) {
	localctx = NewClassMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Java20ParserRULE_classMemberDeclaration)
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1004)
			p.FieldDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1005)
			p.MethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1006)
			p.ClassDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1007)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1008)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	VariableDeclaratorList() IVariableDeclaratorListContext
	SEMI() antlr.TerminalNode
	AllFieldModifier() []IFieldModifierContext
	FieldModifier(i int) IFieldModifierContext

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_fieldDeclaration
	return p
}

func InitEmptyFieldDeclarationContext(p *FieldDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_fieldDeclaration
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *FieldDeclarationContext) VariableDeclaratorList() IVariableDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorListContext)
}

func (s *FieldDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *FieldDeclarationContext) AllFieldModifier() []IFieldModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldModifierContext); ok {
			len++
		}
	}

	tst := make([]IFieldModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldModifierContext); ok {
			tst[i] = t.(IFieldModifierContext)
			i++
		}
	}

	return tst
}

func (s *FieldDeclarationContext) FieldModifier(i int) IFieldModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldModifierContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (p *Java20Parser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Java20ParserRULE_fieldDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-35)) & ^0x3f) == 0 && ((int64(1)<<(_la-35))&2251802230882305) != 0 {
		{
			p.SetState(1011)
			p.FieldModifier()
		}

		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1017)
		p.UnannType()
	}
	{
		p.SetState(1018)
		p.VariableDeclaratorList()
	}
	{
		p.SetState(1019)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldModifierContext is an interface to support dynamic dispatch.
type IFieldModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	VOLATILE() antlr.TerminalNode

	// IsFieldModifierContext differentiates from other interfaces.
	IsFieldModifierContext()
}

type FieldModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldModifierContext() *FieldModifierContext {
	var p = new(FieldModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_fieldModifier
	return p
}

func InitEmptyFieldModifierContext(p *FieldModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_fieldModifier
}

func (*FieldModifierContext) IsFieldModifierContext() {}

func NewFieldModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldModifierContext {
	var p = new(FieldModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_fieldModifier

	return p
}

func (s *FieldModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *FieldModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *FieldModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROTECTED, 0)
}

func (s *FieldModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java20ParserPRIVATE, 0)
}

func (s *FieldModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *FieldModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java20ParserFINAL, 0)
}

func (s *FieldModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(Java20ParserTRANSIENT, 0)
}

func (s *FieldModifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(Java20ParserVOLATILE, 0)
}

func (s *FieldModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterFieldModifier(s)
	}
}

func (s *FieldModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitFieldModifier(s)
	}
}

func (p *Java20Parser) FieldModifier() (localctx IFieldModifierContext) {
	localctx = NewFieldModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Java20ParserRULE_fieldModifier)
	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1023)
			p.Match(Java20ParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1024)
			p.Match(Java20ParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTATIC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1025)
			p.Match(Java20ParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserFINAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1026)
			p.Match(Java20ParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserTRANSIENT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1027)
			p.Match(Java20ParserTRANSIENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserVOLATILE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1028)
			p.Match(Java20ParserVOLATILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorListContext is an interface to support dynamic dispatch.
type IVariableDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclarator() []IVariableDeclaratorContext
	VariableDeclarator(i int) IVariableDeclaratorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableDeclaratorListContext differentiates from other interfaces.
	IsVariableDeclaratorListContext()
}

type VariableDeclaratorListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorListContext() *VariableDeclaratorListContext {
	var p = new(VariableDeclaratorListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableDeclaratorList
	return p
}

func InitEmptyVariableDeclaratorListContext(p *VariableDeclaratorListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableDeclaratorList
}

func (*VariableDeclaratorListContext) IsVariableDeclaratorListContext() {}

func NewVariableDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorListContext {
	var p = new(VariableDeclaratorListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableDeclaratorList

	return p
}

func (s *VariableDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorListContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorContext); ok {
			tst[i] = t.(IVariableDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorListContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *VariableDeclaratorListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *VariableDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableDeclaratorList(s)
	}
}

func (s *VariableDeclaratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableDeclaratorList(s)
	}
}

func (p *Java20Parser) VariableDeclaratorList() (localctx IVariableDeclaratorListContext) {
	localctx = NewVariableDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Java20ParserRULE_variableDeclaratorList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.VariableDeclarator()
	}
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1032)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1033)
				p.VariableDeclarator()
			}

		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaratorId() IVariableDeclaratorIdContext
	ASSIGN() antlr.TerminalNode
	VariableInitializer() IVariableInitializerContext

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableDeclarator
	return p
}

func InitEmptyVariableDeclaratorContext(p *VariableDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableDeclarator
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}

func (p *Java20Parser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Java20ParserRULE_variableDeclarator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.VariableDeclaratorId()
	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1040)
			p.Match(Java20ParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.VariableInitializer()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Dims() IDimsContext

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableDeclaratorId
	return p
}

func InitEmptyVariableDeclaratorIdContext(p *VariableDeclaratorIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableDeclaratorId
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclaratorIdContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableDeclaratorId(s)
	}
}

func (p *Java20Parser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Java20ParserRULE_variableDeclaratorId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.Identifier()
	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1045)
			p.Dims()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ArrayInitializer() IArrayInitializerContext

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableInitializer
	return p
}

func InitEmptyVariableInitializerContext(p *VariableInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableInitializer
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableInitializerContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (p *Java20Parser) VariableInitializer() (localctx IVariableInitializerContext) {
	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Java20ParserRULE_variableInitializer)
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD, Java20ParserBOOLEAN, Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserNEW, Java20ParserSHORT, Java20ParserSUPER, Java20ParserSWITCH, Java20ParserTHIS, Java20ParserVOID, Java20ParserIntegerLiteral, Java20ParserFloatingPointLiteral, Java20ParserBooleanLiteral, Java20ParserCharacterLiteral, Java20ParserStringLiteral, Java20ParserTextBlock, Java20ParserNullLiteral, Java20ParserLPAREN, Java20ParserAT, Java20ParserBANG, Java20ParserTILDE, Java20ParserINC, Java20ParserDEC, Java20ParserADD, Java20ParserSUB, Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.Expression()
		}

	case Java20ParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1049)
			p.ArrayInitializer()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannTypeContext is an interface to support dynamic dispatch.
type IUnannTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannPrimitiveType() IUnannPrimitiveTypeContext
	UnannReferenceType() IUnannReferenceTypeContext

	// IsUnannTypeContext differentiates from other interfaces.
	IsUnannTypeContext()
}

type UnannTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannTypeContext() *UnannTypeContext {
	var p = new(UnannTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannType
	return p
}

func InitEmptyUnannTypeContext(p *UnannTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannType
}

func (*UnannTypeContext) IsUnannTypeContext() {}

func NewUnannTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannTypeContext {
	var p = new(UnannTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannType

	return p
}

func (s *UnannTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannTypeContext) UnannPrimitiveType() IUnannPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannPrimitiveTypeContext)
}

func (s *UnannTypeContext) UnannReferenceType() IUnannReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannReferenceTypeContext)
}

func (s *UnannTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannType(s)
	}
}

func (s *UnannTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannType(s)
	}
}

func (p *Java20Parser) UnannType() (localctx IUnannTypeContext) {
	localctx = NewUnannTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Java20ParserRULE_unannType)
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1052)
			p.UnannPrimitiveType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1053)
			p.UnannReferenceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannPrimitiveTypeContext is an interface to support dynamic dispatch.
type IUnannPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericType() INumericTypeContext
	BOOLEAN() antlr.TerminalNode

	// IsUnannPrimitiveTypeContext differentiates from other interfaces.
	IsUnannPrimitiveTypeContext()
}

type UnannPrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannPrimitiveTypeContext() *UnannPrimitiveTypeContext {
	var p = new(UnannPrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannPrimitiveType
	return p
}

func InitEmptyUnannPrimitiveTypeContext(p *UnannPrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannPrimitiveType
}

func (*UnannPrimitiveTypeContext) IsUnannPrimitiveTypeContext() {}

func NewUnannPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannPrimitiveTypeContext {
	var p = new(UnannPrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannPrimitiveType

	return p
}

func (s *UnannPrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannPrimitiveTypeContext) NumericType() INumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *UnannPrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Java20ParserBOOLEAN, 0)
}

func (s *UnannPrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannPrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannPrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannPrimitiveType(s)
	}
}

func (s *UnannPrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannPrimitiveType(s)
	}
}

func (p *Java20Parser) UnannPrimitiveType() (localctx IUnannPrimitiveTypeContext) {
	localctx = NewUnannPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Java20ParserRULE_unannPrimitiveType)
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserSHORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1056)
			p.NumericType()
		}

	case Java20ParserBOOLEAN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1057)
			p.Match(Java20ParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannReferenceTypeContext is an interface to support dynamic dispatch.
type IUnannReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext
	UnannTypeVariable() IUnannTypeVariableContext
	UnannArrayType() IUnannArrayTypeContext

	// IsUnannReferenceTypeContext differentiates from other interfaces.
	IsUnannReferenceTypeContext()
}

type UnannReferenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannReferenceTypeContext() *UnannReferenceTypeContext {
	var p = new(UnannReferenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannReferenceType
	return p
}

func InitEmptyUnannReferenceTypeContext(p *UnannReferenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannReferenceType
}

func (*UnannReferenceTypeContext) IsUnannReferenceTypeContext() {}

func NewUnannReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannReferenceTypeContext {
	var p = new(UnannReferenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannReferenceType

	return p
}

func (s *UnannReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannReferenceTypeContext) UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannClassOrInterfaceTypeContext)
}

func (s *UnannReferenceTypeContext) UnannTypeVariable() IUnannTypeVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeVariableContext)
}

func (s *UnannReferenceTypeContext) UnannArrayType() IUnannArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannArrayTypeContext)
}

func (s *UnannReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannReferenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannReferenceType(s)
	}
}

func (s *UnannReferenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannReferenceType(s)
	}
}

func (p *Java20Parser) UnannReferenceType() (localctx IUnannReferenceTypeContext) {
	localctx = NewUnannReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Java20ParserRULE_unannReferenceType)
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1060)
			p.UnannClassOrInterfaceType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1061)
			p.UnannTypeVariable()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1062)
			p.UnannArrayType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	PackageName() IPackageNameContext
	DOT() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext
	UCOIT() IUCOITContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsUnannClassOrInterfaceTypeContext differentiates from other interfaces.
	IsUnannClassOrInterfaceTypeContext()
}

type UnannClassOrInterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannClassOrInterfaceTypeContext() *UnannClassOrInterfaceTypeContext {
	var p = new(UnannClassOrInterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannClassOrInterfaceType
	return p
}

func InitEmptyUnannClassOrInterfaceTypeContext(p *UnannClassOrInterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannClassOrInterfaceType
}

func (*UnannClassOrInterfaceTypeContext) IsUnannClassOrInterfaceTypeContext() {}

func NewUnannClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannClassOrInterfaceTypeContext {
	var p = new(UnannClassOrInterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannClassOrInterfaceType

	return p
}

func (s *UnannClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannClassOrInterfaceTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *UnannClassOrInterfaceTypeContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *UnannClassOrInterfaceTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *UnannClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UnannClassOrInterfaceTypeContext) UCOIT() IUCOITContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUCOITContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUCOITContext)
}

func (s *UnannClassOrInterfaceTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *UnannClassOrInterfaceTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnannClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannClassOrInterfaceType(s)
	}
}

func (s *UnannClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannClassOrInterfaceType(s)
	}
}

func (p *Java20Parser) UnannClassOrInterfaceType() (localctx IUnannClassOrInterfaceTypeContext) {
	localctx = NewUnannClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Java20ParserRULE_unannClassOrInterfaceType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1065)
			p.PackageName()
		}
		{
			p.SetState(1066)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(1067)
				p.Annotation()
			}

			p.SetState(1072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1075)
		p.TypeIdentifier()
	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1076)
			p.TypeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1079)
			p.UCOIT()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUCOITContext is an interface to support dynamic dispatch.
type IUCOITContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	TypeArguments() ITypeArgumentsContext
	UCOIT() IUCOITContext

	// IsUCOITContext differentiates from other interfaces.
	IsUCOITContext()
}

type UCOITContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUCOITContext() *UCOITContext {
	var p = new(UCOITContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_uCOIT
	return p
}

func InitEmptyUCOITContext(p *UCOITContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_uCOIT
}

func (*UCOITContext) IsUCOITContext() {}

func NewUCOITContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UCOITContext {
	var p = new(UCOITContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_uCOIT

	return p
}

func (s *UCOITContext) GetParser() antlr.Parser { return s.parser }

func (s *UCOITContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *UCOITContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *UCOITContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *UCOITContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UCOITContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UCOITContext) UCOIT() IUCOITContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUCOITContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUCOITContext)
}

func (s *UCOITContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UCOITContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UCOITContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUCOIT(s)
	}
}

func (s *UCOITContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUCOIT(s)
	}
}

func (p *Java20Parser) UCOIT() (localctx IUCOITContext) {
	localctx = NewUCOITContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Java20ParserRULE_uCOIT)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1082)
		p.Match(Java20ParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(1083)
			p.Annotation()
		}

		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1089)
		p.TypeIdentifier()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1090)
			p.TypeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1093)
			p.UCOIT()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannClassTypeContext is an interface to support dynamic dispatch.
type IUnannClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	TypeArguments() ITypeArgumentsContext
	DOT() antlr.TerminalNode
	PackageName() IPackageNameContext
	UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsUnannClassTypeContext differentiates from other interfaces.
	IsUnannClassTypeContext()
}

type UnannClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannClassTypeContext() *UnannClassTypeContext {
	var p = new(UnannClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannClassType
	return p
}

func InitEmptyUnannClassTypeContext(p *UnannClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannClassType
}

func (*UnannClassTypeContext) IsUnannClassTypeContext() {}

func NewUnannClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannClassTypeContext {
	var p = new(UnannClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannClassType

	return p
}

func (s *UnannClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannClassTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *UnannClassTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UnannClassTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *UnannClassTypeContext) PackageName() IPackageNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageNameContext)
}

func (s *UnannClassTypeContext) UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannClassOrInterfaceTypeContext)
}

func (s *UnannClassTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *UnannClassTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnannClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannClassType(s)
	}
}

func (s *UnannClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannClassType(s)
	}
}

func (p *Java20Parser) UnannClassType() (localctx IUnannClassTypeContext) {
	localctx = NewUnannClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Java20ParserRULE_unannClassType)
	var _la int

	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1096)
			p.TypeIdentifier()
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(1097)
				p.TypeArguments()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1100)
				p.PackageName()
			}

		case 2:
			{
				p.SetState(1101)
				p.UnannClassOrInterfaceType()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1104)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(1105)
				p.Annotation()
			}

			p.SetState(1110)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1111)
			p.TypeIdentifier()
		}
		p.SetState(1113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(1112)
				p.TypeArguments()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannInterfaceTypeContext is an interface to support dynamic dispatch.
type IUnannInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannClassType() IUnannClassTypeContext

	// IsUnannInterfaceTypeContext differentiates from other interfaces.
	IsUnannInterfaceTypeContext()
}

type UnannInterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannInterfaceTypeContext() *UnannInterfaceTypeContext {
	var p = new(UnannInterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannInterfaceType
	return p
}

func InitEmptyUnannInterfaceTypeContext(p *UnannInterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannInterfaceType
}

func (*UnannInterfaceTypeContext) IsUnannInterfaceTypeContext() {}

func NewUnannInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannInterfaceTypeContext {
	var p = new(UnannInterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannInterfaceType

	return p
}

func (s *UnannInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannInterfaceTypeContext) UnannClassType() IUnannClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannClassTypeContext)
}

func (s *UnannInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannInterfaceType(s)
	}
}

func (s *UnannInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannInterfaceType(s)
	}
}

func (p *Java20Parser) UnannInterfaceType() (localctx IUnannInterfaceTypeContext) {
	localctx = NewUnannInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Java20ParserRULE_unannInterfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1117)
		p.UnannClassType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannTypeVariableContext is an interface to support dynamic dispatch.
type IUnannTypeVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsUnannTypeVariableContext differentiates from other interfaces.
	IsUnannTypeVariableContext()
}

type UnannTypeVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannTypeVariableContext() *UnannTypeVariableContext {
	var p = new(UnannTypeVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannTypeVariable
	return p
}

func InitEmptyUnannTypeVariableContext(p *UnannTypeVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannTypeVariable
}

func (*UnannTypeVariableContext) IsUnannTypeVariableContext() {}

func NewUnannTypeVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannTypeVariableContext {
	var p = new(UnannTypeVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannTypeVariable

	return p
}

func (s *UnannTypeVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannTypeVariableContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *UnannTypeVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannTypeVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannTypeVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannTypeVariable(s)
	}
}

func (s *UnannTypeVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannTypeVariable(s)
	}
}

func (p *Java20Parser) UnannTypeVariable() (localctx IUnannTypeVariableContext) {
	localctx = NewUnannTypeVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Java20ParserRULE_unannTypeVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnannArrayTypeContext is an interface to support dynamic dispatch.
type IUnannArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dims() IDimsContext
	UnannPrimitiveType() IUnannPrimitiveTypeContext
	UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext
	UnannTypeVariable() IUnannTypeVariableContext

	// IsUnannArrayTypeContext differentiates from other interfaces.
	IsUnannArrayTypeContext()
}

type UnannArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnannArrayTypeContext() *UnannArrayTypeContext {
	var p = new(UnannArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannArrayType
	return p
}

func InitEmptyUnannArrayTypeContext(p *UnannArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unannArrayType
}

func (*UnannArrayTypeContext) IsUnannArrayTypeContext() {}

func NewUnannArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnannArrayTypeContext {
	var p = new(UnannArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unannArrayType

	return p
}

func (s *UnannArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnannArrayTypeContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *UnannArrayTypeContext) UnannPrimitiveType() IUnannPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannPrimitiveTypeContext)
}

func (s *UnannArrayTypeContext) UnannClassOrInterfaceType() IUnannClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannClassOrInterfaceTypeContext)
}

func (s *UnannArrayTypeContext) UnannTypeVariable() IUnannTypeVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeVariableContext)
}

func (s *UnannArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnannArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnannArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnannArrayType(s)
	}
}

func (s *UnannArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnannArrayType(s)
	}
}

func (p *Java20Parser) UnannArrayType() (localctx IUnannArrayTypeContext) {
	localctx = NewUnannArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Java20ParserRULE_unannArrayType)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1121)
			p.UnannPrimitiveType()
		}

	case 2:
		{
			p.SetState(1122)
			p.UnannClassOrInterfaceType()
		}

	case 3:
		{
			p.SetState(1123)
			p.UnannTypeVariable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1126)
		p.Dims()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodHeader() IMethodHeaderContext
	MethodBody() IMethodBodyContext
	AllMethodModifier() []IMethodModifierContext
	MethodModifier(i int) IMethodModifierContext

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodDeclaration
	return p
}

func InitEmptyMethodDeclarationContext(p *MethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodDeclaration
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) MethodHeader() IMethodHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodHeaderContext)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) AllMethodModifier() []IMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodModifierContext); ok {
			tst[i] = t.(IMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *MethodDeclarationContext) MethodModifier(i int) IMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodModifierContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (p *Java20Parser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Java20ParserRULE_methodDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&692569214556569600) != 0) || _la == Java20ParserAT {
		{
			p.SetState(1128)
			p.MethodModifier()
		}

		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1134)
		p.MethodHeader()
	}
	{
		p.SetState(1135)
		p.MethodBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodModifierContext is an interface to support dynamic dispatch.
type IMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	SYNCHRONIZED() antlr.TerminalNode
	NATIVE() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode

	// IsMethodModifierContext differentiates from other interfaces.
	IsMethodModifierContext()
}

type MethodModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodModifierContext() *MethodModifierContext {
	var p = new(MethodModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodModifier
	return p
}

func InitEmptyMethodModifierContext(p *MethodModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodModifier
}

func (*MethodModifierContext) IsMethodModifierContext() {}

func NewMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodModifierContext {
	var p = new(MethodModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodModifier

	return p
}

func (s *MethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *MethodModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *MethodModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROTECTED, 0)
}

func (s *MethodModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java20ParserPRIVATE, 0)
}

func (s *MethodModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java20ParserABSTRACT, 0)
}

func (s *MethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *MethodModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java20ParserFINAL, 0)
}

func (s *MethodModifierContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(Java20ParserSYNCHRONIZED, 0)
}

func (s *MethodModifierContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(Java20ParserNATIVE, 0)
}

func (s *MethodModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTRICTFP, 0)
}

func (s *MethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodModifier(s)
	}
}

func (s *MethodModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodModifier(s)
	}
}

func (p *Java20Parser) MethodModifier() (localctx IMethodModifierContext) {
	localctx = NewMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Java20ParserRULE_methodModifier)
	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1137)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1138)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1139)
			p.Match(Java20ParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1140)
			p.Match(Java20ParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserABSTRACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1141)
			p.Match(Java20ParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1142)
			p.Match(Java20ParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserFINAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1143)
			p.Match(Java20ParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSYNCHRONIZED:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1144)
			p.Match(Java20ParserSYNCHRONIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserNATIVE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1145)
			p.Match(Java20ParserNATIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1146)
			p.Match(Java20ParserSTRICTFP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodHeaderContext is an interface to support dynamic dispatch.
type IMethodHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Result() IResultContext
	MethodDeclarator() IMethodDeclaratorContext
	TypeParameters() ITypeParametersContext
	ThrowsT() IThrowsTContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsMethodHeaderContext differentiates from other interfaces.
	IsMethodHeaderContext()
}

type MethodHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodHeaderContext() *MethodHeaderContext {
	var p = new(MethodHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodHeader
	return p
}

func InitEmptyMethodHeaderContext(p *MethodHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodHeader
}

func (*MethodHeaderContext) IsMethodHeaderContext() {}

func NewMethodHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodHeaderContext {
	var p = new(MethodHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodHeader

	return p
}

func (s *MethodHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodHeaderContext) Result() IResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *MethodHeaderContext) MethodDeclarator() IMethodDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclaratorContext)
}

func (s *MethodHeaderContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *MethodHeaderContext) ThrowsT() IThrowsTContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowsTContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowsTContext)
}

func (s *MethodHeaderContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *MethodHeaderContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *MethodHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodHeader(s)
	}
}

func (s *MethodHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodHeader(s)
	}
}

func (p *Java20Parser) MethodHeader() (localctx IMethodHeaderContext) {
	localctx = NewMethodHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Java20ParserRULE_methodHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLT {
		{
			p.SetState(1149)
			p.TypeParameters()
		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(1150)
				p.Annotation()
			}

			p.SetState(1155)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1158)
		p.Result()
	}
	{
		p.SetState(1159)
		p.MethodDeclarator()
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserTHROWS {
		{
			p.SetState(1160)
			p.ThrowsT()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultContext is an interface to support dynamic dispatch.
type IResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	VOID() antlr.TerminalNode

	// IsResultContext differentiates from other interfaces.
	IsResultContext()
}

type ResultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultContext() *ResultContext {
	var p = new(ResultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_result
	return p
}

func InitEmptyResultContext(p *ResultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_result
}

func (*ResultContext) IsResultContext() {}

func NewResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultContext {
	var p = new(ResultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_result

	return p
}

func (s *ResultContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *ResultContext) VOID() antlr.TerminalNode {
	return s.GetToken(Java20ParserVOID, 0)
}

func (s *ResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterResult(s)
	}
}

func (s *ResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitResult(s)
	}
}

func (p *Java20Parser) Result() (localctx IResultContext) {
	localctx = NewResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Java20ParserRULE_result)
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD, Java20ParserBOOLEAN, Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserSHORT, Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1163)
			p.UnannType()
		}

	case Java20ParserVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1164)
			p.Match(Java20ParserVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclaratorContext is an interface to support dynamic dispatch.
type IMethodDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReceiverParameter() IReceiverParameterContext
	COMMA() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	Dims() IDimsContext

	// IsMethodDeclaratorContext differentiates from other interfaces.
	IsMethodDeclaratorContext()
}

type MethodDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclaratorContext() *MethodDeclaratorContext {
	var p = new(MethodDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodDeclarator
	return p
}

func InitEmptyMethodDeclaratorContext(p *MethodDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodDeclarator
}

func (*MethodDeclaratorContext) IsMethodDeclaratorContext() {}

func NewMethodDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclaratorContext {
	var p = new(MethodDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodDeclarator

	return p
}

func (s *MethodDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclaratorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodDeclaratorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *MethodDeclaratorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *MethodDeclaratorContext) ReceiverParameter() IReceiverParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *MethodDeclaratorContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, 0)
}

func (s *MethodDeclaratorContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *MethodDeclaratorContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *MethodDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodDeclarator(s)
	}
}

func (s *MethodDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodDeclarator(s)
	}
}

func (p *Java20Parser) MethodDeclarator() (localctx IMethodDeclaratorContext) {
	localctx = NewMethodDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Java20ParserRULE_methodDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Identifier()
	}
	{
		p.SetState(1168)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1172)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1169)
			p.ReceiverParameter()
		}
		{
			p.SetState(1170)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18102533424938990) != 0) || _la == Java20ParserAT || _la == Java20ParserIdentifier {
		{
			p.SetState(1174)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1177)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLBRACK || _la == Java20ParserAT {
		{
			p.SetState(1178)
			p.Dims()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverParameterContext is an interface to support dynamic dispatch.
type IReceiverParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	THIS() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode

	// IsReceiverParameterContext differentiates from other interfaces.
	IsReceiverParameterContext()
}

type ReceiverParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverParameterContext() *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_receiverParameter
	return p
}

func InitEmptyReceiverParameterContext(p *ReceiverParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_receiverParameter
}

func (*ReceiverParameterContext) IsReceiverParameterContext() {}

func NewReceiverParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_receiverParameter

	return p
}

func (s *ReceiverParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverParameterContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *ReceiverParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java20ParserTHIS, 0)
}

func (s *ReceiverParameterContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ReceiverParameterContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ReceiverParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiverParameterContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ReceiverParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterReceiverParameter(s)
	}
}

func (s *ReceiverParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitReceiverParameter(s)
	}
}

func (p *Java20Parser) ReceiverParameter() (localctx IReceiverParameterContext) {
	localctx = NewReceiverParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Java20ParserRULE_receiverParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(1181)
			p.Annotation()
		}

		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1187)
		p.UnannType()
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262126) != 0) || _la == Java20ParserIdentifier {
		{
			p.SetState(1188)
			p.Identifier()
		}
		{
			p.SetState(1189)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1193)
		p.Match(Java20ParserTHIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameter() []IFormalParameterContext
	FormalParameter(i int) IFormalParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *Java20Parser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Java20ParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.FormalParameter()
	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(1196)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1197)
			p.FormalParameter()
		}

		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	VariableDeclaratorId() IVariableDeclaratorIdContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	VariableArityParameter() IVariableArityParameterContext

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_formalParameter
	return p
}

func InitEmptyFormalParameterContext(p *FormalParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_formalParameter
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *FormalParameterContext) VariableArityParameter() IVariableArityParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableArityParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableArityParameterContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (p *Java20Parser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Java20ParserRULE_formalParameter)
	var _la int

	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserFINAL || _la == Java20ParserAT {
			{
				p.SetState(1203)
				p.VariableModifier()
			}

			p.SetState(1208)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1209)
			p.UnannType()
		}
		{
			p.SetState(1210)
			p.VariableDeclaratorId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1212)
			p.VariableArityParameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableArityParameterContext is an interface to support dynamic dispatch.
type IVariableArityParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	ELLIPSIS() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsVariableArityParameterContext differentiates from other interfaces.
	IsVariableArityParameterContext()
}

type VariableArityParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableArityParameterContext() *VariableArityParameterContext {
	var p = new(VariableArityParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableArityParameter
	return p
}

func InitEmptyVariableArityParameterContext(p *VariableArityParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableArityParameter
}

func (*VariableArityParameterContext) IsVariableArityParameterContext() {}

func NewVariableArityParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableArityParameterContext {
	var p = new(VariableArityParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableArityParameter

	return p
}

func (s *VariableArityParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableArityParameterContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *VariableArityParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Java20ParserELLIPSIS, 0)
}

func (s *VariableArityParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableArityParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *VariableArityParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *VariableArityParameterContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *VariableArityParameterContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableArityParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableArityParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableArityParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableArityParameter(s)
	}
}

func (s *VariableArityParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableArityParameter(s)
	}
}

func (p *Java20Parser) VariableArityParameter() (localctx IVariableArityParameterContext) {
	localctx = NewVariableArityParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Java20ParserRULE_variableArityParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserFINAL || _la == Java20ParserAT {
		{
			p.SetState(1215)
			p.VariableModifier()
		}

		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1221)
		p.UnannType()
	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(1222)
			p.Annotation()
		}

		p.SetState(1227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1228)
		p.Match(Java20ParserELLIPSIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1229)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	FINAL() antlr.TerminalNode

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableModifier
	return p
}

func InitEmptyVariableModifierContext(p *VariableModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableModifier
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java20ParserFINAL, 0)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableModifier(s)
	}
}

func (s *VariableModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableModifier(s)
	}
}

func (p *Java20Parser) VariableModifier() (localctx IVariableModifierContext) {
	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Java20ParserRULE_variableModifier)
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1231)
			p.Annotation()
		}

	case Java20ParserFINAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1232)
			p.Match(Java20ParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowsTContext is an interface to support dynamic dispatch.
type IThrowsTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THROWS() antlr.TerminalNode
	ExceptionTypeList() IExceptionTypeListContext

	// IsThrowsTContext differentiates from other interfaces.
	IsThrowsTContext()
}

type ThrowsTContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowsTContext() *ThrowsTContext {
	var p = new(ThrowsTContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_throwsT
	return p
}

func InitEmptyThrowsTContext(p *ThrowsTContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_throwsT
}

func (*ThrowsTContext) IsThrowsTContext() {}

func NewThrowsTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowsTContext {
	var p = new(ThrowsTContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_throwsT

	return p
}

func (s *ThrowsTContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowsTContext) THROWS() antlr.TerminalNode {
	return s.GetToken(Java20ParserTHROWS, 0)
}

func (s *ThrowsTContext) ExceptionTypeList() IExceptionTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionTypeListContext)
}

func (s *ThrowsTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowsTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowsTContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterThrowsT(s)
	}
}

func (s *ThrowsTContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitThrowsT(s)
	}
}

func (p *Java20Parser) ThrowsT() (localctx IThrowsTContext) {
	localctx = NewThrowsTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Java20ParserRULE_throwsT)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(Java20ParserTHROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1236)
		p.ExceptionTypeList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionTypeListContext is an interface to support dynamic dispatch.
type IExceptionTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExceptionType() []IExceptionTypeContext
	ExceptionType(i int) IExceptionTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExceptionTypeListContext differentiates from other interfaces.
	IsExceptionTypeListContext()
}

type ExceptionTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionTypeListContext() *ExceptionTypeListContext {
	var p = new(ExceptionTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_exceptionTypeList
	return p
}

func InitEmptyExceptionTypeListContext(p *ExceptionTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_exceptionTypeList
}

func (*ExceptionTypeListContext) IsExceptionTypeListContext() {}

func NewExceptionTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionTypeListContext {
	var p = new(ExceptionTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_exceptionTypeList

	return p
}

func (s *ExceptionTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionTypeListContext) AllExceptionType() []IExceptionTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExceptionTypeContext); ok {
			len++
		}
	}

	tst := make([]IExceptionTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExceptionTypeContext); ok {
			tst[i] = t.(IExceptionTypeContext)
			i++
		}
	}

	return tst
}

func (s *ExceptionTypeListContext) ExceptionType(i int) IExceptionTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionTypeContext)
}

func (s *ExceptionTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *ExceptionTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *ExceptionTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterExceptionTypeList(s)
	}
}

func (s *ExceptionTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitExceptionTypeList(s)
	}
}

func (p *Java20Parser) ExceptionTypeList() (localctx IExceptionTypeListContext) {
	localctx = NewExceptionTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Java20ParserRULE_exceptionTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1238)
		p.ExceptionType()
	}
	p.SetState(1243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(1239)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1240)
			p.ExceptionType()
		}

		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionTypeContext is an interface to support dynamic dispatch.
type IExceptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassType() IClassTypeContext
	TypeVariable() ITypeVariableContext

	// IsExceptionTypeContext differentiates from other interfaces.
	IsExceptionTypeContext()
}

type ExceptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionTypeContext() *ExceptionTypeContext {
	var p = new(ExceptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_exceptionType
	return p
}

func InitEmptyExceptionTypeContext(p *ExceptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_exceptionType
}

func (*ExceptionTypeContext) IsExceptionTypeContext() {}

func NewExceptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionTypeContext {
	var p = new(ExceptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_exceptionType

	return p
}

func (s *ExceptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *ExceptionTypeContext) TypeVariable() ITypeVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeVariableContext)
}

func (s *ExceptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterExceptionType(s)
	}
}

func (s *ExceptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitExceptionType(s)
	}
}

func (p *Java20Parser) ExceptionType() (localctx IExceptionTypeContext) {
	localctx = NewExceptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Java20ParserRULE_exceptionType)
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1246)
			p.ClassType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1247)
			p.TypeVariable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	SEMI() antlr.TerminalNode

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodBody
	return p
}

func InitEmptyMethodBodyContext(p *MethodBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodBody
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *Java20Parser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Java20ParserRULE_methodBody)
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1250)
			p.Block()
		}

	case Java20ParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1251)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstanceInitializerContext is an interface to support dynamic dispatch.
type IInstanceInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext

	// IsInstanceInitializerContext differentiates from other interfaces.
	IsInstanceInitializerContext()
}

type InstanceInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceInitializerContext() *InstanceInitializerContext {
	var p = new(InstanceInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_instanceInitializer
	return p
}

func InitEmptyInstanceInitializerContext(p *InstanceInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_instanceInitializer
}

func (*InstanceInitializerContext) IsInstanceInitializerContext() {}

func NewInstanceInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceInitializerContext {
	var p = new(InstanceInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_instanceInitializer

	return p
}

func (s *InstanceInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceInitializerContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *InstanceInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstanceInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInstanceInitializer(s)
	}
}

func (s *InstanceInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInstanceInitializer(s)
	}
}

func (p *Java20Parser) InstanceInitializer() (localctx IInstanceInitializerContext) {
	localctx = NewInstanceInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Java20ParserRULE_instanceInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1254)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStaticInitializerContext is an interface to support dynamic dispatch.
type IStaticInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STATIC() antlr.TerminalNode
	Block() IBlockContext

	// IsStaticInitializerContext differentiates from other interfaces.
	IsStaticInitializerContext()
}

type StaticInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticInitializerContext() *StaticInitializerContext {
	var p = new(StaticInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_staticInitializer
	return p
}

func InitEmptyStaticInitializerContext(p *StaticInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_staticInitializer
}

func (*StaticInitializerContext) IsStaticInitializerContext() {}

func NewStaticInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticInitializerContext {
	var p = new(StaticInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_staticInitializer

	return p
}

func (s *StaticInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticInitializerContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *StaticInitializerContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StaticInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStaticInitializer(s)
	}
}

func (s *StaticInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStaticInitializer(s)
	}
}

func (p *Java20Parser) StaticInitializer() (localctx IStaticInitializerContext) {
	localctx = NewStaticInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Java20ParserRULE_staticInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1256)
		p.Match(Java20ParserSTATIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1257)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorDeclarator() IConstructorDeclaratorContext
	ConstructorBody() IConstructorBodyContext
	AllConstructorModifier() []IConstructorModifierContext
	ConstructorModifier(i int) IConstructorModifierContext
	ThrowsT() IThrowsTContext

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorDeclaration
	return p
}

func InitEmptyConstructorDeclarationContext(p *ConstructorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorDeclaration
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) ConstructorDeclarator() IConstructorDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclaratorContext)
}

func (s *ConstructorDeclarationContext) ConstructorBody() IConstructorBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorBodyContext)
}

func (s *ConstructorDeclarationContext) AllConstructorModifier() []IConstructorModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstructorModifierContext); ok {
			len++
		}
	}

	tst := make([]IConstructorModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstructorModifierContext); ok {
			tst[i] = t.(IConstructorModifierContext)
			i++
		}
	}

	return tst
}

func (s *ConstructorDeclarationContext) ConstructorModifier(i int) IConstructorModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorModifierContext)
}

func (s *ConstructorDeclarationContext) ThrowsT() IThrowsTContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowsTContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowsTContext)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}

func (p *Java20Parser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Java20ParserRULE_constructorDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-50)) & ^0x3f) == 0 && ((int64(1)<<(_la-50))&68719476743) != 0 {
		{
			p.SetState(1259)
			p.ConstructorModifier()
		}

		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1265)
		p.ConstructorDeclarator()
	}
	p.SetState(1267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserTHROWS {
		{
			p.SetState(1266)
			p.ThrowsT()
		}

	}
	{
		p.SetState(1269)
		p.ConstructorBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorModifierContext is an interface to support dynamic dispatch.
type IConstructorModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode

	// IsConstructorModifierContext differentiates from other interfaces.
	IsConstructorModifierContext()
}

type ConstructorModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorModifierContext() *ConstructorModifierContext {
	var p = new(ConstructorModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorModifier
	return p
}

func InitEmptyConstructorModifierContext(p *ConstructorModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorModifier
}

func (*ConstructorModifierContext) IsConstructorModifierContext() {}

func NewConstructorModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorModifierContext {
	var p = new(ConstructorModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_constructorModifier

	return p
}

func (s *ConstructorModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ConstructorModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *ConstructorModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROTECTED, 0)
}

func (s *ConstructorModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java20ParserPRIVATE, 0)
}

func (s *ConstructorModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConstructorModifier(s)
	}
}

func (s *ConstructorModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConstructorModifier(s)
	}
}

func (p *Java20Parser) ConstructorModifier() (localctx IConstructorModifierContext) {
	localctx = NewConstructorModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Java20ParserRULE_constructorModifier)
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1271)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1272)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1273)
			p.Match(Java20ParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1274)
			p.Match(Java20ParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorDeclaratorContext is an interface to support dynamic dispatch.
type IConstructorDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleTypeName() ISimpleTypeNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	ReceiverParameter() IReceiverParameterContext
	COMMA() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsConstructorDeclaratorContext differentiates from other interfaces.
	IsConstructorDeclaratorContext()
}

type ConstructorDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclaratorContext() *ConstructorDeclaratorContext {
	var p = new(ConstructorDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorDeclarator
	return p
}

func InitEmptyConstructorDeclaratorContext(p *ConstructorDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorDeclarator
}

func (*ConstructorDeclaratorContext) IsConstructorDeclaratorContext() {}

func NewConstructorDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclaratorContext {
	var p = new(ConstructorDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_constructorDeclarator

	return p
}

func (s *ConstructorDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclaratorContext) SimpleTypeName() ISimpleTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeNameContext)
}

func (s *ConstructorDeclaratorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *ConstructorDeclaratorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *ConstructorDeclaratorContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ConstructorDeclaratorContext) ReceiverParameter() IReceiverParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *ConstructorDeclaratorContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, 0)
}

func (s *ConstructorDeclaratorContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ConstructorDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConstructorDeclarator(s)
	}
}

func (s *ConstructorDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConstructorDeclarator(s)
	}
}

func (p *Java20Parser) ConstructorDeclarator() (localctx IConstructorDeclaratorContext) {
	localctx = NewConstructorDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Java20ParserRULE_constructorDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLT {
		{
			p.SetState(1277)
			p.TypeParameters()
		}

	}
	{
		p.SetState(1280)
		p.SimpleTypeName()
	}
	{
		p.SetState(1281)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1282)
			p.ReceiverParameter()
		}
		{
			p.SetState(1283)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18102533424938990) != 0) || _la == Java20ParserAT || _la == Java20ParserIdentifier {
		{
			p.SetState(1287)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1290)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeNameContext is an interface to support dynamic dispatch.
type ISimpleTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsSimpleTypeNameContext differentiates from other interfaces.
	IsSimpleTypeNameContext()
}

type SimpleTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeNameContext() *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_simpleTypeName
	return p
}

func InitEmptySimpleTypeNameContext(p *SimpleTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_simpleTypeName
}

func (*SimpleTypeNameContext) IsSimpleTypeNameContext() {}

func NewSimpleTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeNameContext {
	var p = new(SimpleTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_simpleTypeName

	return p
}

func (s *SimpleTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeNameContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *SimpleTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSimpleTypeName(s)
	}
}

func (s *SimpleTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSimpleTypeName(s)
	}
}

func (p *Java20Parser) SimpleTypeName() (localctx ISimpleTypeNameContext) {
	localctx = NewSimpleTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Java20ParserRULE_simpleTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorBodyContext is an interface to support dynamic dispatch.
type IConstructorBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ExplicitConstructorInvocation() IExplicitConstructorInvocationContext
	BlockStatements() IBlockStatementsContext

	// IsConstructorBodyContext differentiates from other interfaces.
	IsConstructorBodyContext()
}

type ConstructorBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorBodyContext() *ConstructorBodyContext {
	var p = new(ConstructorBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorBody
	return p
}

func InitEmptyConstructorBodyContext(p *ConstructorBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constructorBody
}

func (*ConstructorBodyContext) IsConstructorBodyContext() {}

func NewConstructorBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorBodyContext {
	var p = new(ConstructorBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_constructorBody

	return p
}

func (s *ConstructorBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *ConstructorBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *ConstructorBodyContext) ExplicitConstructorInvocation() IExplicitConstructorInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitConstructorInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitConstructorInvocationContext)
}

func (s *ConstructorBodyContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *ConstructorBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConstructorBody(s)
	}
}

func (s *ConstructorBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConstructorBody(s)
	}
}

func (p *Java20Parser) ConstructorBody() (localctx IConstructorBodyContext) {
	localctx = NewConstructorBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Java20ParserRULE_constructorBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1294)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1296)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1295)
			p.ExplicitConstructorInvocation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4610965747420626926) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&576461576941625323) != 0) {
		{
			p.SetState(1298)
			p.BlockStatements()
		}

	}
	{
		p.SetState(1301)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitConstructorInvocationContext is an interface to support dynamic dispatch.
type IExplicitConstructorInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext
	ArgumentList() IArgumentListContext
	DOT() antlr.TerminalNode
	ExpressionName() IExpressionNameContext
	Primary() IPrimaryContext

	// IsExplicitConstructorInvocationContext differentiates from other interfaces.
	IsExplicitConstructorInvocationContext()
}

type ExplicitConstructorInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitConstructorInvocationContext() *ExplicitConstructorInvocationContext {
	var p = new(ExplicitConstructorInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_explicitConstructorInvocation
	return p
}

func InitEmptyExplicitConstructorInvocationContext(p *ExplicitConstructorInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_explicitConstructorInvocation
}

func (*ExplicitConstructorInvocationContext) IsExplicitConstructorInvocationContext() {}

func NewExplicitConstructorInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitConstructorInvocationContext {
	var p = new(ExplicitConstructorInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_explicitConstructorInvocation

	return p
}

func (s *ExplicitConstructorInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitConstructorInvocationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *ExplicitConstructorInvocationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *ExplicitConstructorInvocationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ExplicitConstructorInvocationContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java20ParserTHIS, 0)
}

func (s *ExplicitConstructorInvocationContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUPER, 0)
}

func (s *ExplicitConstructorInvocationContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ExplicitConstructorInvocationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ExplicitConstructorInvocationContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ExplicitConstructorInvocationContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ExplicitConstructorInvocationContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExplicitConstructorInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitConstructorInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitConstructorInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterExplicitConstructorInvocation(s)
	}
}

func (s *ExplicitConstructorInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitExplicitConstructorInvocation(s)
	}
}

func (p *Java20Parser) ExplicitConstructorInvocation() (localctx IExplicitConstructorInvocationContext) {
	localctx = NewExplicitConstructorInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Java20ParserRULE_explicitConstructorInvocation)
	var _la int

	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(1303)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1306)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Java20ParserSUPER || _la == Java20ParserTHIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1307)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(1308)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1311)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1313)
				p.ExpressionName()
			}

		case 2:
			{
				p.SetState(1314)
				p.Primary()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1317)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(1318)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1321)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1322)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(1323)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1326)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1327)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	EnumBody() IEnumBodyContext
	AllClassModifier() []IClassModifierContext
	ClassModifier(i int) IClassModifierContext
	ClassImplements() IClassImplementsContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(Java20ParserENUM, 0)
}

func (s *EnumDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *EnumDeclarationContext) EnumBody() IEnumBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyContext)
}

func (s *EnumDeclarationContext) AllClassModifier() []IClassModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassModifierContext); ok {
			tst[i] = t.(IClassModifierContext)
			i++
		}
	}

	return tst
}

func (s *EnumDeclarationContext) ClassModifier(i int) IClassModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *EnumDeclarationContext) ClassImplements() IClassImplementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (p *Java20Parser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Java20ParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&115967724764792840) != 0) || _la == Java20ParserAT {
		{
			p.SetState(1331)
			p.ClassModifier()
		}

		p.SetState(1336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1337)
		p.Match(Java20ParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1338)
		p.TypeIdentifier()
	}
	p.SetState(1340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserIMPLEMENTS {
		{
			p.SetState(1339)
			p.ClassImplements()
		}

	}
	{
		p.SetState(1342)
		p.EnumBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodyContext is an interface to support dynamic dispatch.
type IEnumBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EnumConstantList() IEnumConstantListContext
	COMMA() antlr.TerminalNode
	EnumBodyDeclarations() IEnumBodyDeclarationsContext

	// IsEnumBodyContext differentiates from other interfaces.
	IsEnumBodyContext()
}

type EnumBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyContext() *EnumBodyContext {
	var p = new(EnumBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumBody
	return p
}

func InitEmptyEnumBodyContext(p *EnumBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumBody
}

func (*EnumBodyContext) IsEnumBodyContext() {}

func NewEnumBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyContext {
	var p = new(EnumBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enumBody

	return p
}

func (s *EnumBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *EnumBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *EnumBodyContext) EnumConstantList() IEnumConstantListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantListContext)
}

func (s *EnumBodyContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, 0)
}

func (s *EnumBodyContext) EnumBodyDeclarations() IEnumBodyDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyDeclarationsContext)
}

func (s *EnumBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnumBody(s)
	}
}

func (s *EnumBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnumBody(s)
	}
}

func (p *Java20Parser) EnumBody() (localctx IEnumBodyContext) {
	localctx = NewEnumBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Java20ParserRULE_enumBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1344)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262126) != 0) || _la == Java20ParserAT || _la == Java20ParserIdentifier {
		{
			p.SetState(1345)
			p.EnumConstantList()
		}

	}
	p.SetState(1349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserCOMMA {
		{
			p.SetState(1348)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserSEMI {
		{
			p.SetState(1351)
			p.EnumBodyDeclarations()
		}

	}
	{
		p.SetState(1354)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantListContext is an interface to support dynamic dispatch.
type IEnumConstantListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumConstant() []IEnumConstantContext
	EnumConstant(i int) IEnumConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumConstantListContext differentiates from other interfaces.
	IsEnumConstantListContext()
}

type EnumConstantListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantListContext() *EnumConstantListContext {
	var p = new(EnumConstantListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumConstantList
	return p
}

func InitEmptyEnumConstantListContext(p *EnumConstantListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumConstantList
}

func (*EnumConstantListContext) IsEnumConstantListContext() {}

func NewEnumConstantListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantListContext {
	var p = new(EnumConstantListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enumConstantList

	return p
}

func (s *EnumConstantListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantListContext) AllEnumConstant() []IEnumConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstantContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstantContext); ok {
			tst[i] = t.(IEnumConstantContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantListContext) EnumConstant(i int) IEnumConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *EnumConstantListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *EnumConstantListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnumConstantList(s)
	}
}

func (s *EnumConstantListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnumConstantList(s)
	}
}

func (p *Java20Parser) EnumConstantList() (localctx IEnumConstantListContext) {
	localctx = NewEnumConstantListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Java20ParserRULE_enumConstantList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.EnumConstant()
	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1357)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1358)
				p.EnumConstant()
			}

		}
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllEnumConstantModifier() []IEnumConstantModifierContext
	EnumConstantModifier(i int) IEnumConstantModifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ClassBody() IClassBodyContext
	ArgumentList() IArgumentListContext

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumConstant
	return p
}

func InitEmptyEnumConstantContext(p *EnumConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumConstant
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantContext) AllEnumConstantModifier() []IEnumConstantModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstantModifierContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstantModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstantModifierContext); ok {
			tst[i] = t.(IEnumConstantModifierContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantContext) EnumConstantModifier(i int) IEnumConstantModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantModifierContext)
}

func (s *EnumConstantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *EnumConstantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *EnumConstantContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumConstantContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnumConstant(s)
	}
}

func (s *EnumConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnumConstant(s)
	}
}

func (p *Java20Parser) EnumConstant() (localctx IEnumConstantContext) {
	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Java20ParserRULE_enumConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(1364)
			p.EnumConstantModifier()
		}

		p.SetState(1369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1370)
		p.Identifier()
	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLPAREN {
		{
			p.SetState(1371)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(1372)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1375)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLBRACE {
		{
			p.SetState(1378)
			p.ClassBody()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantModifierContext is an interface to support dynamic dispatch.
type IEnumConstantModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext

	// IsEnumConstantModifierContext differentiates from other interfaces.
	IsEnumConstantModifierContext()
}

type EnumConstantModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantModifierContext() *EnumConstantModifierContext {
	var p = new(EnumConstantModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumConstantModifier
	return p
}

func InitEmptyEnumConstantModifierContext(p *EnumConstantModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumConstantModifier
}

func (*EnumConstantModifierContext) IsEnumConstantModifierContext() {}

func NewEnumConstantModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantModifierContext {
	var p = new(EnumConstantModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enumConstantModifier

	return p
}

func (s *EnumConstantModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *EnumConstantModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnumConstantModifier(s)
	}
}

func (s *EnumConstantModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnumConstantModifier(s)
	}
}

func (p *Java20Parser) EnumConstantModifier() (localctx IEnumConstantModifierContext) {
	localctx = NewEnumConstantModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Java20ParserRULE_enumConstantModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1381)
		p.Annotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodyDeclarationsContext is an interface to support dynamic dispatch.
type IEnumBodyDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext

	// IsEnumBodyDeclarationsContext differentiates from other interfaces.
	IsEnumBodyDeclarationsContext()
}

type EnumBodyDeclarationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyDeclarationsContext() *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumBodyDeclarations
	return p
}

func InitEmptyEnumBodyDeclarationsContext(p *EnumBodyDeclarationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enumBodyDeclarations
}

func (*EnumBodyDeclarationsContext) IsEnumBodyDeclarationsContext() {}

func NewEnumBodyDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enumBodyDeclarations

	return p
}

func (s *EnumBodyDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyDeclarationsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *EnumBodyDeclarationsContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *EnumBodyDeclarationsContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *EnumBodyDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnumBodyDeclarations(s)
	}
}

func (s *EnumBodyDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnumBodyDeclarations(s)
	}
}

func (p *Java20Parser) EnumBodyDeclarations() (localctx IEnumBodyDeclarationsContext) {
	localctx = NewEnumBodyDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Java20ParserRULE_enumBodyDeclarations)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1383)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8512665130203873298) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230376187502595) != 0) {
		{
			p.SetState(1384)
			p.ClassBodyDeclaration()
		}

		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationContext is an interface to support dynamic dispatch.
type IRecordDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	RecordHeader() IRecordHeaderContext
	RecordBody() IRecordBodyContext
	AllClassModifier() []IClassModifierContext
	ClassModifier(i int) IClassModifierContext
	TypeParameters() ITypeParametersContext
	ClassImplements() IClassImplementsContext

	// IsRecordDeclarationContext differentiates from other interfaces.
	IsRecordDeclarationContext()
}

type RecordDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationContext() *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordDeclaration
	return p
}

func InitEmptyRecordDeclarationContext(p *RecordDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordDeclaration
}

func (*RecordDeclarationContext) IsRecordDeclarationContext() {}

func NewRecordDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_recordDeclaration

	return p
}

func (s *RecordDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Java20ParserRECORD, 0)
}

func (s *RecordDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *RecordDeclarationContext) RecordHeader() IRecordHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordHeaderContext)
}

func (s *RecordDeclarationContext) RecordBody() IRecordBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordBodyContext)
}

func (s *RecordDeclarationContext) AllClassModifier() []IClassModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassModifierContext); ok {
			tst[i] = t.(IClassModifierContext)
			i++
		}
	}

	return tst
}

func (s *RecordDeclarationContext) ClassModifier(i int) IClassModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *RecordDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *RecordDeclarationContext) ClassImplements() IClassImplementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsContext)
}

func (s *RecordDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRecordDeclaration(s)
	}
}

func (p *Java20Parser) RecordDeclaration() (localctx IRecordDeclarationContext) {
	localctx = NewRecordDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Java20ParserRULE_recordDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&115967724764792840) != 0) || _la == Java20ParserAT {
		{
			p.SetState(1390)
			p.ClassModifier()
		}

		p.SetState(1395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1396)
		p.Match(Java20ParserRECORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1397)
		p.TypeIdentifier()
	}
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLT {
		{
			p.SetState(1398)
			p.TypeParameters()
		}

	}
	{
		p.SetState(1401)
		p.RecordHeader()
	}
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserIMPLEMENTS {
		{
			p.SetState(1402)
			p.ClassImplements()
		}

	}
	{
		p.SetState(1405)
		p.RecordBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordHeaderContext is an interface to support dynamic dispatch.
type IRecordHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	RecordComponentList() IRecordComponentListContext

	// IsRecordHeaderContext differentiates from other interfaces.
	IsRecordHeaderContext()
}

type RecordHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordHeaderContext() *RecordHeaderContext {
	var p = new(RecordHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordHeader
	return p
}

func InitEmptyRecordHeaderContext(p *RecordHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordHeader
}

func (*RecordHeaderContext) IsRecordHeaderContext() {}

func NewRecordHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordHeaderContext {
	var p = new(RecordHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_recordHeader

	return p
}

func (s *RecordHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordHeaderContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *RecordHeaderContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *RecordHeaderContext) RecordComponentList() IRecordComponentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentListContext)
}

func (s *RecordHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRecordHeader(s)
	}
}

func (s *RecordHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRecordHeader(s)
	}
}

func (p *Java20Parser) RecordHeader() (localctx IRecordHeaderContext) {
	localctx = NewRecordHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Java20ParserRULE_recordHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18102499065200622) != 0) || _la == Java20ParserAT || _la == Java20ParserIdentifier {
		{
			p.SetState(1408)
			p.RecordComponentList()
		}

	}
	{
		p.SetState(1411)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordComponentListContext is an interface to support dynamic dispatch.
type IRecordComponentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRecordComponent() []IRecordComponentContext
	RecordComponent(i int) IRecordComponentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRecordComponentListContext differentiates from other interfaces.
	IsRecordComponentListContext()
}

type RecordComponentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordComponentListContext() *RecordComponentListContext {
	var p = new(RecordComponentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordComponentList
	return p
}

func InitEmptyRecordComponentListContext(p *RecordComponentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordComponentList
}

func (*RecordComponentListContext) IsRecordComponentListContext() {}

func NewRecordComponentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordComponentListContext {
	var p = new(RecordComponentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_recordComponentList

	return p
}

func (s *RecordComponentListContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordComponentListContext) AllRecordComponent() []IRecordComponentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordComponentContext); ok {
			len++
		}
	}

	tst := make([]IRecordComponentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordComponentContext); ok {
			tst[i] = t.(IRecordComponentContext)
			i++
		}
	}

	return tst
}

func (s *RecordComponentListContext) RecordComponent(i int) IRecordComponentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentContext)
}

func (s *RecordComponentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *RecordComponentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *RecordComponentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordComponentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordComponentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRecordComponentList(s)
	}
}

func (s *RecordComponentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRecordComponentList(s)
	}
}

func (p *Java20Parser) RecordComponentList() (localctx IRecordComponentListContext) {
	localctx = NewRecordComponentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Java20ParserRULE_recordComponentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		p.RecordComponent()
	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(1414)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1415)
			p.RecordComponent()
		}

		p.SetState(1420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordComponentContext is an interface to support dynamic dispatch.
type IRecordComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	Identifier() IIdentifierContext
	AllRecordComponentModifier() []IRecordComponentModifierContext
	RecordComponentModifier(i int) IRecordComponentModifierContext
	VariableArityRecordComponent() IVariableArityRecordComponentContext

	// IsRecordComponentContext differentiates from other interfaces.
	IsRecordComponentContext()
}

type RecordComponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordComponentContext() *RecordComponentContext {
	var p = new(RecordComponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordComponent
	return p
}

func InitEmptyRecordComponentContext(p *RecordComponentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordComponent
}

func (*RecordComponentContext) IsRecordComponentContext() {}

func NewRecordComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordComponentContext {
	var p = new(RecordComponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_recordComponent

	return p
}

func (s *RecordComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordComponentContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *RecordComponentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecordComponentContext) AllRecordComponentModifier() []IRecordComponentModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordComponentModifierContext); ok {
			len++
		}
	}

	tst := make([]IRecordComponentModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordComponentModifierContext); ok {
			tst[i] = t.(IRecordComponentModifierContext)
			i++
		}
	}

	return tst
}

func (s *RecordComponentContext) RecordComponentModifier(i int) IRecordComponentModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentModifierContext)
}

func (s *RecordComponentContext) VariableArityRecordComponent() IVariableArityRecordComponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableArityRecordComponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableArityRecordComponentContext)
}

func (s *RecordComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRecordComponent(s)
	}
}

func (s *RecordComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRecordComponent(s)
	}
}

func (p *Java20Parser) RecordComponent() (localctx IRecordComponentContext) {
	localctx = NewRecordComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Java20ParserRULE_recordComponent)
	var _la int

	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(1421)
				p.RecordComponentModifier()
			}

			p.SetState(1426)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1427)
			p.UnannType()
		}
		{
			p.SetState(1428)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1430)
			p.VariableArityRecordComponent()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableArityRecordComponentContext is an interface to support dynamic dispatch.
type IVariableArityRecordComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	ELLIPSIS() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllRecordComponentModifier() []IRecordComponentModifierContext
	RecordComponentModifier(i int) IRecordComponentModifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsVariableArityRecordComponentContext differentiates from other interfaces.
	IsVariableArityRecordComponentContext()
}

type VariableArityRecordComponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableArityRecordComponentContext() *VariableArityRecordComponentContext {
	var p = new(VariableArityRecordComponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableArityRecordComponent
	return p
}

func InitEmptyVariableArityRecordComponentContext(p *VariableArityRecordComponentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableArityRecordComponent
}

func (*VariableArityRecordComponentContext) IsVariableArityRecordComponentContext() {}

func NewVariableArityRecordComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableArityRecordComponentContext {
	var p = new(VariableArityRecordComponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableArityRecordComponent

	return p
}

func (s *VariableArityRecordComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableArityRecordComponentContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *VariableArityRecordComponentContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(Java20ParserELLIPSIS, 0)
}

func (s *VariableArityRecordComponentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableArityRecordComponentContext) AllRecordComponentModifier() []IRecordComponentModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordComponentModifierContext); ok {
			len++
		}
	}

	tst := make([]IRecordComponentModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordComponentModifierContext); ok {
			tst[i] = t.(IRecordComponentModifierContext)
			i++
		}
	}

	return tst
}

func (s *VariableArityRecordComponentContext) RecordComponentModifier(i int) IRecordComponentModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentModifierContext)
}

func (s *VariableArityRecordComponentContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *VariableArityRecordComponentContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableArityRecordComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableArityRecordComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableArityRecordComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableArityRecordComponent(s)
	}
}

func (s *VariableArityRecordComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableArityRecordComponent(s)
	}
}

func (p *Java20Parser) VariableArityRecordComponent() (localctx IVariableArityRecordComponentContext) {
	localctx = NewVariableArityRecordComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Java20ParserRULE_variableArityRecordComponent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(1433)
			p.RecordComponentModifier()
		}

		p.SetState(1438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1439)
		p.UnannType()
	}
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(1440)
			p.Annotation()
		}

		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1446)
		p.Match(Java20ParserELLIPSIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1447)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordComponentModifierContext is an interface to support dynamic dispatch.
type IRecordComponentModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext

	// IsRecordComponentModifierContext differentiates from other interfaces.
	IsRecordComponentModifierContext()
}

type RecordComponentModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordComponentModifierContext() *RecordComponentModifierContext {
	var p = new(RecordComponentModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordComponentModifier
	return p
}

func InitEmptyRecordComponentModifierContext(p *RecordComponentModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordComponentModifier
}

func (*RecordComponentModifierContext) IsRecordComponentModifierContext() {}

func NewRecordComponentModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordComponentModifierContext {
	var p = new(RecordComponentModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_recordComponentModifier

	return p
}

func (s *RecordComponentModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordComponentModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *RecordComponentModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordComponentModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordComponentModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRecordComponentModifier(s)
	}
}

func (s *RecordComponentModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRecordComponentModifier(s)
	}
}

func (p *Java20Parser) RecordComponentModifier() (localctx IRecordComponentModifierContext) {
	localctx = NewRecordComponentModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Java20ParserRULE_recordComponentModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1449)
		p.Annotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordBodyContext is an interface to support dynamic dispatch.
type IRecordBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllRecordBodyDeclaration() []IRecordBodyDeclarationContext
	RecordBodyDeclaration(i int) IRecordBodyDeclarationContext

	// IsRecordBodyContext differentiates from other interfaces.
	IsRecordBodyContext()
}

type RecordBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordBodyContext() *RecordBodyContext {
	var p = new(RecordBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordBody
	return p
}

func InitEmptyRecordBodyContext(p *RecordBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordBody
}

func (*RecordBodyContext) IsRecordBodyContext() {}

func NewRecordBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordBodyContext {
	var p = new(RecordBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_recordBody

	return p
}

func (s *RecordBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *RecordBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *RecordBodyContext) AllRecordBodyDeclaration() []IRecordBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IRecordBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordBodyDeclarationContext); ok {
			tst[i] = t.(IRecordBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordBodyContext) RecordBodyDeclaration(i int) IRecordBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordBodyDeclarationContext)
}

func (s *RecordBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRecordBody(s)
	}
}

func (s *RecordBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRecordBody(s)
	}
}

func (p *Java20Parser) RecordBody() (localctx IRecordBodyContext) {
	localctx = NewRecordBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Java20ParserRULE_recordBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1451)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8512665130203873298) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230376187502595) != 0) {
		{
			p.SetState(1452)
			p.RecordBodyDeclaration()
		}

		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1458)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordBodyDeclarationContext is an interface to support dynamic dispatch.
type IRecordBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassBodyDeclaration() IClassBodyDeclarationContext
	CompactConstructorDeclaration() ICompactConstructorDeclarationContext

	// IsRecordBodyDeclarationContext differentiates from other interfaces.
	IsRecordBodyDeclarationContext()
}

type RecordBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordBodyDeclarationContext() *RecordBodyDeclarationContext {
	var p = new(RecordBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordBodyDeclaration
	return p
}

func InitEmptyRecordBodyDeclarationContext(p *RecordBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_recordBodyDeclaration
}

func (*RecordBodyDeclarationContext) IsRecordBodyDeclarationContext() {}

func NewRecordBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordBodyDeclarationContext {
	var p = new(RecordBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_recordBodyDeclaration

	return p
}

func (s *RecordBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordBodyDeclarationContext) ClassBodyDeclaration() IClassBodyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *RecordBodyDeclarationContext) CompactConstructorDeclaration() ICompactConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactConstructorDeclarationContext)
}

func (s *RecordBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRecordBodyDeclaration(s)
	}
}

func (s *RecordBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRecordBodyDeclaration(s)
	}
}

func (p *Java20Parser) RecordBodyDeclaration() (localctx IRecordBodyDeclarationContext) {
	localctx = NewRecordBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Java20ParserRULE_recordBodyDeclaration)
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1460)
			p.ClassBodyDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1461)
			p.CompactConstructorDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompactConstructorDeclarationContext is an interface to support dynamic dispatch.
type ICompactConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleTypeName() ISimpleTypeNameContext
	ConstructorBody() IConstructorBodyContext
	AllConstructorModifier() []IConstructorModifierContext
	ConstructorModifier(i int) IConstructorModifierContext

	// IsCompactConstructorDeclarationContext differentiates from other interfaces.
	IsCompactConstructorDeclarationContext()
}

type CompactConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompactConstructorDeclarationContext() *CompactConstructorDeclarationContext {
	var p = new(CompactConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_compactConstructorDeclaration
	return p
}

func InitEmptyCompactConstructorDeclarationContext(p *CompactConstructorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_compactConstructorDeclaration
}

func (*CompactConstructorDeclarationContext) IsCompactConstructorDeclarationContext() {}

func NewCompactConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactConstructorDeclarationContext {
	var p = new(CompactConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_compactConstructorDeclaration

	return p
}

func (s *CompactConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactConstructorDeclarationContext) SimpleTypeName() ISimpleTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeNameContext)
}

func (s *CompactConstructorDeclarationContext) ConstructorBody() IConstructorBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorBodyContext)
}

func (s *CompactConstructorDeclarationContext) AllConstructorModifier() []IConstructorModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstructorModifierContext); ok {
			len++
		}
	}

	tst := make([]IConstructorModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstructorModifierContext); ok {
			tst[i] = t.(IConstructorModifierContext)
			i++
		}
	}

	return tst
}

func (s *CompactConstructorDeclarationContext) ConstructorModifier(i int) IConstructorModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorModifierContext)
}

func (s *CompactConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompactConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCompactConstructorDeclaration(s)
	}
}

func (s *CompactConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCompactConstructorDeclaration(s)
	}
}

func (p *Java20Parser) CompactConstructorDeclaration() (localctx ICompactConstructorDeclarationContext) {
	localctx = NewCompactConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Java20ParserRULE_compactConstructorDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-50)) & ^0x3f) == 0 && ((int64(1)<<(_la-50))&68719476743) != 0 {
		{
			p.SetState(1464)
			p.ConstructorModifier()
		}

		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1470)
		p.SimpleTypeName()
	}
	{
		p.SetState(1471)
		p.ConstructorBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NormalInterfaceDeclaration() INormalInterfaceDeclarationContext
	AnnotationInterfaceDeclaration() IAnnotationInterfaceDeclarationContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) NormalInterfaceDeclaration() INormalInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalInterfaceDeclarationContext)
}

func (s *InterfaceDeclarationContext) AnnotationInterfaceDeclaration() IAnnotationInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationInterfaceDeclarationContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (p *Java20Parser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Java20ParserRULE_interfaceDeclaration)
	p.SetState(1475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1473)
			p.NormalInterfaceDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1474)
			p.AnnotationInterfaceDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalInterfaceDeclarationContext is an interface to support dynamic dispatch.
type INormalInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	InterfaceBody() IInterfaceBodyContext
	AllInterfaceModifier() []IInterfaceModifierContext
	InterfaceModifier(i int) IInterfaceModifierContext
	TypeParameters() ITypeParametersContext
	InterfaceExtends() IInterfaceExtendsContext
	InterfacePermits() IInterfacePermitsContext

	// IsNormalInterfaceDeclarationContext differentiates from other interfaces.
	IsNormalInterfaceDeclarationContext()
}

type NormalInterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalInterfaceDeclarationContext() *NormalInterfaceDeclarationContext {
	var p = new(NormalInterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_normalInterfaceDeclaration
	return p
}

func InitEmptyNormalInterfaceDeclarationContext(p *NormalInterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_normalInterfaceDeclaration
}

func (*NormalInterfaceDeclarationContext) IsNormalInterfaceDeclarationContext() {}

func NewNormalInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalInterfaceDeclarationContext {
	var p = new(NormalInterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_normalInterfaceDeclaration

	return p
}

func (s *NormalInterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalInterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserINTERFACE, 0)
}

func (s *NormalInterfaceDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *NormalInterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *NormalInterfaceDeclarationContext) AllInterfaceModifier() []IInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceModifierContext); ok {
			tst[i] = t.(IInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *NormalInterfaceDeclarationContext) InterfaceModifier(i int) IInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceModifierContext)
}

func (s *NormalInterfaceDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *NormalInterfaceDeclarationContext) InterfaceExtends() IInterfaceExtendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceExtendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceExtendsContext)
}

func (s *NormalInterfaceDeclarationContext) InterfacePermits() IInterfacePermitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfacePermitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfacePermitsContext)
}

func (s *NormalInterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalInterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalInterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterNormalInterfaceDeclaration(s)
	}
}

func (s *NormalInterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitNormalInterfaceDeclaration(s)
	}
}

func (p *Java20Parser) NormalInterfaceDeclaration() (localctx INormalInterfaceDeclarationContext) {
	localctx = NewNormalInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Java20ParserRULE_normalInterfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&115967690405054472) != 0) || _la == Java20ParserAT {
		{
			p.SetState(1477)
			p.InterfaceModifier()
		}

		p.SetState(1482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1483)
		p.Match(Java20ParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1484)
		p.TypeIdentifier()
	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLT {
		{
			p.SetState(1485)
			p.TypeParameters()
		}

	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserEXTENDS {
		{
			p.SetState(1488)
			p.InterfaceExtends()
		}

	}
	p.SetState(1492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserPERMITS {
		{
			p.SetState(1491)
			p.InterfacePermits()
		}

	}
	{
		p.SetState(1494)
		p.InterfaceBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceModifierContext is an interface to support dynamic dispatch.
type IInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	NONSEALED() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode

	// IsInterfaceModifierContext differentiates from other interfaces.
	IsInterfaceModifierContext()
}

type InterfaceModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceModifierContext() *InterfaceModifierContext {
	var p = new(InterfaceModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceModifier
	return p
}

func InitEmptyInterfaceModifierContext(p *InterfaceModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceModifier
}

func (*InterfaceModifierContext) IsInterfaceModifierContext() {}

func NewInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceModifierContext {
	var p = new(InterfaceModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceModifier

	return p
}

func (s *InterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *InterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(Java20ParserPROTECTED, 0)
}

func (s *InterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java20ParserPRIVATE, 0)
}

func (s *InterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java20ParserABSTRACT, 0)
}

func (s *InterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *InterfaceModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEALED, 0)
}

func (s *InterfaceModifierContext) NONSEALED() antlr.TerminalNode {
	return s.GetToken(Java20ParserNONSEALED, 0)
}

func (s *InterfaceModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTRICTFP, 0)
}

func (s *InterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceModifier(s)
	}
}

func (s *InterfaceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceModifier(s)
	}
}

func (p *Java20Parser) InterfaceModifier() (localctx IInterfaceModifierContext) {
	localctx = NewInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Java20ParserRULE_interfaceModifier)
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1496)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1497)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1498)
			p.Match(Java20ParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPRIVATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1499)
			p.Match(Java20ParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserABSTRACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1500)
			p.Match(Java20ParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1501)
			p.Match(Java20ParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSEALED:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1502)
			p.Match(Java20ParserSEALED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserNONSEALED:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1503)
			p.Match(Java20ParserNONSEALED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1504)
			p.Match(Java20ParserSTRICTFP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceExtendsContext is an interface to support dynamic dispatch.
type IInterfaceExtendsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTENDS() antlr.TerminalNode
	InterfaceTypeList() IInterfaceTypeListContext

	// IsInterfaceExtendsContext differentiates from other interfaces.
	IsInterfaceExtendsContext()
}

type InterfaceExtendsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceExtendsContext() *InterfaceExtendsContext {
	var p = new(InterfaceExtendsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceExtends
	return p
}

func InitEmptyInterfaceExtendsContext(p *InterfaceExtendsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceExtends
}

func (*InterfaceExtendsContext) IsInterfaceExtendsContext() {}

func NewInterfaceExtendsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceExtendsContext {
	var p = new(InterfaceExtendsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceExtends

	return p
}

func (s *InterfaceExtendsContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceExtendsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(Java20ParserEXTENDS, 0)
}

func (s *InterfaceExtendsContext) InterfaceTypeList() IInterfaceTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeListContext)
}

func (s *InterfaceExtendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceExtendsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceExtendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceExtends(s)
	}
}

func (s *InterfaceExtendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceExtends(s)
	}
}

func (p *Java20Parser) InterfaceExtends() (localctx IInterfaceExtendsContext) {
	localctx = NewInterfaceExtendsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Java20ParserRULE_interfaceExtends)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1507)
		p.Match(Java20ParserEXTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1508)
		p.InterfaceTypeList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfacePermitsContext is an interface to support dynamic dispatch.
type IInterfacePermitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERMITS() antlr.TerminalNode
	AllTypeName() []ITypeNameContext
	TypeName(i int) ITypeNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInterfacePermitsContext differentiates from other interfaces.
	IsInterfacePermitsContext()
}

type InterfacePermitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfacePermitsContext() *InterfacePermitsContext {
	var p = new(InterfacePermitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfacePermits
	return p
}

func InitEmptyInterfacePermitsContext(p *InterfacePermitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfacePermits
}

func (*InterfacePermitsContext) IsInterfacePermitsContext() {}

func NewInterfacePermitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfacePermitsContext {
	var p = new(InterfacePermitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfacePermits

	return p
}

func (s *InterfacePermitsContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfacePermitsContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(Java20ParserPERMITS, 0)
}

func (s *InterfacePermitsContext) AllTypeName() []ITypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeNameContext); ok {
			len++
		}
	}

	tst := make([]ITypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeNameContext); ok {
			tst[i] = t.(ITypeNameContext)
			i++
		}
	}

	return tst
}

func (s *InterfacePermitsContext) TypeName(i int) ITypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *InterfacePermitsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *InterfacePermitsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *InterfacePermitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfacePermitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfacePermitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfacePermits(s)
	}
}

func (s *InterfacePermitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfacePermits(s)
	}
}

func (p *Java20Parser) InterfacePermits() (localctx IInterfacePermitsContext) {
	localctx = NewInterfacePermitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Java20ParserRULE_interfacePermits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		p.Match(Java20ParserPERMITS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1511)
		p.TypeName()
	}
	p.SetState(1516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(1512)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1513)
			p.TypeName()
		}

		p.SetState(1518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllInterfaceMemberDeclaration() []IInterfaceMemberDeclarationContext
	InterfaceMemberDeclaration(i int) IInterfaceMemberDeclarationContext

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceBody
	return p
}

func InitEmptyInterfaceBodyContext(p *InterfaceBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceBody
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *InterfaceBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *InterfaceBodyContext) AllInterfaceMemberDeclaration() []IInterfaceMemberDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMemberDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMemberDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMemberDeclarationContext); ok {
			tst[i] = t.(IInterfaceMemberDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceMemberDeclaration(i int) IInterfaceMemberDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMemberDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberDeclarationContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceBody(s)
	}
}

func (p *Java20Parser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Java20ParserRULE_interfaceBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&134105417395994606) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230376187494401) != 0) {
		{
			p.SetState(1520)
			p.InterfaceMemberDeclaration()
		}

		p.SetState(1525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1526)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMemberDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstantDeclaration() IConstantDeclarationContext
	InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	SEMI() antlr.TerminalNode

	// IsInterfaceMemberDeclarationContext differentiates from other interfaces.
	IsInterfaceMemberDeclarationContext()
}

type InterfaceMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberDeclarationContext() *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceMemberDeclaration
	return p
}

func InitEmptyInterfaceMemberDeclarationContext(p *InterfaceMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceMemberDeclaration
}

func (*InterfaceMemberDeclarationContext) IsInterfaceMemberDeclarationContext() {}

func NewInterfaceMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceMemberDeclaration

	return p
}

func (s *InterfaceMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberDeclarationContext) ConstantDeclaration() IConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *InterfaceMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceMemberDeclaration(s)
	}
}

func (s *InterfaceMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceMemberDeclaration(s)
	}
}

func (p *Java20Parser) InterfaceMemberDeclaration() (localctx IInterfaceMemberDeclarationContext) {
	localctx = NewInterfaceMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Java20ParserRULE_interfaceMemberDeclaration)
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1528)
			p.ConstantDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1529)
			p.InterfaceMethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1530)
			p.ClassDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1531)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1532)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDeclarationContext is an interface to support dynamic dispatch.
type IConstantDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	VariableDeclaratorList() IVariableDeclaratorListContext
	SEMI() antlr.TerminalNode
	AllConstantModifier() []IConstantModifierContext
	ConstantModifier(i int) IConstantModifierContext

	// IsConstantDeclarationContext differentiates from other interfaces.
	IsConstantDeclarationContext()
}

type ConstantDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDeclarationContext() *ConstantDeclarationContext {
	var p = new(ConstantDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constantDeclaration
	return p
}

func InitEmptyConstantDeclarationContext(p *ConstantDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constantDeclaration
}

func (*ConstantDeclarationContext) IsConstantDeclarationContext() {}

func NewConstantDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDeclarationContext {
	var p = new(ConstantDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_constantDeclaration

	return p
}

func (s *ConstantDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDeclarationContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *ConstantDeclarationContext) VariableDeclaratorList() IVariableDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorListContext)
}

func (s *ConstantDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ConstantDeclarationContext) AllConstantModifier() []IConstantModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantModifierContext); ok {
			len++
		}
	}

	tst := make([]IConstantModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantModifierContext); ok {
			tst[i] = t.(IConstantModifierContext)
			i++
		}
	}

	return tst
}

func (s *ConstantDeclarationContext) ConstantModifier(i int) IConstantModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantModifierContext)
}

func (s *ConstantDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConstantDeclaration(s)
	}
}

func (s *ConstantDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConstantDeclaration(s)
	}
}

func (p *Java20Parser) ConstantDeclaration() (localctx IConstantDeclarationContext) {
	localctx = NewConstantDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Java20ParserRULE_constantDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-35)) & ^0x3f) == 0 && ((int64(1)<<(_la-35))&2251799814864897) != 0 {
		{
			p.SetState(1535)
			p.ConstantModifier()
		}

		p.SetState(1540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1541)
		p.UnannType()
	}
	{
		p.SetState(1542)
		p.VariableDeclaratorList()
	}
	{
		p.SetState(1543)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantModifierContext is an interface to support dynamic dispatch.
type IConstantModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	FINAL() antlr.TerminalNode

	// IsConstantModifierContext differentiates from other interfaces.
	IsConstantModifierContext()
}

type ConstantModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantModifierContext() *ConstantModifierContext {
	var p = new(ConstantModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constantModifier
	return p
}

func InitEmptyConstantModifierContext(p *ConstantModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constantModifier
}

func (*ConstantModifierContext) IsConstantModifierContext() {}

func NewConstantModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantModifierContext {
	var p = new(ConstantModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_constantModifier

	return p
}

func (s *ConstantModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ConstantModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *ConstantModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *ConstantModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Java20ParserFINAL, 0)
}

func (s *ConstantModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConstantModifier(s)
	}
}

func (s *ConstantModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConstantModifier(s)
	}
}

func (p *Java20Parser) ConstantModifier() (localctx IConstantModifierContext) {
	localctx = NewConstantModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Java20ParserRULE_constantModifier)
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1545)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1546)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTATIC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1547)
			p.Match(Java20ParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserFINAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1548)
			p.Match(Java20ParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodHeader() IMethodHeaderContext
	MethodBody() IMethodBodyContext
	AllInterfaceMethodModifier() []IInterfaceMethodModifierContext
	InterfaceMethodModifier(i int) IInterfaceMethodModifierContext

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceMethodDeclaration
	return p
}

func InitEmptyInterfaceMethodDeclarationContext(p *InterfaceMethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceMethodDeclaration
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) MethodHeader() IMethodHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodHeaderContext)
}

func (s *InterfaceMethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *InterfaceMethodDeclarationContext) AllInterfaceMethodModifier() []IInterfaceMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodModifierContext); ok {
			tst[i] = t.(IInterfaceMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMethodDeclarationContext) InterfaceMethodModifier(i int) IInterfaceMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodModifierContext)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceMethodDeclaration(s)
	}
}

func (p *Java20Parser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Java20ParserRULE_interfaceMethodDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&113715891128238080) != 0) || _la == Java20ParserAT {
		{
			p.SetState(1551)
			p.InterfaceMethodModifier()
		}

		p.SetState(1556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1557)
		p.MethodHeader()
	}
	{
		p.SetState(1558)
		p.MethodBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodModifierContext is an interface to support dynamic dispatch.
type IInterfaceMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode

	// IsInterfaceMethodModifierContext differentiates from other interfaces.
	IsInterfaceMethodModifierContext()
}

type InterfaceMethodModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodModifierContext() *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceMethodModifier
	return p
}

func InitEmptyInterfaceMethodModifierContext(p *InterfaceMethodModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_interfaceMethodModifier
}

func (*InterfaceMethodModifierContext) IsInterfaceMethodModifierContext() {}

func NewInterfaceMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_interfaceMethodModifier

	return p
}

func (s *InterfaceMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceMethodModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *InterfaceMethodModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Java20ParserPRIVATE, 0)
}

func (s *InterfaceMethodModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java20ParserABSTRACT, 0)
}

func (s *InterfaceMethodModifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDEFAULT, 0)
}

func (s *InterfaceMethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTATIC, 0)
}

func (s *InterfaceMethodModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(Java20ParserSTRICTFP, 0)
}

func (s *InterfaceMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInterfaceMethodModifier(s)
	}
}

func (s *InterfaceMethodModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInterfaceMethodModifier(s)
	}
}

func (p *Java20Parser) InterfaceMethodModifier() (localctx IInterfaceMethodModifierContext) {
	localctx = NewInterfaceMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Java20ParserRULE_interfaceMethodModifier)
	p.SetState(1567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1560)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1561)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserPRIVATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1562)
			p.Match(Java20ParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserABSTRACT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1563)
			p.Match(Java20ParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserDEFAULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1564)
			p.Match(Java20ParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTATIC:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1565)
			p.Match(Java20ParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserSTRICTFP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1566)
			p.Match(Java20ParserSTRICTFP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	AnnotationInterfaceBody() IAnnotationInterfaceBodyContext
	AllInterfaceModifier() []IInterfaceModifierContext
	InterfaceModifier(i int) IInterfaceModifierContext

	// IsAnnotationInterfaceDeclarationContext differentiates from other interfaces.
	IsAnnotationInterfaceDeclarationContext()
}

type AnnotationInterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationInterfaceDeclarationContext() *AnnotationInterfaceDeclarationContext {
	var p = new(AnnotationInterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceDeclaration
	return p
}

func InitEmptyAnnotationInterfaceDeclarationContext(p *AnnotationInterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceDeclaration
}

func (*AnnotationInterfaceDeclarationContext) IsAnnotationInterfaceDeclarationContext() {}

func NewAnnotationInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationInterfaceDeclarationContext {
	var p = new(AnnotationInterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_annotationInterfaceDeclaration

	return p
}

func (s *AnnotationInterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationInterfaceDeclarationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java20ParserAT, 0)
}

func (s *AnnotationInterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserINTERFACE, 0)
}

func (s *AnnotationInterfaceDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *AnnotationInterfaceDeclarationContext) AnnotationInterfaceBody() IAnnotationInterfaceBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationInterfaceBodyContext)
}

func (s *AnnotationInterfaceDeclarationContext) AllInterfaceModifier() []IInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceModifierContext); ok {
			tst[i] = t.(IInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationInterfaceDeclarationContext) InterfaceModifier(i int) IInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceModifierContext)
}

func (s *AnnotationInterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationInterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationInterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAnnotationInterfaceDeclaration(s)
	}
}

func (s *AnnotationInterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAnnotationInterfaceDeclaration(s)
	}
}

func (p *Java20Parser) AnnotationInterfaceDeclaration() (localctx IAnnotationInterfaceDeclarationContext) {
	localctx = NewAnnotationInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Java20ParserRULE_annotationInterfaceDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1569)
				p.InterfaceModifier()
			}

		}
		p.SetState(1574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1575)
		p.Match(Java20ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1576)
		p.Match(Java20ParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1577)
		p.TypeIdentifier()
	}
	{
		p.SetState(1578)
		p.AnnotationInterfaceBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationInterfaceBodyContext is an interface to support dynamic dispatch.
type IAnnotationInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllAnnotationInterfaceMemberDeclaration() []IAnnotationInterfaceMemberDeclarationContext
	AnnotationInterfaceMemberDeclaration(i int) IAnnotationInterfaceMemberDeclarationContext

	// IsAnnotationInterfaceBodyContext differentiates from other interfaces.
	IsAnnotationInterfaceBodyContext()
}

type AnnotationInterfaceBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationInterfaceBodyContext() *AnnotationInterfaceBodyContext {
	var p = new(AnnotationInterfaceBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceBody
	return p
}

func InitEmptyAnnotationInterfaceBodyContext(p *AnnotationInterfaceBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceBody
}

func (*AnnotationInterfaceBodyContext) IsAnnotationInterfaceBodyContext() {}

func NewAnnotationInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationInterfaceBodyContext {
	var p = new(AnnotationInterfaceBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_annotationInterfaceBody

	return p
}

func (s *AnnotationInterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationInterfaceBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *AnnotationInterfaceBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *AnnotationInterfaceBodyContext) AllAnnotationInterfaceMemberDeclaration() []IAnnotationInterfaceMemberDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationInterfaceMemberDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationInterfaceMemberDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationInterfaceMemberDeclarationContext); ok {
			tst[i] = t.(IAnnotationInterfaceMemberDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationInterfaceBodyContext) AnnotationInterfaceMemberDeclaration(i int) IAnnotationInterfaceMemberDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationInterfaceMemberDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationInterfaceMemberDeclarationContext)
}

func (s *AnnotationInterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationInterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationInterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAnnotationInterfaceBody(s)
	}
}

func (s *AnnotationInterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAnnotationInterfaceBody(s)
	}
}

func (p *Java20Parser) AnnotationInterfaceBody() (localctx IAnnotationInterfaceBodyContext) {
	localctx = NewAnnotationInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, Java20ParserRULE_annotationInterfaceBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1580)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&134105416859123694) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&2199023255569) != 0) {
		{
			p.SetState(1581)
			p.AnnotationInterfaceMemberDeclaration()
		}

		p.SetState(1586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1587)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationInterfaceMemberDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationInterfaceMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationInterfaceElementDeclaration() IAnnotationInterfaceElementDeclarationContext
	ConstantDeclaration() IConstantDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	SEMI() antlr.TerminalNode

	// IsAnnotationInterfaceMemberDeclarationContext differentiates from other interfaces.
	IsAnnotationInterfaceMemberDeclarationContext()
}

type AnnotationInterfaceMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationInterfaceMemberDeclarationContext() *AnnotationInterfaceMemberDeclarationContext {
	var p = new(AnnotationInterfaceMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceMemberDeclaration
	return p
}

func InitEmptyAnnotationInterfaceMemberDeclarationContext(p *AnnotationInterfaceMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceMemberDeclaration
}

func (*AnnotationInterfaceMemberDeclarationContext) IsAnnotationInterfaceMemberDeclarationContext() {}

func NewAnnotationInterfaceMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationInterfaceMemberDeclarationContext {
	var p = new(AnnotationInterfaceMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_annotationInterfaceMemberDeclaration

	return p
}

func (s *AnnotationInterfaceMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationInterfaceMemberDeclarationContext) AnnotationInterfaceElementDeclaration() IAnnotationInterfaceElementDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationInterfaceElementDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationInterfaceElementDeclarationContext)
}

func (s *AnnotationInterfaceMemberDeclarationContext) ConstantDeclaration() IConstantDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDeclarationContext)
}

func (s *AnnotationInterfaceMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *AnnotationInterfaceMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *AnnotationInterfaceMemberDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *AnnotationInterfaceMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationInterfaceMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationInterfaceMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAnnotationInterfaceMemberDeclaration(s)
	}
}

func (s *AnnotationInterfaceMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAnnotationInterfaceMemberDeclaration(s)
	}
}

func (p *Java20Parser) AnnotationInterfaceMemberDeclaration() (localctx IAnnotationInterfaceMemberDeclarationContext) {
	localctx = NewAnnotationInterfaceMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, Java20ParserRULE_annotationInterfaceMemberDeclaration)
	p.SetState(1594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1589)
			p.AnnotationInterfaceElementDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1590)
			p.ConstantDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1591)
			p.ClassDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1592)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1593)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationInterfaceElementDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationInterfaceElementDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	AllAnnotationInterfaceElementModifier() []IAnnotationInterfaceElementModifierContext
	AnnotationInterfaceElementModifier(i int) IAnnotationInterfaceElementModifierContext
	Dims() IDimsContext
	DefaultValue() IDefaultValueContext

	// IsAnnotationInterfaceElementDeclarationContext differentiates from other interfaces.
	IsAnnotationInterfaceElementDeclarationContext()
}

type AnnotationInterfaceElementDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationInterfaceElementDeclarationContext() *AnnotationInterfaceElementDeclarationContext {
	var p = new(AnnotationInterfaceElementDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceElementDeclaration
	return p
}

func InitEmptyAnnotationInterfaceElementDeclarationContext(p *AnnotationInterfaceElementDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceElementDeclaration
}

func (*AnnotationInterfaceElementDeclarationContext) IsAnnotationInterfaceElementDeclarationContext() {
}

func NewAnnotationInterfaceElementDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationInterfaceElementDeclarationContext {
	var p = new(AnnotationInterfaceElementDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_annotationInterfaceElementDeclaration

	return p
}

func (s *AnnotationInterfaceElementDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationInterfaceElementDeclarationContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *AnnotationInterfaceElementDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnnotationInterfaceElementDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *AnnotationInterfaceElementDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *AnnotationInterfaceElementDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *AnnotationInterfaceElementDeclarationContext) AllAnnotationInterfaceElementModifier() []IAnnotationInterfaceElementModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationInterfaceElementModifierContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationInterfaceElementModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationInterfaceElementModifierContext); ok {
			tst[i] = t.(IAnnotationInterfaceElementModifierContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationInterfaceElementDeclarationContext) AnnotationInterfaceElementModifier(i int) IAnnotationInterfaceElementModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationInterfaceElementModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationInterfaceElementModifierContext)
}

func (s *AnnotationInterfaceElementDeclarationContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *AnnotationInterfaceElementDeclarationContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AnnotationInterfaceElementDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationInterfaceElementDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationInterfaceElementDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAnnotationInterfaceElementDeclaration(s)
	}
}

func (s *AnnotationInterfaceElementDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAnnotationInterfaceElementDeclaration(s)
	}
}

func (p *Java20Parser) AnnotationInterfaceElementDeclaration() (localctx IAnnotationInterfaceElementDeclarationContext) {
	localctx = NewAnnotationInterfaceElementDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, Java20ParserRULE_annotationInterfaceElementDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserABSTRACT || _la == Java20ParserPUBLIC || _la == Java20ParserAT {
		{
			p.SetState(1596)
			p.AnnotationInterfaceElementModifier()
		}

		p.SetState(1601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1602)
		p.UnannType()
	}
	{
		p.SetState(1603)
		p.Identifier()
	}
	{
		p.SetState(1604)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1605)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLBRACK || _la == Java20ParserAT {
		{
			p.SetState(1606)
			p.Dims()
		}

	}
	p.SetState(1610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserDEFAULT {
		{
			p.SetState(1609)
			p.DefaultValue()
		}

	}
	{
		p.SetState(1612)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationInterfaceElementModifierContext is an interface to support dynamic dispatch.
type IAnnotationInterfaceElementModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode

	// IsAnnotationInterfaceElementModifierContext differentiates from other interfaces.
	IsAnnotationInterfaceElementModifierContext()
}

type AnnotationInterfaceElementModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationInterfaceElementModifierContext() *AnnotationInterfaceElementModifierContext {
	var p = new(AnnotationInterfaceElementModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceElementModifier
	return p
}

func InitEmptyAnnotationInterfaceElementModifierContext(p *AnnotationInterfaceElementModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotationInterfaceElementModifier
}

func (*AnnotationInterfaceElementModifierContext) IsAnnotationInterfaceElementModifierContext() {}

func NewAnnotationInterfaceElementModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationInterfaceElementModifierContext {
	var p = new(AnnotationInterfaceElementModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_annotationInterfaceElementModifier

	return p
}

func (s *AnnotationInterfaceElementModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationInterfaceElementModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationInterfaceElementModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(Java20ParserPUBLIC, 0)
}

func (s *AnnotationInterfaceElementModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(Java20ParserABSTRACT, 0)
}

func (s *AnnotationInterfaceElementModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationInterfaceElementModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationInterfaceElementModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAnnotationInterfaceElementModifier(s)
	}
}

func (s *AnnotationInterfaceElementModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAnnotationInterfaceElementModifier(s)
	}
}

func (p *Java20Parser) AnnotationInterfaceElementModifier() (localctx IAnnotationInterfaceElementModifierContext) {
	localctx = NewAnnotationInterfaceElementModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, Java20ParserRULE_annotationInterfaceElementModifier)
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1614)
			p.Annotation()
		}

	case Java20ParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1615)
			p.Match(Java20ParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserABSTRACT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1616)
			p.Match(Java20ParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	ElementValue() IElementValueContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDEFAULT, 0)
}

func (s *DefaultValueContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *Java20Parser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, Java20ParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1619)
		p.Match(Java20ParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1620)
		p.ElementValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NormalAnnotation() INormalAnnotationContext
	MarkerAnnotation() IMarkerAnnotationContext
	SingleElementAnnotation() ISingleElementAnnotationContext

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) NormalAnnotation() INormalAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalAnnotationContext)
}

func (s *AnnotationContext) MarkerAnnotation() IMarkerAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkerAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkerAnnotationContext)
}

func (s *AnnotationContext) SingleElementAnnotation() ISingleElementAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleElementAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleElementAnnotationContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *Java20Parser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, Java20ParserRULE_annotation)
	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1622)
			p.NormalAnnotation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1623)
			p.MarkerAnnotation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1624)
			p.SingleElementAnnotation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalAnnotationContext is an interface to support dynamic dispatch.
type INormalAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	TypeName() ITypeNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ElementValuePairList() IElementValuePairListContext

	// IsNormalAnnotationContext differentiates from other interfaces.
	IsNormalAnnotationContext()
}

type NormalAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalAnnotationContext() *NormalAnnotationContext {
	var p = new(NormalAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_normalAnnotation
	return p
}

func InitEmptyNormalAnnotationContext(p *NormalAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_normalAnnotation
}

func (*NormalAnnotationContext) IsNormalAnnotationContext() {}

func NewNormalAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalAnnotationContext {
	var p = new(NormalAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_normalAnnotation

	return p
}

func (s *NormalAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalAnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java20ParserAT, 0)
}

func (s *NormalAnnotationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *NormalAnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *NormalAnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *NormalAnnotationContext) ElementValuePairList() IElementValuePairListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairListContext)
}

func (s *NormalAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterNormalAnnotation(s)
	}
}

func (s *NormalAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitNormalAnnotation(s)
	}
}

func (p *Java20Parser) NormalAnnotation() (localctx INormalAnnotationContext) {
	localctx = NewNormalAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, Java20ParserRULE_normalAnnotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(Java20ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1628)
		p.TypeName()
	}
	{
		p.SetState(1629)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262126) != 0) || _la == Java20ParserIdentifier {
		{
			p.SetState(1630)
			p.ElementValuePairList()
		}

	}
	{
		p.SetState(1633)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairListContext is an interface to support dynamic dispatch.
type IElementValuePairListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElementValuePair() []IElementValuePairContext
	ElementValuePair(i int) IElementValuePairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValuePairListContext differentiates from other interfaces.
	IsElementValuePairListContext()
}

type ElementValuePairListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairListContext() *ElementValuePairListContext {
	var p = new(ElementValuePairListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValuePairList
	return p
}

func InitEmptyElementValuePairListContext(p *ElementValuePairListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValuePairList
}

func (*ElementValuePairListContext) IsElementValuePairListContext() {}

func NewElementValuePairListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairListContext {
	var p = new(ElementValuePairListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_elementValuePairList

	return p
}

func (s *ElementValuePairListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairListContext) AllElementValuePair() []IElementValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValuePairContext); ok {
			len++
		}
	}

	tst := make([]IElementValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValuePairContext); ok {
			tst[i] = t.(IElementValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairListContext) ElementValuePair(i int) IElementValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *ElementValuePairListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *ElementValuePairListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterElementValuePairList(s)
	}
}

func (s *ElementValuePairListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitElementValuePairList(s)
	}
}

func (p *Java20Parser) ElementValuePairList() (localctx IElementValuePairListContext) {
	localctx = NewElementValuePairListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, Java20ParserRULE_elementValuePairList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.ElementValuePair()
	}
	p.SetState(1640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(1636)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1637)
			p.ElementValuePair()
		}

		p.SetState(1642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	ElementValue() IElementValueContext

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValuePair
	return p
}

func InitEmptyElementValuePairContext(p *ElementValuePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValuePair
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}

func (p *Java20Parser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, Java20ParserRULE_elementValuePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1643)
		p.Identifier()
	}
	{
		p.SetState(1644)
		p.Match(Java20ParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1645)
		p.ElementValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalExpression() IConditionalExpressionContext
	ElementValueArrayInitializer() IElementValueArrayInitializerContext
	Annotation() IAnnotationContext

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValue
	return p
}

func InitEmptyElementValueContext(p *ElementValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValue
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitElementValue(s)
	}
}

func (p *Java20Parser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, Java20ParserRULE_elementValue)
	p.SetState(1650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1647)
			p.ConditionalExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1648)
			p.ElementValueArrayInitializer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1649)
			p.Annotation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ElementValueList() IElementValueListContext
	COMMA() antlr.TerminalNode

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValueArrayInitializer
	return p
}

func InitEmptyElementValueArrayInitializerContext(p *ElementValueArrayInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValueArrayInitializer
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) ElementValueList() IElementValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueListContext)
}

func (s *ElementValueArrayInitializerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, 0)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}

func (p *Java20Parser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, Java20ParserRULE_elementValueArrayInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1652)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939449841) != 0) {
		{
			p.SetState(1653)
			p.ElementValueList()
		}

	}
	p.SetState(1657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserCOMMA {
		{
			p.SetState(1656)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1659)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueListContext is an interface to support dynamic dispatch.
type IElementValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElementValue() []IElementValueContext
	ElementValue(i int) IElementValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValueListContext differentiates from other interfaces.
	IsElementValueListContext()
}

type ElementValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueListContext() *ElementValueListContext {
	var p = new(ElementValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValueList
	return p
}

func InitEmptyElementValueListContext(p *ElementValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_elementValueList
}

func (*ElementValueListContext) IsElementValueListContext() {}

func NewElementValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueListContext {
	var p = new(ElementValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_elementValueList

	return p
}

func (s *ElementValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueListContext) AllElementValue() []IElementValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValueContext); ok {
			len++
		}
	}

	tst := make([]IElementValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValueContext); ok {
			tst[i] = t.(IElementValueContext)
			i++
		}
	}

	return tst
}

func (s *ElementValueListContext) ElementValue(i int) IElementValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *ElementValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *ElementValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterElementValueList(s)
	}
}

func (s *ElementValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitElementValueList(s)
	}
}

func (p *Java20Parser) ElementValueList() (localctx IElementValueListContext) {
	localctx = NewElementValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, Java20ParserRULE_elementValueList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1661)
		p.ElementValue()
	}
	p.SetState(1666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1662)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1663)
				p.ElementValue()
			}

		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMarkerAnnotationContext is an interface to support dynamic dispatch.
type IMarkerAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	TypeName() ITypeNameContext

	// IsMarkerAnnotationContext differentiates from other interfaces.
	IsMarkerAnnotationContext()
}

type MarkerAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMarkerAnnotationContext() *MarkerAnnotationContext {
	var p = new(MarkerAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_markerAnnotation
	return p
}

func InitEmptyMarkerAnnotationContext(p *MarkerAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_markerAnnotation
}

func (*MarkerAnnotationContext) IsMarkerAnnotationContext() {}

func NewMarkerAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MarkerAnnotationContext {
	var p = new(MarkerAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_markerAnnotation

	return p
}

func (s *MarkerAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *MarkerAnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java20ParserAT, 0)
}

func (s *MarkerAnnotationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MarkerAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MarkerAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MarkerAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMarkerAnnotation(s)
	}
}

func (s *MarkerAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMarkerAnnotation(s)
	}
}

func (p *Java20Parser) MarkerAnnotation() (localctx IMarkerAnnotationContext) {
	localctx = NewMarkerAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, Java20ParserRULE_markerAnnotation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1669)
		p.Match(Java20ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1670)
		p.TypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleElementAnnotationContext is an interface to support dynamic dispatch.
type ISingleElementAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	TypeName() ITypeNameContext
	LPAREN() antlr.TerminalNode
	ElementValue() IElementValueContext
	RPAREN() antlr.TerminalNode

	// IsSingleElementAnnotationContext differentiates from other interfaces.
	IsSingleElementAnnotationContext()
}

type SingleElementAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleElementAnnotationContext() *SingleElementAnnotationContext {
	var p = new(SingleElementAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_singleElementAnnotation
	return p
}

func InitEmptySingleElementAnnotationContext(p *SingleElementAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_singleElementAnnotation
}

func (*SingleElementAnnotationContext) IsSingleElementAnnotationContext() {}

func NewSingleElementAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleElementAnnotationContext {
	var p = new(SingleElementAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_singleElementAnnotation

	return p
}

func (s *SingleElementAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleElementAnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(Java20ParserAT, 0)
}

func (s *SingleElementAnnotationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *SingleElementAnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *SingleElementAnnotationContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *SingleElementAnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *SingleElementAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleElementAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleElementAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSingleElementAnnotation(s)
	}
}

func (s *SingleElementAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSingleElementAnnotation(s)
	}
}

func (p *Java20Parser) SingleElementAnnotation() (localctx ISingleElementAnnotationContext) {
	localctx = NewSingleElementAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, Java20ParserRULE_singleElementAnnotation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1672)
		p.Match(Java20ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1673)
		p.TypeName()
	}
	{
		p.SetState(1674)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1675)
		p.ElementValue()
	}
	{
		p.SetState(1676)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	VariableInitializerList() IVariableInitializerListContext
	COMMA() antlr.TerminalNode

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayInitializer
	return p
}

func InitEmptyArrayInitializerContext(p *ArrayInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayInitializer
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *ArrayInitializerContext) VariableInitializerList() IVariableInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerListContext)
}

func (s *ArrayInitializerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, 0)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (p *Java20Parser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, Java20ParserRULE_arrayInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1678)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939449841) != 0) {
		{
			p.SetState(1679)
			p.VariableInitializerList()
		}

	}
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserCOMMA {
		{
			p.SetState(1682)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1685)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableInitializerListContext is an interface to support dynamic dispatch.
type IVariableInitializerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableInitializer() []IVariableInitializerContext
	VariableInitializer(i int) IVariableInitializerContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableInitializerListContext differentiates from other interfaces.
	IsVariableInitializerListContext()
}

type VariableInitializerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerListContext() *VariableInitializerListContext {
	var p = new(VariableInitializerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableInitializerList
	return p
}

func InitEmptyVariableInitializerListContext(p *VariableInitializerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableInitializerList
}

func (*VariableInitializerListContext) IsVariableInitializerListContext() {}

func NewVariableInitializerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerListContext {
	var p = new(VariableInitializerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableInitializerList

	return p
}

func (s *VariableInitializerListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerListContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *VariableInitializerListContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableInitializerListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *VariableInitializerListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *VariableInitializerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableInitializerList(s)
	}
}

func (s *VariableInitializerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableInitializerList(s)
	}
}

func (p *Java20Parser) VariableInitializerList() (localctx IVariableInitializerListContext) {
	localctx = NewVariableInitializerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, Java20ParserRULE_variableInitializerList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1687)
		p.VariableInitializer()
	}
	p.SetState(1692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1688)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1689)
				p.VariableInitializer()
			}

		}
		p.SetState(1694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	BlockStatements() IBlockStatementsContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *BlockContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *Java20Parser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, Java20ParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1695)
		p.Match(Java20ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4610965747420626926) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&576461576941625323) != 0) {
		{
			p.SetState(1696)
			p.BlockStatements()
		}

	}
	{
		p.SetState(1699)
		p.Match(Java20ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementsContext is an interface to support dynamic dispatch.
type IBlockStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBlockStatement() []IBlockStatementContext
	BlockStatement(i int) IBlockStatementContext

	// IsBlockStatementsContext differentiates from other interfaces.
	IsBlockStatementsContext()
}

type BlockStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsContext() *BlockStatementsContext {
	var p = new(BlockStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_blockStatements
	return p
}

func InitEmptyBlockStatementsContext(p *BlockStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_blockStatements
}

func (*BlockStatementsContext) IsBlockStatementsContext() {}

func NewBlockStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsContext {
	var p = new(BlockStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_blockStatements

	return p
}

func (s *BlockStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementsContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterBlockStatements(s)
	}
}

func (s *BlockStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitBlockStatements(s)
	}
}

func (p *Java20Parser) BlockStatements() (localctx IBlockStatementsContext) {
	localctx = NewBlockStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, Java20ParserRULE_blockStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)
		p.BlockStatement()
	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4610965747420626926) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&576461576941625323) != 0) {
		{
			p.SetState(1702)
			p.BlockStatement()
		}

		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalClassOrInterfaceDeclaration() ILocalClassOrInterfaceDeclarationContext
	LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext
	Statement() IStatementContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_blockStatement
	return p
}

func InitEmptyBlockStatementContext(p *BlockStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_blockStatement
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalClassOrInterfaceDeclaration() ILocalClassOrInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalClassOrInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalClassOrInterfaceDeclarationContext)
}

func (s *BlockStatementContext) LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationStatementContext)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *Java20Parser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, Java20ParserRULE_blockStatement)
	p.SetState(1711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1708)
			p.LocalClassOrInterfaceDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1709)
			p.LocalVariableDeclarationStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1710)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalClassOrInterfaceDeclarationContext is an interface to support dynamic dispatch.
type ILocalClassOrInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	NormalInterfaceDeclaration() INormalInterfaceDeclarationContext

	// IsLocalClassOrInterfaceDeclarationContext differentiates from other interfaces.
	IsLocalClassOrInterfaceDeclarationContext()
}

type LocalClassOrInterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalClassOrInterfaceDeclarationContext() *LocalClassOrInterfaceDeclarationContext {
	var p = new(LocalClassOrInterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localClassOrInterfaceDeclaration
	return p
}

func InitEmptyLocalClassOrInterfaceDeclarationContext(p *LocalClassOrInterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localClassOrInterfaceDeclaration
}

func (*LocalClassOrInterfaceDeclarationContext) IsLocalClassOrInterfaceDeclarationContext() {}

func NewLocalClassOrInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalClassOrInterfaceDeclarationContext {
	var p = new(LocalClassOrInterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_localClassOrInterfaceDeclaration

	return p
}

func (s *LocalClassOrInterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalClassOrInterfaceDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *LocalClassOrInterfaceDeclarationContext) NormalInterfaceDeclaration() INormalInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalInterfaceDeclarationContext)
}

func (s *LocalClassOrInterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalClassOrInterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalClassOrInterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLocalClassOrInterfaceDeclaration(s)
	}
}

func (s *LocalClassOrInterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLocalClassOrInterfaceDeclaration(s)
	}
}

func (p *Java20Parser) LocalClassOrInterfaceDeclaration() (localctx ILocalClassOrInterfaceDeclarationContext) {
	localctx = NewLocalClassOrInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, Java20ParserRULE_localClassOrInterfaceDeclaration)
	p.SetState(1715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1713)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1714)
			p.NormalInterfaceDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableType() ILocalVariableTypeContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	VariableDeclaratorList() IVariableDeclaratorListContext

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localVariableDeclaration
	return p
}

func InitEmptyLocalVariableDeclarationContext(p *LocalVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localVariableDeclaration
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) LocalVariableType() ILocalVariableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableTypeContext)
}

func (s *LocalVariableDeclarationContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LocalVariableDeclarationContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LocalVariableDeclarationContext) VariableDeclaratorList() IVariableDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorListContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (p *Java20Parser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, Java20ParserRULE_localVariableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserFINAL || _la == Java20ParserAT {
		{
			p.SetState(1717)
			p.VariableModifier()
		}

		p.SetState(1722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1723)
		p.LocalVariableType()
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1724)
			p.VariableDeclaratorList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalVariableTypeContext is an interface to support dynamic dispatch.
type ILocalVariableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	VAR() antlr.TerminalNode

	// IsLocalVariableTypeContext differentiates from other interfaces.
	IsLocalVariableTypeContext()
}

type LocalVariableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableTypeContext() *LocalVariableTypeContext {
	var p = new(LocalVariableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localVariableType
	return p
}

func InitEmptyLocalVariableTypeContext(p *LocalVariableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localVariableType
}

func (*LocalVariableTypeContext) IsLocalVariableTypeContext() {}

func NewLocalVariableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableTypeContext {
	var p = new(LocalVariableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_localVariableType

	return p
}

func (s *LocalVariableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableTypeContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *LocalVariableTypeContext) VAR() antlr.TerminalNode {
	return s.GetToken(Java20ParserVAR, 0)
}

func (s *LocalVariableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLocalVariableType(s)
	}
}

func (s *LocalVariableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLocalVariableType(s)
	}
}

func (p *Java20Parser) LocalVariableType() (localctx ILocalVariableTypeContext) {
	localctx = NewLocalVariableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, Java20ParserRULE_localVariableType)
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1727)
			p.UnannType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1728)
			p.Match(Java20ParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	SEMI() antlr.TerminalNode

	// IsLocalVariableDeclarationStatementContext differentiates from other interfaces.
	IsLocalVariableDeclarationStatementContext()
}

type LocalVariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationStatementContext() *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localVariableDeclarationStatement
	return p
}

func InitEmptyLocalVariableDeclarationStatementContext(p *LocalVariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_localVariableDeclarationStatement
}

func (*LocalVariableDeclarationStatementContext) IsLocalVariableDeclarationStatementContext() {}

func NewLocalVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_localVariableDeclarationStatement

	return p
}

func (s *LocalVariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *LocalVariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLocalVariableDeclarationStatement(s)
	}
}

func (s *LocalVariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLocalVariableDeclarationStatement(s)
	}
}

func (p *Java20Parser) LocalVariableDeclarationStatement() (localctx ILocalVariableDeclarationStatementContext) {
	localctx = NewLocalVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, Java20ParserRULE_localVariableDeclarationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1731)
		p.LocalVariableDeclaration()
	}
	{
		p.SetState(1732)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementWithoutTrailingSubstatement() IStatementWithoutTrailingSubstatementContext
	LabeledStatement() ILabeledStatementContext
	IfThenStatement() IIfThenStatementContext
	IfThenElseStatement() IIfThenElseStatementContext
	WhileStatement() IWhileStatementContext
	ForStatement() IForStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) StatementWithoutTrailingSubstatement() IStatementWithoutTrailingSubstatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementWithoutTrailingSubstatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementWithoutTrailingSubstatementContext)
}

func (s *StatementContext) LabeledStatement() ILabeledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementContext)
}

func (s *StatementContext) IfThenStatement() IIfThenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfThenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfThenStatementContext)
}

func (s *StatementContext) IfThenElseStatement() IIfThenElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfThenElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfThenElseStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *Java20Parser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, Java20ParserRULE_statement)
	p.SetState(1740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1734)
			p.StatementWithoutTrailingSubstatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1735)
			p.LabeledStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1736)
			p.IfThenStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1737)
			p.IfThenElseStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1738)
			p.WhileStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1739)
			p.ForStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementNoShortIfContext is an interface to support dynamic dispatch.
type IStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementWithoutTrailingSubstatement() IStatementWithoutTrailingSubstatementContext
	LabeledStatementNoShortIf() ILabeledStatementNoShortIfContext
	IfThenElseStatementNoShortIf() IIfThenElseStatementNoShortIfContext
	WhileStatementNoShortIf() IWhileStatementNoShortIfContext
	ForStatementNoShortIf() IForStatementNoShortIfContext

	// IsStatementNoShortIfContext differentiates from other interfaces.
	IsStatementNoShortIfContext()
}

type StatementNoShortIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementNoShortIfContext() *StatementNoShortIfContext {
	var p = new(StatementNoShortIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementNoShortIf
	return p
}

func InitEmptyStatementNoShortIfContext(p *StatementNoShortIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementNoShortIf
}

func (*StatementNoShortIfContext) IsStatementNoShortIfContext() {}

func NewStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementNoShortIfContext {
	var p = new(StatementNoShortIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_statementNoShortIf

	return p
}

func (s *StatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementNoShortIfContext) StatementWithoutTrailingSubstatement() IStatementWithoutTrailingSubstatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementWithoutTrailingSubstatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementWithoutTrailingSubstatementContext)
}

func (s *StatementNoShortIfContext) LabeledStatementNoShortIf() ILabeledStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) IfThenElseStatementNoShortIf() IIfThenElseStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfThenElseStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfThenElseStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) WhileStatementNoShortIf() IWhileStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) ForStatementNoShortIf() IForStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementNoShortIfContext)
}

func (s *StatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStatementNoShortIf(s)
	}
}

func (s *StatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStatementNoShortIf(s)
	}
}

func (p *Java20Parser) StatementNoShortIf() (localctx IStatementNoShortIfContext) {
	localctx = NewStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, Java20ParserRULE_statementNoShortIf)
	p.SetState(1747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1742)
			p.StatementWithoutTrailingSubstatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1743)
			p.LabeledStatementNoShortIf()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1744)
			p.IfThenElseStatementNoShortIf()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1745)
			p.WhileStatementNoShortIf()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1746)
			p.ForStatementNoShortIf()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementWithoutTrailingSubstatementContext is an interface to support dynamic dispatch.
type IStatementWithoutTrailingSubstatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	EmptyStatement_() IEmptyStatement_Context
	ExpressionStatement() IExpressionStatementContext
	AssertStatement() IAssertStatementContext
	SwitchStatement() ISwitchStatementContext
	DoStatement() IDoStatementContext
	BreakStatement() IBreakStatementContext
	ContinueStatement() IContinueStatementContext
	ReturnStatement() IReturnStatementContext
	SynchronizedStatement() ISynchronizedStatementContext
	ThrowStatement() IThrowStatementContext
	TryStatement() ITryStatementContext
	YieldStatement() IYieldStatementContext

	// IsStatementWithoutTrailingSubstatementContext differentiates from other interfaces.
	IsStatementWithoutTrailingSubstatementContext()
}

type StatementWithoutTrailingSubstatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementWithoutTrailingSubstatementContext() *StatementWithoutTrailingSubstatementContext {
	var p = new(StatementWithoutTrailingSubstatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementWithoutTrailingSubstatement
	return p
}

func InitEmptyStatementWithoutTrailingSubstatementContext(p *StatementWithoutTrailingSubstatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementWithoutTrailingSubstatement
}

func (*StatementWithoutTrailingSubstatementContext) IsStatementWithoutTrailingSubstatementContext() {}

func NewStatementWithoutTrailingSubstatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementWithoutTrailingSubstatementContext {
	var p = new(StatementWithoutTrailingSubstatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_statementWithoutTrailingSubstatement

	return p
}

func (s *StatementWithoutTrailingSubstatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementWithoutTrailingSubstatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementWithoutTrailingSubstatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementWithoutTrailingSubstatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) AssertStatement() IAssertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) DoStatement() IDoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) SynchronizedStatement() ISynchronizedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISynchronizedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISynchronizedStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) YieldStatement() IYieldStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *StatementWithoutTrailingSubstatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementWithoutTrailingSubstatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementWithoutTrailingSubstatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStatementWithoutTrailingSubstatement(s)
	}
}

func (s *StatementWithoutTrailingSubstatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStatementWithoutTrailingSubstatement(s)
	}
}

func (p *Java20Parser) StatementWithoutTrailingSubstatement() (localctx IStatementWithoutTrailingSubstatementContext) {
	localctx = NewStatementWithoutTrailingSubstatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, Java20ParserRULE_statementWithoutTrailingSubstatement)
	p.SetState(1762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1749)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1750)
			p.EmptyStatement_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1751)
			p.ExpressionStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1752)
			p.AssertStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1753)
			p.SwitchStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1754)
			p.DoStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1755)
			p.BreakStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1756)
			p.ContinueStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1757)
			p.ReturnStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1758)
			p.SynchronizedStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1759)
			p.ThrowStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1760)
			p.TryStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1761)
			p.YieldStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (p *Java20Parser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, Java20ParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledStatementContext is an interface to support dynamic dispatch.
type ILabeledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsLabeledStatementContext differentiates from other interfaces.
	IsLabeledStatementContext()
}

type LabeledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementContext() *LabeledStatementContext {
	var p = new(LabeledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_labeledStatement
	return p
}

func InitEmptyLabeledStatementContext(p *LabeledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_labeledStatement
}

func (*LabeledStatementContext) IsLabeledStatementContext() {}

func NewLabeledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementContext {
	var p = new(LabeledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_labeledStatement

	return p
}

func (s *LabeledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, 0)
}

func (s *LabeledStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLabeledStatement(s)
	}
}

func (s *LabeledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLabeledStatement(s)
	}
}

func (p *Java20Parser) LabeledStatement() (localctx ILabeledStatementContext) {
	localctx = NewLabeledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, Java20ParserRULE_labeledStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1766)
		p.Identifier()
	}
	{
		p.SetState(1767)
		p.Match(Java20ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1768)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledStatementNoShortIfContext is an interface to support dynamic dispatch.
type ILabeledStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	StatementNoShortIf() IStatementNoShortIfContext

	// IsLabeledStatementNoShortIfContext differentiates from other interfaces.
	IsLabeledStatementNoShortIfContext()
}

type LabeledStatementNoShortIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementNoShortIfContext() *LabeledStatementNoShortIfContext {
	var p = new(LabeledStatementNoShortIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_labeledStatementNoShortIf
	return p
}

func InitEmptyLabeledStatementNoShortIfContext(p *LabeledStatementNoShortIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_labeledStatementNoShortIf
}

func (*LabeledStatementNoShortIfContext) IsLabeledStatementNoShortIfContext() {}

func NewLabeledStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementNoShortIfContext {
	var p = new(LabeledStatementNoShortIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_labeledStatementNoShortIf

	return p
}

func (s *LabeledStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementNoShortIfContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStatementNoShortIfContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, 0)
}

func (s *LabeledStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *LabeledStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLabeledStatementNoShortIf(s)
	}
}

func (s *LabeledStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLabeledStatementNoShortIf(s)
	}
}

func (p *Java20Parser) LabeledStatementNoShortIf() (localctx ILabeledStatementNoShortIfContext) {
	localctx = NewLabeledStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, Java20ParserRULE_labeledStatementNoShortIf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1770)
		p.Identifier()
	}
	{
		p.SetState(1771)
		p.Match(Java20ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1772)
		p.StatementNoShortIf()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementExpression() IStatementExpressionContext
	SEMI() antlr.TerminalNode

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) StatementExpression() IStatementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *ExpressionStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *Java20Parser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, Java20ParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1774)
		p.StatementExpression()
	}
	{
		p.SetState(1775)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementExpressionContext is an interface to support dynamic dispatch.
type IStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment() IAssignmentContext
	PreIncrementExpression() IPreIncrementExpressionContext
	PreDecrementExpression() IPreDecrementExpressionContext
	PostIncrementExpression() IPostIncrementExpressionContext
	PostDecrementExpression() IPostDecrementExpressionContext
	MethodInvocation() IMethodInvocationContext
	ClassInstanceCreationExpression() IClassInstanceCreationExpressionContext

	// IsStatementExpressionContext differentiates from other interfaces.
	IsStatementExpressionContext()
}

type StatementExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionContext() *StatementExpressionContext {
	var p = new(StatementExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementExpression
	return p
}

func InitEmptyStatementExpressionContext(p *StatementExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementExpression
}

func (*StatementExpressionContext) IsStatementExpressionContext() {}

func NewStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionContext {
	var p = new(StatementExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_statementExpression

	return p
}

func (s *StatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *StatementExpressionContext) PreIncrementExpression() IPreIncrementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreIncrementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreIncrementExpressionContext)
}

func (s *StatementExpressionContext) PreDecrementExpression() IPreDecrementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreDecrementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreDecrementExpressionContext)
}

func (s *StatementExpressionContext) PostIncrementExpression() IPostIncrementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostIncrementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostIncrementExpressionContext)
}

func (s *StatementExpressionContext) PostDecrementExpression() IPostDecrementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostDecrementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostDecrementExpressionContext)
}

func (s *StatementExpressionContext) MethodInvocation() IMethodInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodInvocationContext)
}

func (s *StatementExpressionContext) ClassInstanceCreationExpression() IClassInstanceCreationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassInstanceCreationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassInstanceCreationExpressionContext)
}

func (s *StatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStatementExpression(s)
	}
}

func (s *StatementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStatementExpression(s)
	}
}

func (p *Java20Parser) StatementExpression() (localctx IStatementExpressionContext) {
	localctx = NewStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, Java20ParserRULE_statementExpression)
	p.SetState(1784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1777)
			p.Assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1778)
			p.PreIncrementExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1779)
			p.PreDecrementExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1780)
			p.PostIncrementExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1781)
			p.PostDecrementExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1782)
			p.MethodInvocation()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1783)
			p.ClassInstanceCreationExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfThenStatementContext is an interface to support dynamic dispatch.
type IIfThenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	Statement() IStatementContext

	// IsIfThenStatementContext differentiates from other interfaces.
	IsIfThenStatementContext()
}

type IfThenStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenStatementContext() *IfThenStatementContext {
	var p = new(IfThenStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ifThenStatement
	return p
}

func InitEmptyIfThenStatementContext(p *IfThenStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ifThenStatement
}

func (*IfThenStatementContext) IsIfThenStatementContext() {}

func NewIfThenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenStatementContext {
	var p = new(IfThenStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_ifThenStatement

	return p
}

func (s *IfThenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(Java20ParserIF, 0)
}

func (s *IfThenStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *IfThenStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfThenStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *IfThenStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfThenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterIfThenStatement(s)
	}
}

func (s *IfThenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitIfThenStatement(s)
	}
}

func (p *Java20Parser) IfThenStatement() (localctx IIfThenStatementContext) {
	localctx = NewIfThenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, Java20ParserRULE_ifThenStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1786)
		p.Match(Java20ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1787)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1788)
		p.Expression()
	}
	{
		p.SetState(1789)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1790)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfThenElseStatementContext is an interface to support dynamic dispatch.
type IIfThenElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	StatementNoShortIf() IStatementNoShortIfContext
	ELSE() antlr.TerminalNode
	Statement() IStatementContext

	// IsIfThenElseStatementContext differentiates from other interfaces.
	IsIfThenElseStatementContext()
}

type IfThenElseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenElseStatementContext() *IfThenElseStatementContext {
	var p = new(IfThenElseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ifThenElseStatement
	return p
}

func InitEmptyIfThenElseStatementContext(p *IfThenElseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ifThenElseStatement
}

func (*IfThenElseStatementContext) IsIfThenElseStatementContext() {}

func NewIfThenElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenElseStatementContext {
	var p = new(IfThenElseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_ifThenElseStatement

	return p
}

func (s *IfThenElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenElseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(Java20ParserIF, 0)
}

func (s *IfThenElseStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *IfThenElseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfThenElseStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *IfThenElseStatementContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *IfThenElseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Java20ParserELSE, 0)
}

func (s *IfThenElseStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfThenElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterIfThenElseStatement(s)
	}
}

func (s *IfThenElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitIfThenElseStatement(s)
	}
}

func (p *Java20Parser) IfThenElseStatement() (localctx IIfThenElseStatementContext) {
	localctx = NewIfThenElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, Java20ParserRULE_ifThenElseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1792)
		p.Match(Java20ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1793)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1794)
		p.Expression()
	}
	{
		p.SetState(1795)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1796)
		p.StatementNoShortIf()
	}
	{
		p.SetState(1797)
		p.Match(Java20ParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1798)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfThenElseStatementNoShortIfContext is an interface to support dynamic dispatch.
type IIfThenElseStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllStatementNoShortIf() []IStatementNoShortIfContext
	StatementNoShortIf(i int) IStatementNoShortIfContext
	ELSE() antlr.TerminalNode

	// IsIfThenElseStatementNoShortIfContext differentiates from other interfaces.
	IsIfThenElseStatementNoShortIfContext()
}

type IfThenElseStatementNoShortIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenElseStatementNoShortIfContext() *IfThenElseStatementNoShortIfContext {
	var p = new(IfThenElseStatementNoShortIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ifThenElseStatementNoShortIf
	return p
}

func InitEmptyIfThenElseStatementNoShortIfContext(p *IfThenElseStatementNoShortIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_ifThenElseStatementNoShortIf
}

func (*IfThenElseStatementNoShortIfContext) IsIfThenElseStatementNoShortIfContext() {}

func NewIfThenElseStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenElseStatementNoShortIfContext {
	var p = new(IfThenElseStatementNoShortIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_ifThenElseStatementNoShortIf

	return p
}

func (s *IfThenElseStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenElseStatementNoShortIfContext) IF() antlr.TerminalNode {
	return s.GetToken(Java20ParserIF, 0)
}

func (s *IfThenElseStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *IfThenElseStatementNoShortIfContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfThenElseStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *IfThenElseStatementNoShortIfContext) AllStatementNoShortIf() []IStatementNoShortIfContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementNoShortIfContext); ok {
			len++
		}
	}

	tst := make([]IStatementNoShortIfContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementNoShortIfContext); ok {
			tst[i] = t.(IStatementNoShortIfContext)
			i++
		}
	}

	return tst
}

func (s *IfThenElseStatementNoShortIfContext) StatementNoShortIf(i int) IStatementNoShortIfContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementNoShortIfContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *IfThenElseStatementNoShortIfContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Java20ParserELSE, 0)
}

func (s *IfThenElseStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenElseStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenElseStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterIfThenElseStatementNoShortIf(s)
	}
}

func (s *IfThenElseStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitIfThenElseStatementNoShortIf(s)
	}
}

func (p *Java20Parser) IfThenElseStatementNoShortIf() (localctx IIfThenElseStatementNoShortIfContext) {
	localctx = NewIfThenElseStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, Java20ParserRULE_ifThenElseStatementNoShortIf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1800)
		p.Match(Java20ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1801)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1802)
		p.Expression()
	}
	{
		p.SetState(1803)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1804)
		p.StatementNoShortIf()
	}
	{
		p.SetState(1805)
		p.Match(Java20ParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1806)
		p.StatementNoShortIf()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSERT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SEMI() antlr.TerminalNode
	COLON() antlr.TerminalNode

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assertStatement
	return p
}

func InitEmptyAssertStatementContext(p *AssertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assertStatement
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(Java20ParserASSERT, 0)
}

func (s *AssertStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssertStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *AssertStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, 0)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAssertStatement(s)
	}
}

func (s *AssertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAssertStatement(s)
	}
}

func (p *Java20Parser) AssertStatement() (localctx IAssertStatementContext) {
	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, Java20ParserRULE_assertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1808)
		p.Match(Java20ParserASSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1809)
		p.Expression()
	}
	p.SetState(1812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserCOLON {
		{
			p.SetState(1810)
			p.Match(Java20ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1811)
			p.Expression()
		}

	}
	{
		p.SetState(1814)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	SwitchBlock() ISwitchBlockContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(Java20ParserSWITCH, 0)
}

func (s *SwitchStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *SwitchStatementContext) SwitchBlock() ISwitchBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *Java20Parser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, Java20ParserRULE_switchStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.Match(Java20ParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1817)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1818)
		p.Expression()
	}
	{
		p.SetState(1819)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1820)
		p.SwitchBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchBlockContext is an interface to support dynamic dispatch.
type ISwitchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllSwitchRule() []ISwitchRuleContext
	SwitchRule(i int) ISwitchRuleContext
	RBRACE() antlr.TerminalNode
	AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext
	SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext
	AllSwitchLabel() []ISwitchLabelContext
	SwitchLabel(i int) ISwitchLabelContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode

	// IsSwitchBlockContext differentiates from other interfaces.
	IsSwitchBlockContext()
}

type SwitchBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockContext() *SwitchBlockContext {
	var p = new(SwitchBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchBlock
	return p
}

func InitEmptySwitchBlockContext(p *SwitchBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchBlock
}

func (*SwitchBlockContext) IsSwitchBlockContext() {}

func NewSwitchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockContext {
	var p = new(SwitchBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_switchBlock

	return p
}

func (s *SwitchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACE, 0)
}

func (s *SwitchBlockContext) AllSwitchRule() []ISwitchRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchRuleContext); ok {
			len++
		}
	}

	tst := make([]ISwitchRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchRuleContext); ok {
			tst[i] = t.(ISwitchRuleContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockContext) SwitchRule(i int) ISwitchRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchRuleContext)
}

func (s *SwitchBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACE, 0)
}

func (s *SwitchBlockContext) AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			len++
		}
	}

	tst := make([]ISwitchBlockStatementGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			tst[i] = t.(ISwitchBlockStatementGroupContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockContext) SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupContext)
}

func (s *SwitchBlockContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOLON)
}

func (s *SwitchBlockContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, i)
}

func (s *SwitchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSwitchBlock(s)
	}
}

func (s *SwitchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSwitchBlock(s)
	}
}

func (p *Java20Parser) SwitchBlock() (localctx ISwitchBlockContext) {
	localctx = NewSwitchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, Java20ParserRULE_switchBlock)
	var _la int

	var _alt int

	p.SetState(1848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1822)
			p.Match(Java20ParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1823)
			p.SwitchRule()
		}
		p.SetState(1827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserCASE || _la == Java20ParserDEFAULT {
			{
				p.SetState(1824)
				p.SwitchRule()
			}

			p.SetState(1829)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1830)
			p.Match(Java20ParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1832)
			p.Match(Java20ParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1833)
					p.SwitchBlockStatementGroup()
				}

			}
			p.SetState(1838)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserCASE || _la == Java20ParserDEFAULT {
			{
				p.SetState(1839)
				p.SwitchLabel()
			}
			{
				p.SetState(1840)
				p.Match(Java20ParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1846)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1847)
			p.Match(Java20ParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchRuleContext is an interface to support dynamic dispatch.
type ISwitchRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SwitchLabel() ISwitchLabelContext
	ARROW() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	Block() IBlockContext
	ThrowStatement() IThrowStatementContext

	// IsSwitchRuleContext differentiates from other interfaces.
	IsSwitchRuleContext()
}

type SwitchRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchRuleContext() *SwitchRuleContext {
	var p = new(SwitchRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchRule
	return p
}

func InitEmptySwitchRuleContext(p *SwitchRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchRule
}

func (*SwitchRuleContext) IsSwitchRuleContext() {}

func NewSwitchRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchRuleContext {
	var p = new(SwitchRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_switchRule

	return p
}

func (s *SwitchRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchRuleContext) SwitchLabel() ISwitchLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchRuleContext) ARROW() antlr.TerminalNode {
	return s.GetToken(Java20ParserARROW, 0)
}

func (s *SwitchRuleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchRuleContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *SwitchRuleContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SwitchRuleContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *SwitchRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSwitchRule(s)
	}
}

func (s *SwitchRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSwitchRule(s)
	}
}

func (p *Java20Parser) SwitchRule() (localctx ISwitchRuleContext) {
	localctx = NewSwitchRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, Java20ParserRULE_switchRule)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1850)
		p.SwitchLabel()
	}
	{
		p.SetState(1851)
		p.Match(Java20ParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD, Java20ParserBOOLEAN, Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserNEW, Java20ParserSHORT, Java20ParserSUPER, Java20ParserSWITCH, Java20ParserTHIS, Java20ParserVOID, Java20ParserIntegerLiteral, Java20ParserFloatingPointLiteral, Java20ParserBooleanLiteral, Java20ParserCharacterLiteral, Java20ParserStringLiteral, Java20ParserTextBlock, Java20ParserNullLiteral, Java20ParserLPAREN, Java20ParserAT, Java20ParserBANG, Java20ParserTILDE, Java20ParserINC, Java20ParserDEC, Java20ParserADD, Java20ParserSUB, Java20ParserIdentifier:
		{
			p.SetState(1852)
			p.Expression()
		}
		{
			p.SetState(1853)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserLBRACE:
		{
			p.SetState(1855)
			p.Block()
		}

	case Java20ParserTHROW:
		{
			p.SetState(1856)
			p.ThrowStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchBlockStatementGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSwitchLabel() []ISwitchLabelContext
	SwitchLabel(i int) ISwitchLabelContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	BlockStatements() IBlockStatementsContext

	// IsSwitchBlockStatementGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupContext()
}

type SwitchBlockStatementGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupContext() *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchBlockStatementGroup
	return p
}

func InitEmptySwitchBlockStatementGroupContext(p *SwitchBlockStatementGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchBlockStatementGroup
}

func (*SwitchBlockStatementGroupContext) IsSwitchBlockStatementGroupContext() {}

func NewSwitchBlockStatementGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_switchBlockStatementGroup

	return p
}

func (s *SwitchBlockStatementGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockStatementGroupContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOLON)
}

func (s *SwitchBlockStatementGroupContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, i)
}

func (s *SwitchBlockStatementGroupContext) BlockStatements() IBlockStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *SwitchBlockStatementGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSwitchBlockStatementGroup(s)
	}
}

func (s *SwitchBlockStatementGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSwitchBlockStatementGroup(s)
	}
}

func (p *Java20Parser) SwitchBlockStatementGroup() (localctx ISwitchBlockStatementGroupContext) {
	localctx = NewSwitchBlockStatementGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, Java20ParserRULE_switchBlockStatementGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1859)
		p.SwitchLabel()
	}
	{
		p.SetState(1860)
		p.Match(Java20ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCASE || _la == Java20ParserDEFAULT {
		{
			p.SetState(1861)
			p.SwitchLabel()
		}
		{
			p.SetState(1862)
			p.Match(Java20ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1869)
		p.BlockStatements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	AllCaseConstant() []ICaseConstantContext
	CaseConstant(i int) ICaseConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchLabel
	return p
}

func InitEmptySwitchLabelContext(p *SwitchLabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchLabel
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(Java20ParserCASE, 0)
}

func (s *SwitchLabelContext) AllCaseConstant() []ICaseConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseConstantContext); ok {
			len++
		}
	}

	tst := make([]ICaseConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseConstantContext); ok {
			tst[i] = t.(ICaseConstantContext)
			i++
		}
	}

	return tst
}

func (s *SwitchLabelContext) CaseConstant(i int) ICaseConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseConstantContext)
}

func (s *SwitchLabelContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *SwitchLabelContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSwitchLabel(s)
	}
}

func (p *Java20Parser) SwitchLabel() (localctx ISwitchLabelContext) {
	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, Java20ParserRULE_switchLabel)
	var _la int

	p.SetState(1881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1871)
			p.Match(Java20ParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1872)
			p.CaseConstant()
		}
		p.SetState(1877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserCOMMA {
			{
				p.SetState(1873)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1874)
				p.CaseConstant()
			}

			p.SetState(1879)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case Java20ParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1880)
			p.Match(Java20ParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseConstantContext is an interface to support dynamic dispatch.
type ICaseConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalExpression() IConditionalExpressionContext

	// IsCaseConstantContext differentiates from other interfaces.
	IsCaseConstantContext()
}

type CaseConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseConstantContext() *CaseConstantContext {
	var p = new(CaseConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_caseConstant
	return p
}

func InitEmptyCaseConstantContext(p *CaseConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_caseConstant
}

func (*CaseConstantContext) IsCaseConstantContext() {}

func NewCaseConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseConstantContext {
	var p = new(CaseConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_caseConstant

	return p
}

func (s *CaseConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseConstantContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *CaseConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCaseConstant(s)
	}
}

func (s *CaseConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCaseConstant(s)
	}
}

func (p *Java20Parser) CaseConstant() (localctx ICaseConstantContext) {
	localctx = NewCaseConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, Java20ParserRULE_caseConstant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1883)
		p.ConditionalExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Java20ParserWHILE, 0)
}

func (s *WhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *Java20Parser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, Java20ParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1885)
		p.Match(Java20ParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1886)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1887)
		p.Expression()
	}
	{
		p.SetState(1888)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1889)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementNoShortIfContext is an interface to support dynamic dispatch.
type IWhileStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	StatementNoShortIf() IStatementNoShortIfContext

	// IsWhileStatementNoShortIfContext differentiates from other interfaces.
	IsWhileStatementNoShortIfContext()
}

type WhileStatementNoShortIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementNoShortIfContext() *WhileStatementNoShortIfContext {
	var p = new(WhileStatementNoShortIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_whileStatementNoShortIf
	return p
}

func InitEmptyWhileStatementNoShortIfContext(p *WhileStatementNoShortIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_whileStatementNoShortIf
}

func (*WhileStatementNoShortIfContext) IsWhileStatementNoShortIfContext() {}

func NewWhileStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementNoShortIfContext {
	var p = new(WhileStatementNoShortIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_whileStatementNoShortIf

	return p
}

func (s *WhileStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementNoShortIfContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Java20ParserWHILE, 0)
}

func (s *WhileStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *WhileStatementNoShortIfContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *WhileStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *WhileStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterWhileStatementNoShortIf(s)
	}
}

func (s *WhileStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitWhileStatementNoShortIf(s)
	}
}

func (p *Java20Parser) WhileStatementNoShortIf() (localctx IWhileStatementNoShortIfContext) {
	localctx = NewWhileStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, Java20ParserRULE_whileStatementNoShortIf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1891)
		p.Match(Java20ParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1892)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1893)
		p.Expression()
	}
	{
		p.SetState(1894)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1895)
		p.StatementNoShortIf()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Statement() IStatementContext
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_doStatement
	return p
}

func InitEmptyDoStatementContext(p *DoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_doStatement
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(Java20ParserDO, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Java20ParserWHILE, 0)
}

func (s *DoStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *DoStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *DoStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (p *Java20Parser) DoStatement() (localctx IDoStatementContext) {
	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, Java20ParserRULE_doStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1897)
		p.Match(Java20ParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1898)
		p.Statement()
	}
	{
		p.SetState(1899)
		p.Match(Java20ParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1900)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1901)
		p.Expression()
	}
	{
		p.SetState(1902)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1903)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BasicForStatement() IBasicForStatementContext
	EnhancedForStatement() IEnhancedForStatementContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) BasicForStatement() IBasicForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicForStatementContext)
}

func (s *ForStatementContext) EnhancedForStatement() IEnhancedForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForStatementContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *Java20Parser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, Java20ParserRULE_forStatement)
	p.SetState(1907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1905)
			p.BasicForStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1906)
			p.EnhancedForStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementNoShortIfContext is an interface to support dynamic dispatch.
type IForStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BasicForStatementNoShortIf() IBasicForStatementNoShortIfContext
	EnhancedForStatementNoShortIf() IEnhancedForStatementNoShortIfContext

	// IsForStatementNoShortIfContext differentiates from other interfaces.
	IsForStatementNoShortIfContext()
}

type ForStatementNoShortIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementNoShortIfContext() *ForStatementNoShortIfContext {
	var p = new(ForStatementNoShortIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forStatementNoShortIf
	return p
}

func InitEmptyForStatementNoShortIfContext(p *ForStatementNoShortIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forStatementNoShortIf
}

func (*ForStatementNoShortIfContext) IsForStatementNoShortIfContext() {}

func NewForStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementNoShortIfContext {
	var p = new(ForStatementNoShortIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_forStatementNoShortIf

	return p
}

func (s *ForStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementNoShortIfContext) BasicForStatementNoShortIf() IBasicForStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasicForStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasicForStatementNoShortIfContext)
}

func (s *ForStatementNoShortIfContext) EnhancedForStatementNoShortIf() IEnhancedForStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForStatementNoShortIfContext)
}

func (s *ForStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterForStatementNoShortIf(s)
	}
}

func (s *ForStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitForStatementNoShortIf(s)
	}
}

func (p *Java20Parser) ForStatementNoShortIf() (localctx IForStatementNoShortIfContext) {
	localctx = NewForStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, Java20ParserRULE_forStatementNoShortIf)
	p.SetState(1911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1909)
			p.BasicForStatementNoShortIf()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1910)
			p.EnhancedForStatementNoShortIf()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBasicForStatementContext is an interface to support dynamic dispatch.
type IBasicForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Statement() IStatementContext
	ForInit() IForInitContext
	Expression() IExpressionContext
	ForUpdate() IForUpdateContext

	// IsBasicForStatementContext differentiates from other interfaces.
	IsBasicForStatementContext()
}

type BasicForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicForStatementContext() *BasicForStatementContext {
	var p = new(BasicForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_basicForStatement
	return p
}

func InitEmptyBasicForStatementContext(p *BasicForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_basicForStatement
}

func (*BasicForStatementContext) IsBasicForStatementContext() {}

func NewBasicForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicForStatementContext {
	var p = new(BasicForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_basicForStatement

	return p
}

func (s *BasicForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java20ParserFOR, 0)
}

func (s *BasicForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *BasicForStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserSEMI)
}

func (s *BasicForStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, i)
}

func (s *BasicForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *BasicForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BasicForStatementContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *BasicForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BasicForStatementContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *BasicForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasicForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterBasicForStatement(s)
	}
}

func (s *BasicForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitBasicForStatement(s)
	}
}

func (p *Java20Parser) BasicForStatement() (localctx IBasicForStatementContext) {
	localctx = NewBasicForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, Java20ParserRULE_basicForStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1913)
		p.Match(Java20ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1914)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1315420701084352494) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230788470673393) != 0) {
		{
			p.SetState(1915)
			p.ForInit()
		}

	}
	{
		p.SetState(1918)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
		{
			p.SetState(1919)
			p.Expression()
		}

	}
	{
		p.SetState(1922)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1315420666724614126) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230788470673393) != 0) {
		{
			p.SetState(1923)
			p.ForUpdate()
		}

	}
	{
		p.SetState(1926)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1927)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBasicForStatementNoShortIfContext is an interface to support dynamic dispatch.
type IBasicForStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	StatementNoShortIf() IStatementNoShortIfContext
	ForInit() IForInitContext
	Expression() IExpressionContext
	ForUpdate() IForUpdateContext

	// IsBasicForStatementNoShortIfContext differentiates from other interfaces.
	IsBasicForStatementNoShortIfContext()
}

type BasicForStatementNoShortIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicForStatementNoShortIfContext() *BasicForStatementNoShortIfContext {
	var p = new(BasicForStatementNoShortIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_basicForStatementNoShortIf
	return p
}

func InitEmptyBasicForStatementNoShortIfContext(p *BasicForStatementNoShortIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_basicForStatementNoShortIf
}

func (*BasicForStatementNoShortIfContext) IsBasicForStatementNoShortIfContext() {}

func NewBasicForStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicForStatementNoShortIfContext {
	var p = new(BasicForStatementNoShortIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_basicForStatementNoShortIf

	return p
}

func (s *BasicForStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicForStatementNoShortIfContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java20ParserFOR, 0)
}

func (s *BasicForStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *BasicForStatementNoShortIfContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserSEMI)
}

func (s *BasicForStatementNoShortIfContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, i)
}

func (s *BasicForStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *BasicForStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *BasicForStatementNoShortIfContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *BasicForStatementNoShortIfContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BasicForStatementNoShortIfContext) ForUpdate() IForUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *BasicForStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicForStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasicForStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterBasicForStatementNoShortIf(s)
	}
}

func (s *BasicForStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitBasicForStatementNoShortIf(s)
	}
}

func (p *Java20Parser) BasicForStatementNoShortIf() (localctx IBasicForStatementNoShortIfContext) {
	localctx = NewBasicForStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, Java20ParserRULE_basicForStatementNoShortIf)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1929)
		p.Match(Java20ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1930)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1315420701084352494) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230788470673393) != 0) {
		{
			p.SetState(1931)
			p.ForInit()
		}

	}
	{
		p.SetState(1934)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
		{
			p.SetState(1935)
			p.Expression()
		}

	}
	{
		p.SetState(1938)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1315420666724614126) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288230788470673393) != 0) {
		{
			p.SetState(1939)
			p.ForUpdate()
		}

	}
	{
		p.SetState(1942)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1943)
		p.StatementNoShortIf()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementExpressionList() IStatementExpressionListContext
	LocalVariableDeclaration() ILocalVariableDeclarationContext

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) StatementExpressionList() IStatementExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionListContext)
}

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (p *Java20Parser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, Java20ParserRULE_forInit)
	p.SetState(1947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1945)
			p.StatementExpressionList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1946)
			p.LocalVariableDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementExpressionList() IStatementExpressionListContext

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forUpdate
	return p
}

func InitEmptyForUpdateContext(p *ForUpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_forUpdate
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) StatementExpressionList() IStatementExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterForUpdate(s)
	}
}

func (s *ForUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitForUpdate(s)
	}
}

func (p *Java20Parser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, Java20ParserRULE_forUpdate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1949)
		p.StatementExpressionList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementExpressionListContext is an interface to support dynamic dispatch.
type IStatementExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatementExpression() []IStatementExpressionContext
	StatementExpression(i int) IStatementExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStatementExpressionListContext differentiates from other interfaces.
	IsStatementExpressionListContext()
}

type StatementExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionListContext() *StatementExpressionListContext {
	var p = new(StatementExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementExpressionList
	return p
}

func InitEmptyStatementExpressionListContext(p *StatementExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_statementExpressionList
}

func (*StatementExpressionListContext) IsStatementExpressionListContext() {}

func NewStatementExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionListContext {
	var p = new(StatementExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_statementExpressionList

	return p
}

func (s *StatementExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionListContext) AllStatementExpression() []IStatementExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			len++
		}
	}

	tst := make([]IStatementExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementExpressionContext); ok {
			tst[i] = t.(IStatementExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StatementExpressionListContext) StatementExpression(i int) IStatementExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *StatementExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *StatementExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *StatementExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterStatementExpressionList(s)
	}
}

func (s *StatementExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitStatementExpressionList(s)
	}
}

func (p *Java20Parser) StatementExpressionList() (localctx IStatementExpressionListContext) {
	localctx = NewStatementExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, Java20ParserRULE_statementExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1951)
		p.StatementExpression()
	}
	p.SetState(1956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(1952)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1953)
			p.StatementExpression()
		}

		p.SetState(1958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedForStatementContext is an interface to support dynamic dispatch.
type IEnhancedForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	Statement() IStatementContext

	// IsEnhancedForStatementContext differentiates from other interfaces.
	IsEnhancedForStatementContext()
}

type EnhancedForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForStatementContext() *EnhancedForStatementContext {
	var p = new(EnhancedForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enhancedForStatement
	return p
}

func InitEmptyEnhancedForStatementContext(p *EnhancedForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enhancedForStatement
}

func (*EnhancedForStatementContext) IsEnhancedForStatementContext() {}

func NewEnhancedForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForStatementContext {
	var p = new(EnhancedForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enhancedForStatement

	return p
}

func (s *EnhancedForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java20ParserFOR, 0)
}

func (s *EnhancedForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *EnhancedForStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *EnhancedForStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, 0)
}

func (s *EnhancedForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *EnhancedForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EnhancedForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnhancedForStatement(s)
	}
}

func (s *EnhancedForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnhancedForStatement(s)
	}
}

func (p *Java20Parser) EnhancedForStatement() (localctx IEnhancedForStatementContext) {
	localctx = NewEnhancedForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, Java20ParserRULE_enhancedForStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1959)
		p.Match(Java20ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1960)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1961)
		p.LocalVariableDeclaration()
	}
	{
		p.SetState(1962)
		p.Match(Java20ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1963)
		p.Expression()
	}
	{
		p.SetState(1964)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1965)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedForStatementNoShortIfContext is an interface to support dynamic dispatch.
type IEnhancedForStatementNoShortIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	StatementNoShortIf() IStatementNoShortIfContext

	// IsEnhancedForStatementNoShortIfContext differentiates from other interfaces.
	IsEnhancedForStatementNoShortIfContext()
}

type EnhancedForStatementNoShortIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForStatementNoShortIfContext() *EnhancedForStatementNoShortIfContext {
	var p = new(EnhancedForStatementNoShortIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enhancedForStatementNoShortIf
	return p
}

func InitEmptyEnhancedForStatementNoShortIfContext(p *EnhancedForStatementNoShortIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_enhancedForStatementNoShortIf
}

func (*EnhancedForStatementNoShortIfContext) IsEnhancedForStatementNoShortIfContext() {}

func NewEnhancedForStatementNoShortIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForStatementNoShortIfContext {
	var p = new(EnhancedForStatementNoShortIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_enhancedForStatementNoShortIf

	return p
}

func (s *EnhancedForStatementNoShortIfContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForStatementNoShortIfContext) FOR() antlr.TerminalNode {
	return s.GetToken(Java20ParserFOR, 0)
}

func (s *EnhancedForStatementNoShortIfContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *EnhancedForStatementNoShortIfContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *EnhancedForStatementNoShortIfContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, 0)
}

func (s *EnhancedForStatementNoShortIfContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForStatementNoShortIfContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *EnhancedForStatementNoShortIfContext) StatementNoShortIf() IStatementNoShortIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementNoShortIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementNoShortIfContext)
}

func (s *EnhancedForStatementNoShortIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForStatementNoShortIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForStatementNoShortIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEnhancedForStatementNoShortIf(s)
	}
}

func (s *EnhancedForStatementNoShortIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEnhancedForStatementNoShortIf(s)
	}
}

func (p *Java20Parser) EnhancedForStatementNoShortIf() (localctx IEnhancedForStatementNoShortIfContext) {
	localctx = NewEnhancedForStatementNoShortIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, Java20ParserRULE_enhancedForStatementNoShortIf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1967)
		p.Match(Java20ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1968)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1969)
		p.LocalVariableDeclaration()
	}
	{
		p.SetState(1970)
		p.Match(Java20ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1971)
		p.Expression()
	}
	{
		p.SetState(1972)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1973)
		p.StatementNoShortIf()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(Java20ParserBREAK, 0)
}

func (s *BreakStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *Java20Parser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, Java20ParserRULE_breakStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1975)
		p.Match(Java20ParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262126) != 0) || _la == Java20ParserIdentifier {
		{
			p.SetState(1976)
			p.Identifier()
		}

	}
	{
		p.SetState(1979)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Java20ParserCONTINUE, 0)
}

func (s *ContinueStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *Java20Parser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, Java20ParserRULE_continueStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1981)
		p.Match(Java20ParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262126) != 0) || _la == Java20ParserIdentifier {
		{
			p.SetState(1982)
			p.Identifier()
		}

	}
	{
		p.SetState(1985)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRETURN, 0)
}

func (s *ReturnStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *Java20Parser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, Java20ParserRULE_returnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1987)
		p.Match(Java20ParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
		{
			p.SetState(1988)
			p.Expression()
		}

	}
	{
		p.SetState(1991)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THROW() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(Java20ParserTHROW, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *Java20Parser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, Java20ParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1993)
		p.Match(Java20ParserTHROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1994)
		p.Expression()
	}
	{
		p.SetState(1995)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISynchronizedStatementContext is an interface to support dynamic dispatch.
type ISynchronizedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYNCHRONIZED() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext

	// IsSynchronizedStatementContext differentiates from other interfaces.
	IsSynchronizedStatementContext()
}

type SynchronizedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynchronizedStatementContext() *SynchronizedStatementContext {
	var p = new(SynchronizedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_synchronizedStatement
	return p
}

func InitEmptySynchronizedStatementContext(p *SynchronizedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_synchronizedStatement
}

func (*SynchronizedStatementContext) IsSynchronizedStatementContext() {}

func NewSynchronizedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SynchronizedStatementContext {
	var p = new(SynchronizedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_synchronizedStatement

	return p
}

func (s *SynchronizedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SynchronizedStatementContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(Java20ParserSYNCHRONIZED, 0)
}

func (s *SynchronizedStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *SynchronizedStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SynchronizedStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *SynchronizedStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SynchronizedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SynchronizedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SynchronizedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSynchronizedStatement(s)
	}
}

func (s *SynchronizedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSynchronizedStatement(s)
	}
}

func (p *Java20Parser) SynchronizedStatement() (localctx ISynchronizedStatementContext) {
	localctx = NewSynchronizedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, Java20ParserRULE_synchronizedStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1997)
		p.Match(Java20ParserSYNCHRONIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1998)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1999)
		p.Expression()
	}
	{
		p.SetState(2000)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2001)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Block() IBlockContext
	Catches() ICatchesContext
	FinallyBlock() IFinallyBlockContext
	TryWithResourcesStatement() ITryWithResourcesStatementContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(Java20ParserTRY, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) Catches() ICatchesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchesContext)
}

func (s *TryStatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryStatementContext) TryWithResourcesStatement() ITryWithResourcesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryWithResourcesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryWithResourcesStatementContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *Java20Parser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, Java20ParserRULE_tryStatement)
	var _la int

	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2003)
			p.Match(Java20ParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2004)
			p.Block()
		}
		{
			p.SetState(2005)
			p.Catches()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2007)
			p.Match(Java20ParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Block()
		}
		{
			p.SetState(2009)
			p.FinallyBlock()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2011)
			p.Match(Java20ParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2012)
			p.Block()
		}
		p.SetState(2014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserCATCH {
			{
				p.SetState(2013)
				p.Catches()
			}

		}
		{
			p.SetState(2016)
			p.FinallyBlock()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2018)
			p.TryWithResourcesStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchesContext is an interface to support dynamic dispatch.
type ICatchesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext

	// IsCatchesContext differentiates from other interfaces.
	IsCatchesContext()
}

type CatchesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchesContext() *CatchesContext {
	var p = new(CatchesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catches
	return p
}

func InitEmptyCatchesContext(p *CatchesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catches
}

func (*CatchesContext) IsCatchesContext() {}

func NewCatchesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchesContext {
	var p = new(CatchesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_catches

	return p
}

func (s *CatchesContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchesContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *CatchesContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *CatchesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCatches(s)
	}
}

func (s *CatchesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCatches(s)
	}
}

func (p *Java20Parser) Catches() (localctx ICatchesContext) {
	localctx = NewCatchesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, Java20ParserRULE_catches)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2021)
		p.CatchClause()
	}
	p.SetState(2025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCATCH {
		{
			p.SetState(2022)
			p.CatchClause()
		}

		p.SetState(2027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	CatchFormalParameter() ICatchFormalParameterContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(Java20ParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *CatchClauseContext) CatchFormalParameter() ICatchFormalParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchFormalParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchFormalParameterContext)
}

func (s *CatchClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *Java20Parser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, Java20ParserRULE_catchClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2028)
		p.Match(Java20ParserCATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2029)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2030)
		p.CatchFormalParameter()
	}
	{
		p.SetState(2031)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2032)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchFormalParameterContext is an interface to support dynamic dispatch.
type ICatchFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CatchType() ICatchTypeContext
	VariableDeclaratorId() IVariableDeclaratorIdContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext

	// IsCatchFormalParameterContext differentiates from other interfaces.
	IsCatchFormalParameterContext()
}

type CatchFormalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchFormalParameterContext() *CatchFormalParameterContext {
	var p = new(CatchFormalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catchFormalParameter
	return p
}

func InitEmptyCatchFormalParameterContext(p *CatchFormalParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catchFormalParameter
}

func (*CatchFormalParameterContext) IsCatchFormalParameterContext() {}

func NewCatchFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchFormalParameterContext {
	var p = new(CatchFormalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_catchFormalParameter

	return p
}

func (s *CatchFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchFormalParameterContext) CatchType() ICatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchFormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *CatchFormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *CatchFormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *CatchFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCatchFormalParameter(s)
	}
}

func (s *CatchFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCatchFormalParameter(s)
	}
}

func (p *Java20Parser) CatchFormalParameter() (localctx ICatchFormalParameterContext) {
	localctx = NewCatchFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, Java20ParserRULE_catchFormalParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserFINAL || _la == Java20ParserAT {
		{
			p.SetState(2034)
			p.VariableModifier()
		}

		p.SetState(2039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2040)
		p.CatchType()
	}
	{
		p.SetState(2041)
		p.VariableDeclaratorId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannClassType() IUnannClassTypeContext
	AllBITOR() []antlr.TerminalNode
	BITOR(i int) antlr.TerminalNode
	AllClassType() []IClassTypeContext
	ClassType(i int) IClassTypeContext

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catchType
	return p
}

func InitEmptyCatchTypeContext(p *CatchTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_catchType
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) UnannClassType() IUnannClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannClassTypeContext)
}

func (s *CatchTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserBITOR)
}

func (s *CatchTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserBITOR, i)
}

func (s *CatchTypeContext) AllClassType() []IClassTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassTypeContext); ok {
			len++
		}
	}

	tst := make([]IClassTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassTypeContext); ok {
			tst[i] = t.(IClassTypeContext)
			i++
		}
	}

	return tst
}

func (s *CatchTypeContext) ClassType(i int) IClassTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCatchType(s)
	}
}

func (s *CatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCatchType(s)
	}
}

func (p *Java20Parser) CatchType() (localctx ICatchTypeContext) {
	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, Java20ParserRULE_catchType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2043)
		p.UnannClassType()
	}
	p.SetState(2048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserBITOR {
		{
			p.SetState(2044)
			p.Match(Java20ParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2045)
			p.ClassType()
		}

		p.SetState(2050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_finallyBlock
	return p
}

func InitEmptyFinallyBlockContext(p *FinallyBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_finallyBlock
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(Java20ParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (p *Java20Parser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, Java20ParserRULE_finallyBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2051)
		p.Match(Java20ParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2052)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryWithResourcesStatementContext is an interface to support dynamic dispatch.
type ITryWithResourcesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	ResourceSpecification() IResourceSpecificationContext
	Block() IBlockContext
	Catches() ICatchesContext
	FinallyBlock() IFinallyBlockContext

	// IsTryWithResourcesStatementContext differentiates from other interfaces.
	IsTryWithResourcesStatementContext()
}

type TryWithResourcesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryWithResourcesStatementContext() *TryWithResourcesStatementContext {
	var p = new(TryWithResourcesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_tryWithResourcesStatement
	return p
}

func InitEmptyTryWithResourcesStatementContext(p *TryWithResourcesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_tryWithResourcesStatement
}

func (*TryWithResourcesStatementContext) IsTryWithResourcesStatementContext() {}

func NewTryWithResourcesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryWithResourcesStatementContext {
	var p = new(TryWithResourcesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_tryWithResourcesStatement

	return p
}

func (s *TryWithResourcesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryWithResourcesStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(Java20ParserTRY, 0)
}

func (s *TryWithResourcesStatementContext) ResourceSpecification() IResourceSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceSpecificationContext)
}

func (s *TryWithResourcesStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryWithResourcesStatementContext) Catches() ICatchesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchesContext)
}

func (s *TryWithResourcesStatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryWithResourcesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryWithResourcesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryWithResourcesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTryWithResourcesStatement(s)
	}
}

func (s *TryWithResourcesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTryWithResourcesStatement(s)
	}
}

func (p *Java20Parser) TryWithResourcesStatement() (localctx ITryWithResourcesStatementContext) {
	localctx = NewTryWithResourcesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, Java20ParserRULE_tryWithResourcesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2054)
		p.Match(Java20ParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2055)
		p.ResourceSpecification()
	}
	{
		p.SetState(2056)
		p.Block()
	}
	p.SetState(2058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserCATCH {
		{
			p.SetState(2057)
			p.Catches()
		}

	}
	p.SetState(2061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserFINALLY {
		{
			p.SetState(2060)
			p.FinallyBlock()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceSpecificationContext is an interface to support dynamic dispatch.
type IResourceSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ResourceList() IResourceListContext
	RPAREN() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsResourceSpecificationContext differentiates from other interfaces.
	IsResourceSpecificationContext()
}

type ResourceSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceSpecificationContext() *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_resourceSpecification
	return p
}

func InitEmptyResourceSpecificationContext(p *ResourceSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_resourceSpecification
}

func (*ResourceSpecificationContext) IsResourceSpecificationContext() {}

func NewResourceSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_resourceSpecification

	return p
}

func (s *ResourceSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceSpecificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *ResourceSpecificationContext) ResourceList() IResourceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceListContext)
}

func (s *ResourceSpecificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *ResourceSpecificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *ResourceSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterResourceSpecification(s)
	}
}

func (s *ResourceSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitResourceSpecification(s)
	}
}

func (p *Java20Parser) ResourceSpecification() (localctx IResourceSpecificationContext) {
	localctx = NewResourceSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, Java20ParserRULE_resourceSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2063)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2064)
		p.ResourceList()
	}
	p.SetState(2066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserSEMI {
		{
			p.SetState(2065)
			p.Match(Java20ParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2068)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceListContext is an interface to support dynamic dispatch.
type IResourceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllResource() []IResourceContext
	Resource(i int) IResourceContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsResourceListContext differentiates from other interfaces.
	IsResourceListContext()
}

type ResourceListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceListContext() *ResourceListContext {
	var p = new(ResourceListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_resourceList
	return p
}

func InitEmptyResourceListContext(p *ResourceListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_resourceList
}

func (*ResourceListContext) IsResourceListContext() {}

func NewResourceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceListContext {
	var p = new(ResourceListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_resourceList

	return p
}

func (s *ResourceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceListContext) AllResource() []IResourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceContext); ok {
			len++
		}
	}

	tst := make([]IResourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceContext); ok {
			tst[i] = t.(IResourceContext)
			i++
		}
	}

	return tst
}

func (s *ResourceListContext) Resource(i int) IResourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourceListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserSEMI)
}

func (s *ResourceListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, i)
}

func (s *ResourceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterResourceList(s)
	}
}

func (s *ResourceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitResourceList(s)
	}
}

func (p *Java20Parser) ResourceList() (localctx IResourceListContext) {
	localctx = NewResourceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, Java20ParserRULE_resourceList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2070)
		p.Resource()
	}
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2071)
				p.Match(Java20ParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2072)
				p.Resource()
			}

		}
		p.SetState(2077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	VariableAccess() IVariableAccessContext

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ResourceContext) VariableAccess() IVariableAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableAccessContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *Java20Parser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, Java20ParserRULE_resource)
	p.SetState(2080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2078)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2079)
			p.VariableAccess()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableAccessContext is an interface to support dynamic dispatch.
type IVariableAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionName() IExpressionNameContext
	FieldAccess() IFieldAccessContext

	// IsVariableAccessContext differentiates from other interfaces.
	IsVariableAccessContext()
}

type VariableAccessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableAccessContext() *VariableAccessContext {
	var p = new(VariableAccessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableAccess
	return p
}

func InitEmptyVariableAccessContext(p *VariableAccessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_variableAccess
}

func (*VariableAccessContext) IsVariableAccessContext() {}

func NewVariableAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableAccessContext {
	var p = new(VariableAccessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_variableAccess

	return p
}

func (s *VariableAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableAccessContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *VariableAccessContext) FieldAccess() IFieldAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldAccessContext)
}

func (s *VariableAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterVariableAccess(s)
	}
}

func (s *VariableAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitVariableAccess(s)
	}
}

func (p *Java20Parser) VariableAccess() (localctx IVariableAccessContext) {
	localctx = NewVariableAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, Java20ParserRULE_variableAccess)
	p.SetState(2084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2082)
			p.ExpressionName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2083)
			p.FieldAccess()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_yieldStatement
	return p
}

func InitEmptyYieldStatementContext(p *YieldStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_yieldStatement
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) YIELD() antlr.TerminalNode {
	return s.GetToken(Java20ParserYIELD, 0)
}

func (s *YieldStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *YieldStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(Java20ParserSEMI, 0)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterYieldStatement(s)
	}
}

func (s *YieldStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitYieldStatement(s)
	}
}

func (p *Java20Parser) YieldStatement() (localctx IYieldStatementContext) {
	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, Java20ParserRULE_yieldStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2086)
		p.Match(Java20ParserYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2087)
		p.Expression()
	}
	{
		p.SetState(2088)
		p.Match(Java20ParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypePattern() ITypePatternContext

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) TypePattern() ITypePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypePatternContext)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *Java20Parser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, Java20ParserRULE_pattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2090)
		p.TypePattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypePatternContext is an interface to support dynamic dispatch.
type ITypePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext

	// IsTypePatternContext differentiates from other interfaces.
	IsTypePatternContext()
}

type TypePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypePatternContext() *TypePatternContext {
	var p = new(TypePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typePattern
	return p
}

func InitEmptyTypePatternContext(p *TypePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typePattern
}

func (*TypePatternContext) IsTypePatternContext() {}

func NewTypePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypePatternContext {
	var p = new(TypePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typePattern

	return p
}

func (s *TypePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *TypePatternContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *TypePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypePattern(s)
	}
}

func (s *TypePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypePattern(s)
	}
}

func (p *Java20Parser) TypePattern() (localctx ITypePatternContext) {
	localctx = NewTypePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, Java20ParserRULE_typePattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2092)
		p.LocalVariableDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaExpression() ILambdaExpressionContext
	AssignmentExpression() IAssignmentExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *Java20Parser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, Java20ParserRULE_expression)
	p.SetState(2096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2094)
			p.LambdaExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2095)
			p.AssignmentExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryNoNewArray() IPrimaryNoNewArrayContext
	ArrayCreationExpression() IArrayCreationExpressionContext

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_primary
	return p
}

func InitEmptyPrimaryContext(p *PrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_primary
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) PrimaryNoNewArray() IPrimaryNoNewArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryNoNewArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArrayContext)
}

func (s *PrimaryContext) ArrayCreationExpression() IArrayCreationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationExpressionContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *Java20Parser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, Java20ParserRULE_primary)
	p.SetState(2100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2098)
			p.PrimaryNoNewArray()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2099)
			p.ArrayCreationExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryNoNewArrayContext is an interface to support dynamic dispatch.
type IPrimaryNoNewArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	PNNA() IPNNAContext
	ClassLiteral() IClassLiteralContext
	THIS() antlr.TerminalNode
	TypeName() ITypeNameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	UnqualifiedClassInstanceCreationExpression() IUnqualifiedClassInstanceCreationExpressionContext
	ExpressionName() IExpressionNameContext
	ArrayCreationExpression() IArrayCreationExpressionContext
	Identifier() IIdentifierContext
	SUPER() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	ArrayCreationExpressionWithInitializer() IArrayCreationExpressionWithInitializerContext
	MethodName() IMethodNameContext
	ArgumentList() IArgumentListContext
	TypeArguments() ITypeArgumentsContext
	COLONCOLON() antlr.TerminalNode
	ReferenceType() IReferenceTypeContext
	ClassType() IClassTypeContext
	NEW() antlr.TerminalNode
	ArrayType() IArrayTypeContext

	// IsPrimaryNoNewArrayContext differentiates from other interfaces.
	IsPrimaryNoNewArrayContext()
}

type PrimaryNoNewArrayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryNoNewArrayContext() *PrimaryNoNewArrayContext {
	var p = new(PrimaryNoNewArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_primaryNoNewArray
	return p
}

func InitEmptyPrimaryNoNewArrayContext(p *PrimaryNoNewArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_primaryNoNewArray
}

func (*PrimaryNoNewArrayContext) IsPrimaryNoNewArrayContext() {}

func NewPrimaryNoNewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryNoNewArrayContext {
	var p = new(PrimaryNoNewArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_primaryNoNewArray

	return p
}

func (s *PrimaryNoNewArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryNoNewArrayContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryNoNewArrayContext) PNNA() IPNNAContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPNNAContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPNNAContext)
}

func (s *PrimaryNoNewArrayContext) ClassLiteral() IClassLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassLiteralContext)
}

func (s *PrimaryNoNewArrayContext) THIS() antlr.TerminalNode {
	return s.GetToken(Java20ParserTHIS, 0)
}

func (s *PrimaryNoNewArrayContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *PrimaryNoNewArrayContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserDOT)
}

func (s *PrimaryNoNewArrayContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, i)
}

func (s *PrimaryNoNewArrayContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *PrimaryNoNewArrayContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryNoNewArrayContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *PrimaryNoNewArrayContext) UnqualifiedClassInstanceCreationExpression() IUnqualifiedClassInstanceCreationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnqualifiedClassInstanceCreationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedClassInstanceCreationExpressionContext)
}

func (s *PrimaryNoNewArrayContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *PrimaryNoNewArrayContext) ArrayCreationExpression() IArrayCreationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationExpressionContext)
}

func (s *PrimaryNoNewArrayContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryNoNewArrayContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUPER, 0)
}

func (s *PrimaryNoNewArrayContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACK, 0)
}

func (s *PrimaryNoNewArrayContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACK, 0)
}

func (s *PrimaryNoNewArrayContext) ArrayCreationExpressionWithInitializer() IArrayCreationExpressionWithInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationExpressionWithInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationExpressionWithInitializerContext)
}

func (s *PrimaryNoNewArrayContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *PrimaryNoNewArrayContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *PrimaryNoNewArrayContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *PrimaryNoNewArrayContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLONCOLON, 0)
}

func (s *PrimaryNoNewArrayContext) ReferenceType() IReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *PrimaryNoNewArrayContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *PrimaryNoNewArrayContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java20ParserNEW, 0)
}

func (s *PrimaryNoNewArrayContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *PrimaryNoNewArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNoNewArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryNoNewArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPrimaryNoNewArray(s)
	}
}

func (s *PrimaryNoNewArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPrimaryNoNewArray(s)
	}
}

func (p *Java20Parser) PrimaryNoNewArray() (localctx IPrimaryNoNewArrayContext) {
	localctx = NewPrimaryNoNewArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, Java20ParserRULE_primaryNoNewArray)
	var _la int

	p.SetState(2319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2102)
			p.Literal()
		}
		p.SetState(2104)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2103)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2106)
			p.ClassLiteral()
		}
		p.SetState(2108)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2107)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2110)
			p.Match(Java20ParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2112)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2111)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2114)
			p.TypeName()
		}
		{
			p.SetState(2115)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.Match(Java20ParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2118)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2117)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2120)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)
			p.Expression()
		}
		{
			p.SetState(2122)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2124)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2123)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2126)
			p.UnqualifiedClassInstanceCreationExpression()
		}
		p.SetState(2128)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2127)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2130)
			p.ExpressionName()
		}
		{
			p.SetState(2131)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2132)
			p.UnqualifiedClassInstanceCreationExpression()
		}
		p.SetState(2134)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2133)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2136)
			p.ArrayCreationExpression()
		}
		{
			p.SetState(2137)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2138)
			p.UnqualifiedClassInstanceCreationExpression()
		}
		p.SetState(2140)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2139)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2142)
			p.ArrayCreationExpression()
		}
		{
			p.SetState(2143)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2144)
			p.Identifier()
		}
		p.SetState(2146)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2145)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2148)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2149)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2150)
			p.Identifier()
		}
		p.SetState(2152)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2151)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2154)
			p.TypeName()
		}
		{
			p.SetState(2155)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2156)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2157)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2158)
			p.Identifier()
		}
		p.SetState(2160)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2159)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2162)
			p.ExpressionName()
		}
		{
			p.SetState(2163)
			p.Match(Java20ParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2164)
			p.Expression()
		}
		{
			p.SetState(2165)
			p.Match(Java20ParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2167)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2166)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2169)
			p.ArrayCreationExpressionWithInitializer()
		}
		{
			p.SetState(2170)
			p.Match(Java20ParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2171)
			p.Expression()
		}
		{
			p.SetState(2172)
			p.Match(Java20ParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2174)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2173)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2176)
			p.MethodName()
		}
		{
			p.SetState(2177)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2178)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2181)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2183)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2182)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2185)
			p.TypeName()
		}
		{
			p.SetState(2186)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2187)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2190)
			p.Identifier()
		}
		{
			p.SetState(2191)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2192)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2195)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2197)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2196)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2199)
			p.ExpressionName()
		}
		{
			p.SetState(2200)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2201)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2204)
			p.Identifier()
		}
		{
			p.SetState(2205)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2206)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2209)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2211)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2210)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2213)
			p.ArrayCreationExpression()
		}
		{
			p.SetState(2214)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2215)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2218)
			p.Identifier()
		}
		{
			p.SetState(2219)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2220)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2223)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2224)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2227)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2228)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2229)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2232)
			p.Identifier()
		}
		{
			p.SetState(2233)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2234)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2237)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2239)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2238)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2241)
			p.TypeName()
		}
		{
			p.SetState(2242)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2243)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2245)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2248)
			p.Identifier()
		}
		{
			p.SetState(2249)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2250)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2253)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2255)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2254)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2257)
			p.ExpressionName()
		}
		{
			p.SetState(2258)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2259)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2262)
			p.Identifier()
		}
		p.SetState(2264)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2263)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2266)
			p.ArrayCreationExpression()
		}
		{
			p.SetState(2267)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2268)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2271)
			p.Identifier()
		}
		p.SetState(2273)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2272)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2275)
			p.ReferenceType()
		}
		{
			p.SetState(2276)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2277)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2280)
			p.Identifier()
		}
		p.SetState(2282)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2281)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2284)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2285)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2286)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2289)
			p.Identifier()
		}
		p.SetState(2291)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2290)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2293)
			p.TypeName()
		}
		{
			p.SetState(2294)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2295)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2296)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2297)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2300)
			p.Identifier()
		}
		p.SetState(2302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2301)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2304)
			p.ClassType()
		}
		{
			p.SetState(2305)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2306)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2309)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2311)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2310)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2313)
			p.ArrayType()
		}
		{
			p.SetState(2314)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2315)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2317)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2316)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPNNAContext is an interface to support dynamic dispatch.
type IPNNAContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	UnqualifiedClassInstanceCreationExpression() IUnqualifiedClassInstanceCreationExpressionContext
	PNNA() IPNNAContext
	Identifier() IIdentifierContext
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext
	ArgumentList() IArgumentListContext
	COLONCOLON() antlr.TerminalNode

	// IsPNNAContext differentiates from other interfaces.
	IsPNNAContext()
}

type PNNAContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPNNAContext() *PNNAContext {
	var p = new(PNNAContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_pNNA
	return p
}

func InitEmptyPNNAContext(p *PNNAContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_pNNA
}

func (*PNNAContext) IsPNNAContext() {}

func NewPNNAContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PNNAContext {
	var p = new(PNNAContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_pNNA

	return p
}

func (s *PNNAContext) GetParser() antlr.Parser { return s.parser }

func (s *PNNAContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *PNNAContext) UnqualifiedClassInstanceCreationExpression() IUnqualifiedClassInstanceCreationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnqualifiedClassInstanceCreationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedClassInstanceCreationExpressionContext)
}

func (s *PNNAContext) PNNA() IPNNAContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPNNAContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPNNAContext)
}

func (s *PNNAContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PNNAContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACK, 0)
}

func (s *PNNAContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PNNAContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACK, 0)
}

func (s *PNNAContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *PNNAContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *PNNAContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *PNNAContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *PNNAContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLONCOLON, 0)
}

func (s *PNNAContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PNNAContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PNNAContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPNNA(s)
	}
}

func (s *PNNAContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPNNA(s)
	}
}

func (p *Java20Parser) PNNA() (localctx IPNNAContext) {
	localctx = NewPNNAContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, Java20ParserRULE_pNNA)
	var _la int

	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2321)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2322)
			p.UnqualifiedClassInstanceCreationExpression()
		}
		p.SetState(2324)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2323)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2326)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2327)
			p.Identifier()
		}
		p.SetState(2329)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2328)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2331)
			p.Match(Java20ParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2332)
			p.Expression()
		}
		{
			p.SetState(2333)
			p.Match(Java20ParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2335)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2334)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2337)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2338)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2341)
			p.Identifier()
		}
		{
			p.SetState(2342)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2343)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2346)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2348)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2347)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2350)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2351)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2354)
			p.Identifier()
		}
		p.SetState(2356)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2355)
				p.PNNA()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassLiteralContext is an interface to support dynamic dispatch.
type IClassLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeName() ITypeNameContext
	DOT() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	NumericType() INumericTypeContext
	BOOLEAN() antlr.TerminalNode
	VOID() antlr.TerminalNode

	// IsClassLiteralContext differentiates from other interfaces.
	IsClassLiteralContext()
}

type ClassLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassLiteralContext() *ClassLiteralContext {
	var p = new(ClassLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classLiteral
	return p
}

func InitEmptyClassLiteralContext(p *ClassLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classLiteral
}

func (*ClassLiteralContext) IsClassLiteralContext() {}

func NewClassLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassLiteralContext {
	var p = new(ClassLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classLiteral

	return p
}

func (s *ClassLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassLiteralContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *ClassLiteralContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ClassLiteralContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Java20ParserCLASS, 0)
}

func (s *ClassLiteralContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserLBRACK)
}

func (s *ClassLiteralContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACK, i)
}

func (s *ClassLiteralContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserRBRACK)
}

func (s *ClassLiteralContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACK, i)
}

func (s *ClassLiteralContext) NumericType() INumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *ClassLiteralContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(Java20ParserBOOLEAN, 0)
}

func (s *ClassLiteralContext) VOID() antlr.TerminalNode {
	return s.GetToken(Java20ParserVOID, 0)
}

func (s *ClassLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassLiteral(s)
	}
}

func (s *ClassLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassLiteral(s)
	}
}

func (p *Java20Parser) ClassLiteral() (localctx IClassLiteralContext) {
	localctx = NewClassLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, Java20ParserRULE_classLiteral)
	var _la int

	p.SetState(2395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD, Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2360)
			p.TypeName()
		}
		p.SetState(2365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserLBRACK {
			{
				p.SetState(2361)
				p.Match(Java20ParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2362)
				p.Match(Java20ParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2367)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2368)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2369)
			p.Match(Java20ParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserSHORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2371)
			p.NumericType()
		}
		p.SetState(2376)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserLBRACK {
			{
				p.SetState(2372)
				p.Match(Java20ParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2373)
				p.Match(Java20ParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2378)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2379)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2380)
			p.Match(Java20ParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserBOOLEAN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2382)
			p.Match(Java20ParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserLBRACK {
			{
				p.SetState(2383)
				p.Match(Java20ParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2384)
				p.Match(Java20ParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2389)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2390)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2391)
			p.Match(Java20ParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserVOID:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2392)
			p.Match(Java20ParserVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2393)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2394)
			p.Match(Java20ParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassInstanceCreationExpressionContext is an interface to support dynamic dispatch.
type IClassInstanceCreationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnqualifiedClassInstanceCreationExpression() IUnqualifiedClassInstanceCreationExpressionContext
	ExpressionName() IExpressionNameContext
	DOT() antlr.TerminalNode
	Primary() IPrimaryContext

	// IsClassInstanceCreationExpressionContext differentiates from other interfaces.
	IsClassInstanceCreationExpressionContext()
}

type ClassInstanceCreationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassInstanceCreationExpressionContext() *ClassInstanceCreationExpressionContext {
	var p = new(ClassInstanceCreationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classInstanceCreationExpression
	return p
}

func InitEmptyClassInstanceCreationExpressionContext(p *ClassInstanceCreationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classInstanceCreationExpression
}

func (*ClassInstanceCreationExpressionContext) IsClassInstanceCreationExpressionContext() {}

func NewClassInstanceCreationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassInstanceCreationExpressionContext {
	var p = new(ClassInstanceCreationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classInstanceCreationExpression

	return p
}

func (s *ClassInstanceCreationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassInstanceCreationExpressionContext) UnqualifiedClassInstanceCreationExpression() IUnqualifiedClassInstanceCreationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnqualifiedClassInstanceCreationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedClassInstanceCreationExpressionContext)
}

func (s *ClassInstanceCreationExpressionContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ClassInstanceCreationExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *ClassInstanceCreationExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ClassInstanceCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassInstanceCreationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassInstanceCreationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassInstanceCreationExpression(s)
	}
}

func (s *ClassInstanceCreationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassInstanceCreationExpression(s)
	}
}

func (p *Java20Parser) ClassInstanceCreationExpression() (localctx IClassInstanceCreationExpressionContext) {
	localctx = NewClassInstanceCreationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, Java20ParserRULE_classInstanceCreationExpression)
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2397)
			p.UnqualifiedClassInstanceCreationExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2398)
			p.ExpressionName()
		}
		{
			p.SetState(2399)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2400)
			p.UnqualifiedClassInstanceCreationExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2402)
			p.Primary()
		}
		{
			p.SetState(2403)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2404)
			p.UnqualifiedClassInstanceCreationExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnqualifiedClassInstanceCreationExpressionContext is an interface to support dynamic dispatch.
type IUnqualifiedClassInstanceCreationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEW() antlr.TerminalNode
	ClassOrInterfaceTypeToInstantiate() IClassOrInterfaceTypeToInstantiateContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext
	ArgumentList() IArgumentListContext
	ClassBody() IClassBodyContext

	// IsUnqualifiedClassInstanceCreationExpressionContext differentiates from other interfaces.
	IsUnqualifiedClassInstanceCreationExpressionContext()
}

type UnqualifiedClassInstanceCreationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnqualifiedClassInstanceCreationExpressionContext() *UnqualifiedClassInstanceCreationExpressionContext {
	var p = new(UnqualifiedClassInstanceCreationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unqualifiedClassInstanceCreationExpression
	return p
}

func InitEmptyUnqualifiedClassInstanceCreationExpressionContext(p *UnqualifiedClassInstanceCreationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unqualifiedClassInstanceCreationExpression
}

func (*UnqualifiedClassInstanceCreationExpressionContext) IsUnqualifiedClassInstanceCreationExpressionContext() {
}

func NewUnqualifiedClassInstanceCreationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnqualifiedClassInstanceCreationExpressionContext {
	var p = new(UnqualifiedClassInstanceCreationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unqualifiedClassInstanceCreationExpression

	return p
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnqualifiedClassInstanceCreationExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java20ParserNEW, 0)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) ClassOrInterfaceTypeToInstantiate() IClassOrInterfaceTypeToInstantiateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeToInstantiateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeToInstantiateContext)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnqualifiedClassInstanceCreationExpression(s)
	}
}

func (s *UnqualifiedClassInstanceCreationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnqualifiedClassInstanceCreationExpression(s)
	}
}

func (p *Java20Parser) UnqualifiedClassInstanceCreationExpression() (localctx IUnqualifiedClassInstanceCreationExpressionContext) {
	localctx = NewUnqualifiedClassInstanceCreationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, Java20ParserRULE_unqualifiedClassInstanceCreationExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2408)
		p.Match(Java20ParserNEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserLT {
		{
			p.SetState(2409)
			p.TypeArguments()
		}

	}
	{
		p.SetState(2412)
		p.ClassOrInterfaceTypeToInstantiate()
	}
	{
		p.SetState(2413)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
		{
			p.SetState(2414)
			p.ArgumentList()
		}

	}
	{
		p.SetState(2417)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2419)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2418)
			p.ClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceTypeToInstantiateContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeToInstantiateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext

	// IsClassOrInterfaceTypeToInstantiateContext differentiates from other interfaces.
	IsClassOrInterfaceTypeToInstantiateContext()
}

type ClassOrInterfaceTypeToInstantiateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeToInstantiateContext() *ClassOrInterfaceTypeToInstantiateContext {
	var p = new(ClassOrInterfaceTypeToInstantiateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classOrInterfaceTypeToInstantiate
	return p
}

func InitEmptyClassOrInterfaceTypeToInstantiateContext(p *ClassOrInterfaceTypeToInstantiateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_classOrInterfaceTypeToInstantiate
}

func (*ClassOrInterfaceTypeToInstantiateContext) IsClassOrInterfaceTypeToInstantiateContext() {}

func NewClassOrInterfaceTypeToInstantiateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeToInstantiateContext {
	var p = new(ClassOrInterfaceTypeToInstantiateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_classOrInterfaceTypeToInstantiate

	return p
}

func (s *ClassOrInterfaceTypeToInstantiateContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeToInstantiateContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeToInstantiateContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassOrInterfaceTypeToInstantiateContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeToInstantiateContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceTypeToInstantiateContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserDOT)
}

func (s *ClassOrInterfaceTypeToInstantiateContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, i)
}

func (s *ClassOrInterfaceTypeToInstantiateContext) TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *ClassOrInterfaceTypeToInstantiateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeToInstantiateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeToInstantiateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterClassOrInterfaceTypeToInstantiate(s)
	}
}

func (s *ClassOrInterfaceTypeToInstantiateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitClassOrInterfaceTypeToInstantiate(s)
	}
}

func (p *Java20Parser) ClassOrInterfaceTypeToInstantiate() (localctx IClassOrInterfaceTypeToInstantiateContext) {
	localctx = NewClassOrInterfaceTypeToInstantiateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, Java20ParserRULE_classOrInterfaceTypeToInstantiate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(2421)
			p.Annotation()
		}

		p.SetState(2426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2427)
		p.Identifier()
	}
	p.SetState(2438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserDOT {
		{
			p.SetState(2428)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserAT {
			{
				p.SetState(2429)
				p.Annotation()
			}

			p.SetState(2434)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2435)
			p.Identifier()
		}

		p.SetState(2440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == Java20ParserOACA || _la == Java20ParserLT {
		{
			p.SetState(2441)
			p.TypeArgumentsOrDiamond()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeArguments() ITypeArgumentsContext
	OACA() antlr.TerminalNode

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArgumentsOrDiamond
	return p
}

func InitEmptyTypeArgumentsOrDiamondContext(p *TypeArgumentsOrDiamondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_typeArgumentsOrDiamond
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) OACA() antlr.TerminalNode {
	return s.GetToken(Java20ParserOACA, 0)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitTypeArgumentsOrDiamond(s)
	}
}

func (p *Java20Parser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, Java20ParserRULE_typeArgumentsOrDiamond)
	p.SetState(2446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserLT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2444)
			p.TypeArguments()
		}

	case Java20ParserOACA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2445)
			p.Match(Java20ParserOACA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayCreationExpressionContext is an interface to support dynamic dispatch.
type IArrayCreationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayCreationExpressionWithoutInitializer() IArrayCreationExpressionWithoutInitializerContext
	ArrayCreationExpressionWithInitializer() IArrayCreationExpressionWithInitializerContext

	// IsArrayCreationExpressionContext differentiates from other interfaces.
	IsArrayCreationExpressionContext()
}

type ArrayCreationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreationExpressionContext() *ArrayCreationExpressionContext {
	var p = new(ArrayCreationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayCreationExpression
	return p
}

func InitEmptyArrayCreationExpressionContext(p *ArrayCreationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayCreationExpression
}

func (*ArrayCreationExpressionContext) IsArrayCreationExpressionContext() {}

func NewArrayCreationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreationExpressionContext {
	var p = new(ArrayCreationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_arrayCreationExpression

	return p
}

func (s *ArrayCreationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreationExpressionContext) ArrayCreationExpressionWithoutInitializer() IArrayCreationExpressionWithoutInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationExpressionWithoutInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationExpressionWithoutInitializerContext)
}

func (s *ArrayCreationExpressionContext) ArrayCreationExpressionWithInitializer() IArrayCreationExpressionWithInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationExpressionWithInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationExpressionWithInitializerContext)
}

func (s *ArrayCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterArrayCreationExpression(s)
	}
}

func (s *ArrayCreationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitArrayCreationExpression(s)
	}
}

func (p *Java20Parser) ArrayCreationExpression() (localctx IArrayCreationExpressionContext) {
	localctx = NewArrayCreationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, Java20ParserRULE_arrayCreationExpression)
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2448)
			p.ArrayCreationExpressionWithoutInitializer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2449)
			p.ArrayCreationExpressionWithInitializer()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayCreationExpressionWithoutInitializerContext is an interface to support dynamic dispatch.
type IArrayCreationExpressionWithoutInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEW() antlr.TerminalNode
	PrimitiveType() IPrimitiveTypeContext
	DimExprs() IDimExprsContext
	Dims() IDimsContext
	ClassType() IClassTypeContext

	// IsArrayCreationExpressionWithoutInitializerContext differentiates from other interfaces.
	IsArrayCreationExpressionWithoutInitializerContext()
}

type ArrayCreationExpressionWithoutInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreationExpressionWithoutInitializerContext() *ArrayCreationExpressionWithoutInitializerContext {
	var p = new(ArrayCreationExpressionWithoutInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayCreationExpressionWithoutInitializer
	return p
}

func InitEmptyArrayCreationExpressionWithoutInitializerContext(p *ArrayCreationExpressionWithoutInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayCreationExpressionWithoutInitializer
}

func (*ArrayCreationExpressionWithoutInitializerContext) IsArrayCreationExpressionWithoutInitializerContext() {
}

func NewArrayCreationExpressionWithoutInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreationExpressionWithoutInitializerContext {
	var p = new(ArrayCreationExpressionWithoutInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_arrayCreationExpressionWithoutInitializer

	return p
}

func (s *ArrayCreationExpressionWithoutInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreationExpressionWithoutInitializerContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java20ParserNEW, 0)
}

func (s *ArrayCreationExpressionWithoutInitializerContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ArrayCreationExpressionWithoutInitializerContext) DimExprs() IDimExprsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimExprsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimExprsContext)
}

func (s *ArrayCreationExpressionWithoutInitializerContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *ArrayCreationExpressionWithoutInitializerContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *ArrayCreationExpressionWithoutInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationExpressionWithoutInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreationExpressionWithoutInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterArrayCreationExpressionWithoutInitializer(s)
	}
}

func (s *ArrayCreationExpressionWithoutInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitArrayCreationExpressionWithoutInitializer(s)
	}
}

func (p *Java20Parser) ArrayCreationExpressionWithoutInitializer() (localctx IArrayCreationExpressionWithoutInitializerContext) {
	localctx = NewArrayCreationExpressionWithoutInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, Java20ParserRULE_arrayCreationExpressionWithoutInitializer)
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2452)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2453)
			p.PrimitiveType()
		}
		{
			p.SetState(2454)
			p.DimExprs()
		}
		p.SetState(2456)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2455)
				p.Dims()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2458)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2459)
			p.ClassType()
		}
		{
			p.SetState(2460)
			p.DimExprs()
		}
		p.SetState(2462)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2461)
				p.Dims()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayCreationExpressionWithInitializerContext is an interface to support dynamic dispatch.
type IArrayCreationExpressionWithInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEW() antlr.TerminalNode
	PrimitiveType() IPrimitiveTypeContext
	Dims() IDimsContext
	ArrayInitializer() IArrayInitializerContext
	ClassOrInterfaceType() IClassOrInterfaceTypeContext

	// IsArrayCreationExpressionWithInitializerContext differentiates from other interfaces.
	IsArrayCreationExpressionWithInitializerContext()
}

type ArrayCreationExpressionWithInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreationExpressionWithInitializerContext() *ArrayCreationExpressionWithInitializerContext {
	var p = new(ArrayCreationExpressionWithInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayCreationExpressionWithInitializer
	return p
}

func InitEmptyArrayCreationExpressionWithInitializerContext(p *ArrayCreationExpressionWithInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayCreationExpressionWithInitializer
}

func (*ArrayCreationExpressionWithInitializerContext) IsArrayCreationExpressionWithInitializerContext() {
}

func NewArrayCreationExpressionWithInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreationExpressionWithInitializerContext {
	var p = new(ArrayCreationExpressionWithInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_arrayCreationExpressionWithInitializer

	return p
}

func (s *ArrayCreationExpressionWithInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreationExpressionWithInitializerContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java20ParserNEW, 0)
}

func (s *ArrayCreationExpressionWithInitializerContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ArrayCreationExpressionWithInitializerContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *ArrayCreationExpressionWithInitializerContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *ArrayCreationExpressionWithInitializerContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ArrayCreationExpressionWithInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationExpressionWithInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreationExpressionWithInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterArrayCreationExpressionWithInitializer(s)
	}
}

func (s *ArrayCreationExpressionWithInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitArrayCreationExpressionWithInitializer(s)
	}
}

func (p *Java20Parser) ArrayCreationExpressionWithInitializer() (localctx IArrayCreationExpressionWithInitializerContext) {
	localctx = NewArrayCreationExpressionWithInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, Java20ParserRULE_arrayCreationExpressionWithInitializer)
	p.SetState(2476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2466)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2467)
			p.PrimitiveType()
		}
		{
			p.SetState(2468)
			p.Dims()
		}
		{
			p.SetState(2469)
			p.ArrayInitializer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2471)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2472)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(2473)
			p.Dims()
		}
		{
			p.SetState(2474)
			p.ArrayInitializer()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDimExprsContext is an interface to support dynamic dispatch.
type IDimExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDimExpr() []IDimExprContext
	DimExpr(i int) IDimExprContext

	// IsDimExprsContext differentiates from other interfaces.
	IsDimExprsContext()
}

type DimExprsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimExprsContext() *DimExprsContext {
	var p = new(DimExprsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_dimExprs
	return p
}

func InitEmptyDimExprsContext(p *DimExprsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_dimExprs
}

func (*DimExprsContext) IsDimExprsContext() {}

func NewDimExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimExprsContext {
	var p = new(DimExprsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_dimExprs

	return p
}

func (s *DimExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *DimExprsContext) AllDimExpr() []IDimExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDimExprContext); ok {
			len++
		}
	}

	tst := make([]IDimExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDimExprContext); ok {
			tst[i] = t.(IDimExprContext)
			i++
		}
	}

	return tst
}

func (s *DimExprsContext) DimExpr(i int) IDimExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimExprContext)
}

func (s *DimExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterDimExprs(s)
	}
}

func (s *DimExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitDimExprs(s)
	}
}

func (p *Java20Parser) DimExprs() (localctx IDimExprsContext) {
	localctx = NewDimExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, Java20ParserRULE_dimExprs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2478)
		p.DimExpr()
	}
	p.SetState(2482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2479)
				p.DimExpr()
			}

		}
		p.SetState(2484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDimExprContext is an interface to support dynamic dispatch.
type IDimExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsDimExprContext differentiates from other interfaces.
	IsDimExprContext()
}

type DimExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimExprContext() *DimExprContext {
	var p = new(DimExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_dimExpr
	return p
}

func InitEmptyDimExprContext(p *DimExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_dimExpr
}

func (*DimExprContext) IsDimExprContext() {}

func NewDimExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimExprContext {
	var p = new(DimExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_dimExpr

	return p
}

func (s *DimExprContext) GetParser() antlr.Parser { return s.parser }

func (s *DimExprContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACK, 0)
}

func (s *DimExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DimExprContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACK, 0)
}

func (s *DimExprContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *DimExprContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *DimExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterDimExpr(s)
	}
}

func (s *DimExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitDimExpr(s)
	}
}

func (p *Java20Parser) DimExpr() (localctx IDimExprContext) {
	localctx = NewDimExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, Java20ParserRULE_dimExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserAT {
		{
			p.SetState(2485)
			p.Annotation()
		}

		p.SetState(2490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2491)
		p.Match(Java20ParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2492)
		p.Expression()
	}
	{
		p.SetState(2493)
		p.Match(Java20ParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayAccessContext is an interface to support dynamic dispatch.
type IArrayAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionName() IExpressionNameContext
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	PrimaryNoNewArray() IPrimaryNoNewArrayContext
	ArrayCreationExpressionWithInitializer() IArrayCreationExpressionWithInitializerContext

	// IsArrayAccessContext differentiates from other interfaces.
	IsArrayAccessContext()
}

type ArrayAccessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayAccessContext() *ArrayAccessContext {
	var p = new(ArrayAccessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayAccess
	return p
}

func InitEmptyArrayAccessContext(p *ArrayAccessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_arrayAccess
}

func (*ArrayAccessContext) IsArrayAccessContext() {}

func NewArrayAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayAccessContext {
	var p = new(ArrayAccessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_arrayAccess

	return p
}

func (s *ArrayAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayAccessContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *ArrayAccessContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserLBRACK, 0)
}

func (s *ArrayAccessContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayAccessContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(Java20ParserRBRACK, 0)
}

func (s *ArrayAccessContext) PrimaryNoNewArray() IPrimaryNoNewArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryNoNewArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryNoNewArrayContext)
}

func (s *ArrayAccessContext) ArrayCreationExpressionWithInitializer() IArrayCreationExpressionWithInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreationExpressionWithInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreationExpressionWithInitializerContext)
}

func (s *ArrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterArrayAccess(s)
	}
}

func (s *ArrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitArrayAccess(s)
	}
}

func (p *Java20Parser) ArrayAccess() (localctx IArrayAccessContext) {
	localctx = NewArrayAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, Java20ParserRULE_arrayAccess)
	p.SetState(2510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2495)
			p.ExpressionName()
		}
		{
			p.SetState(2496)
			p.Match(Java20ParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2497)
			p.Expression()
		}
		{
			p.SetState(2498)
			p.Match(Java20ParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2500)
			p.PrimaryNoNewArray()
		}
		{
			p.SetState(2501)
			p.Match(Java20ParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2502)
			p.Expression()
		}
		{
			p.SetState(2503)
			p.Match(Java20ParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2505)
			p.ArrayCreationExpressionWithInitializer()
		}
		{
			p.SetState(2506)
			p.Match(Java20ParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2507)
			p.Expression()
		}
		{
			p.SetState(2508)
			p.Match(Java20ParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldAccessContext is an interface to support dynamic dispatch.
type IFieldAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Primary() IPrimaryContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	SUPER() antlr.TerminalNode
	TypeName() ITypeNameContext

	// IsFieldAccessContext differentiates from other interfaces.
	IsFieldAccessContext()
}

type FieldAccessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldAccessContext() *FieldAccessContext {
	var p = new(FieldAccessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_fieldAccess
	return p
}

func InitEmptyFieldAccessContext(p *FieldAccessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_fieldAccess
}

func (*FieldAccessContext) IsFieldAccessContext() {}

func NewFieldAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldAccessContext {
	var p = new(FieldAccessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_fieldAccess

	return p
}

func (s *FieldAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldAccessContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *FieldAccessContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserDOT)
}

func (s *FieldAccessContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, i)
}

func (s *FieldAccessContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FieldAccessContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUPER, 0)
}

func (s *FieldAccessContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *FieldAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterFieldAccess(s)
	}
}

func (s *FieldAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitFieldAccess(s)
	}
}

func (p *Java20Parser) FieldAccess() (localctx IFieldAccessContext) {
	localctx = NewFieldAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, Java20ParserRULE_fieldAccess)
	p.SetState(2525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2512)
			p.Primary()
		}
		{
			p.SetState(2513)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2514)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2516)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2517)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2518)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2519)
			p.TypeName()
		}
		{
			p.SetState(2520)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2521)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2522)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2523)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodInvocationContext is an interface to support dynamic dispatch.
type IMethodInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodName() IMethodNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ArgumentList() IArgumentListContext
	TypeName() ITypeNameContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	TypeArguments() ITypeArgumentsContext
	ExpressionName() IExpressionNameContext
	Primary() IPrimaryContext
	SUPER() antlr.TerminalNode

	// IsMethodInvocationContext differentiates from other interfaces.
	IsMethodInvocationContext()
}

type MethodInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodInvocationContext() *MethodInvocationContext {
	var p = new(MethodInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodInvocation
	return p
}

func InitEmptyMethodInvocationContext(p *MethodInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodInvocation
}

func (*MethodInvocationContext) IsMethodInvocationContext() {}

func NewMethodInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodInvocationContext {
	var p = new(MethodInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodInvocation

	return p
}

func (s *MethodInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodInvocationContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodInvocationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *MethodInvocationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *MethodInvocationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *MethodInvocationContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MethodInvocationContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserDOT)
}

func (s *MethodInvocationContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, i)
}

func (s *MethodInvocationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodInvocationContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodInvocationContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *MethodInvocationContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *MethodInvocationContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUPER, 0)
}

func (s *MethodInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodInvocation(s)
	}
}

func (s *MethodInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodInvocation(s)
	}
}

func (p *Java20Parser) MethodInvocation() (localctx IMethodInvocationContext) {
	localctx = NewMethodInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, Java20ParserRULE_methodInvocation)
	var _la int

	p.SetState(2596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2527)
			p.MethodName()
		}
		{
			p.SetState(2528)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2529)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2532)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2534)
			p.TypeName()
		}
		{
			p.SetState(2535)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2536)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2539)
			p.Identifier()
		}
		{
			p.SetState(2540)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2541)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2544)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2546)
			p.ExpressionName()
		}
		{
			p.SetState(2547)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2549)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2548)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2551)
			p.Identifier()
		}
		{
			p.SetState(2552)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2553)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2556)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2558)
			p.Primary()
		}
		{
			p.SetState(2559)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2560)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2563)
			p.Identifier()
		}
		{
			p.SetState(2564)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2565)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2568)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2570)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2571)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2572)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2575)
			p.Identifier()
		}
		{
			p.SetState(2576)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2577)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2580)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2582)
			p.TypeName()
		}
		{
			p.SetState(2583)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2585)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2586)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2589)
			p.Identifier()
		}
		{
			p.SetState(2590)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1603651042876325870) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&288232437939441649) != 0) {
			{
				p.SetState(2591)
				p.ArgumentList()
			}

		}
		{
			p.SetState(2594)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *Java20Parser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, Java20ParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2598)
		p.Expression()
	}
	p.SetState(2603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Java20ParserCOMMA {
		{
			p.SetState(2599)
			p.Match(Java20ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2600)
			p.Expression()
		}

		p.SetState(2605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodReferenceContext is an interface to support dynamic dispatch.
type IMethodReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionName() IExpressionNameContext
	COLONCOLON() antlr.TerminalNode
	Identifier() IIdentifierContext
	TypeArguments() ITypeArgumentsContext
	Primary() IPrimaryContext
	ReferenceType() IReferenceTypeContext
	SUPER() antlr.TerminalNode
	TypeName() ITypeNameContext
	DOT() antlr.TerminalNode
	ClassType() IClassTypeContext
	NEW() antlr.TerminalNode
	ArrayType() IArrayTypeContext

	// IsMethodReferenceContext differentiates from other interfaces.
	IsMethodReferenceContext()
}

type MethodReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodReferenceContext() *MethodReferenceContext {
	var p = new(MethodReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodReference
	return p
}

func InitEmptyMethodReferenceContext(p *MethodReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_methodReference
}

func (*MethodReferenceContext) IsMethodReferenceContext() {}

func NewMethodReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodReferenceContext {
	var p = new(MethodReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_methodReference

	return p
}

func (s *MethodReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodReferenceContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *MethodReferenceContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLONCOLON, 0)
}

func (s *MethodReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodReferenceContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *MethodReferenceContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *MethodReferenceContext) ReferenceType() IReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *MethodReferenceContext) SUPER() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUPER, 0)
}

func (s *MethodReferenceContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *MethodReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(Java20ParserDOT, 0)
}

func (s *MethodReferenceContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *MethodReferenceContext) NEW() antlr.TerminalNode {
	return s.GetToken(Java20ParserNEW, 0)
}

func (s *MethodReferenceContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *MethodReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMethodReference(s)
	}
}

func (s *MethodReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMethodReference(s)
	}
}

func (p *Java20Parser) MethodReference() (localctx IMethodReferenceContext) {
	localctx = NewMethodReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, Java20ParserRULE_methodReference)
	var _la int

	p.SetState(2653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2606)
			p.ExpressionName()
		}
		{
			p.SetState(2607)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2608)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2611)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2613)
			p.Primary()
		}
		{
			p.SetState(2614)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2615)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2618)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2620)
			p.ReferenceType()
		}
		{
			p.SetState(2621)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2622)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2625)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2627)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2628)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2629)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2632)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2633)
			p.TypeName()
		}
		{
			p.SetState(2634)
			p.Match(Java20ParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2635)
			p.Match(Java20ParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2636)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2637)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2640)
			p.Identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2642)
			p.ClassType()
		}
		{
			p.SetState(2643)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Java20ParserLT {
			{
				p.SetState(2644)
				p.TypeArguments()
			}

		}
		{
			p.SetState(2647)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2649)
			p.ArrayType()
		}
		{
			p.SetState(2650)
			p.Match(Java20ParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2651)
			p.Match(Java20ParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Primary() IPrimaryContext
	PfE() IPfEContext
	ExpressionName() IExpressionNameContext

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_postfixExpression
	return p
}

func InitEmptyPostfixExpressionContext(p *PostfixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_postfixExpression
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PostfixExpressionContext) PfE() IPfEContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPfEContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPfEContext)
}

func (s *PostfixExpressionContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (p *Java20Parser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, Java20ParserRULE_postfixExpression)
	p.SetState(2663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2655)
			p.Primary()
		}
		p.SetState(2657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2656)
				p.PfE()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2659)
			p.ExpressionName()
		}
		p.SetState(2661)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2660)
				p.PfE()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPfEContext is an interface to support dynamic dispatch.
type IPfEContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INC() antlr.TerminalNode
	PfE() IPfEContext
	DEC() antlr.TerminalNode

	// IsPfEContext differentiates from other interfaces.
	IsPfEContext()
}

type PfEContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPfEContext() *PfEContext {
	var p = new(PfEContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_pfE
	return p
}

func InitEmptyPfEContext(p *PfEContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_pfE
}

func (*PfEContext) IsPfEContext() {}

func NewPfEContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PfEContext {
	var p = new(PfEContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_pfE

	return p
}

func (s *PfEContext) GetParser() antlr.Parser { return s.parser }

func (s *PfEContext) INC() antlr.TerminalNode {
	return s.GetToken(Java20ParserINC, 0)
}

func (s *PfEContext) PfE() IPfEContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPfEContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPfEContext)
}

func (s *PfEContext) DEC() antlr.TerminalNode {
	return s.GetToken(Java20ParserDEC, 0)
}

func (s *PfEContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PfEContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PfEContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPfE(s)
	}
}

func (s *PfEContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPfE(s)
	}
}

func (p *Java20Parser) PfE() (localctx IPfEContext) {
	localctx = NewPfEContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, Java20ParserRULE_pfE)
	p.SetState(2673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserINC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2665)
			p.Match(Java20ParserINC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2667)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2666)
				p.PfE()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case Java20ParserDEC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2669)
			p.Match(Java20ParserDEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2671)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2670)
				p.PfE()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostIncrementExpressionContext is an interface to support dynamic dispatch.
type IPostIncrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpression() IPostfixExpressionContext
	INC() antlr.TerminalNode

	// IsPostIncrementExpressionContext differentiates from other interfaces.
	IsPostIncrementExpressionContext()
}

type PostIncrementExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostIncrementExpressionContext() *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_postIncrementExpression
	return p
}

func InitEmptyPostIncrementExpressionContext(p *PostIncrementExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_postIncrementExpression
}

func (*PostIncrementExpressionContext) IsPostIncrementExpressionContext() {}

func NewPostIncrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_postIncrementExpression

	return p
}

func (s *PostIncrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostIncrementExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostIncrementExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(Java20ParserINC, 0)
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

func (p *Java20Parser) PostIncrementExpression() (localctx IPostIncrementExpressionContext) {
	localctx = NewPostIncrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, Java20ParserRULE_postIncrementExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2675)
		p.PostfixExpression()
	}
	{
		p.SetState(2676)
		p.Match(Java20ParserINC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostDecrementExpressionContext is an interface to support dynamic dispatch.
type IPostDecrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpression() IPostfixExpressionContext
	DEC() antlr.TerminalNode

	// IsPostDecrementExpressionContext differentiates from other interfaces.
	IsPostDecrementExpressionContext()
}

type PostDecrementExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostDecrementExpressionContext() *PostDecrementExpressionContext {
	var p = new(PostDecrementExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_postDecrementExpression
	return p
}

func InitEmptyPostDecrementExpressionContext(p *PostDecrementExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_postDecrementExpression
}

func (*PostDecrementExpressionContext) IsPostDecrementExpressionContext() {}

func NewPostDecrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostDecrementExpressionContext {
	var p = new(PostDecrementExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_postDecrementExpression

	return p
}

func (s *PostDecrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostDecrementExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostDecrementExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(Java20ParserDEC, 0)
}

func (s *PostDecrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostDecrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPostDecrementExpression(s)
	}
}

func (s *PostDecrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPostDecrementExpression(s)
	}
}

func (p *Java20Parser) PostDecrementExpression() (localctx IPostDecrementExpressionContext) {
	localctx = NewPostDecrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, Java20ParserRULE_postDecrementExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2678)
		p.PostfixExpression()
	}
	{
		p.SetState(2679)
		p.Match(Java20ParserDEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PreIncrementExpression() IPreIncrementExpressionContext
	PreDecrementExpression() IPreDecrementExpressionContext
	ADD() antlr.TerminalNode
	UnaryExpression() IUnaryExpressionContext
	SUB() antlr.TerminalNode
	UnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinusContext

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unaryExpression
	return p
}

func InitEmptyUnaryExpressionContext(p *UnaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unaryExpression
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) PreIncrementExpression() IPreIncrementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreIncrementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreIncrementExpressionContext)
}

func (s *UnaryExpressionContext) PreDecrementExpression() IPreDecrementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreDecrementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreDecrementExpressionContext)
}

func (s *UnaryExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(Java20ParserADD, 0)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUB, 0)
}

func (s *UnaryExpressionContext) UnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionNotPlusMinusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionNotPlusMinusContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (p *Java20Parser) UnaryExpression() (localctx IUnaryExpressionContext) {
	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, Java20ParserRULE_unaryExpression)
	p.SetState(2688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserINC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2681)
			p.PreIncrementExpression()
		}

	case Java20ParserDEC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2682)
			p.PreDecrementExpression()
		}

	case Java20ParserADD:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2683)
			p.Match(Java20ParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2684)
			p.UnaryExpression()
		}

	case Java20ParserSUB:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2685)
			p.Match(Java20ParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2686)
			p.UnaryExpression()
		}

	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD, Java20ParserBOOLEAN, Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserNEW, Java20ParserSHORT, Java20ParserSUPER, Java20ParserSWITCH, Java20ParserTHIS, Java20ParserVOID, Java20ParserIntegerLiteral, Java20ParserFloatingPointLiteral, Java20ParserBooleanLiteral, Java20ParserCharacterLiteral, Java20ParserStringLiteral, Java20ParserTextBlock, Java20ParserNullLiteral, Java20ParserLPAREN, Java20ParserAT, Java20ParserBANG, Java20ParserTILDE, Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2687)
			p.UnaryExpressionNotPlusMinus()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreIncrementExpressionContext is an interface to support dynamic dispatch.
type IPreIncrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INC() antlr.TerminalNode
	UnaryExpression() IUnaryExpressionContext

	// IsPreIncrementExpressionContext differentiates from other interfaces.
	IsPreIncrementExpressionContext()
}

type PreIncrementExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreIncrementExpressionContext() *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_preIncrementExpression
	return p
}

func InitEmptyPreIncrementExpressionContext(p *PreIncrementExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_preIncrementExpression
}

func (*PreIncrementExpressionContext) IsPreIncrementExpressionContext() {}

func NewPreIncrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_preIncrementExpression

	return p
}

func (s *PreIncrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PreIncrementExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(Java20ParserINC, 0)
}

func (s *PreIncrementExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

func (p *Java20Parser) PreIncrementExpression() (localctx IPreIncrementExpressionContext) {
	localctx = NewPreIncrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, Java20ParserRULE_preIncrementExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2690)
		p.Match(Java20ParserINC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2691)
		p.UnaryExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreDecrementExpressionContext is an interface to support dynamic dispatch.
type IPreDecrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEC() antlr.TerminalNode
	UnaryExpression() IUnaryExpressionContext

	// IsPreDecrementExpressionContext differentiates from other interfaces.
	IsPreDecrementExpressionContext()
}

type PreDecrementExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreDecrementExpressionContext() *PreDecrementExpressionContext {
	var p = new(PreDecrementExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_preDecrementExpression
	return p
}

func InitEmptyPreDecrementExpressionContext(p *PreDecrementExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_preDecrementExpression
}

func (*PreDecrementExpressionContext) IsPreDecrementExpressionContext() {}

func NewPreDecrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreDecrementExpressionContext {
	var p = new(PreDecrementExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_preDecrementExpression

	return p
}

func (s *PreDecrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PreDecrementExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(Java20ParserDEC, 0)
}

func (s *PreDecrementExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *PreDecrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreDecrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterPreDecrementExpression(s)
	}
}

func (s *PreDecrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitPreDecrementExpression(s)
	}
}

func (p *Java20Parser) PreDecrementExpression() (localctx IPreDecrementExpressionContext) {
	localctx = NewPreDecrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, Java20ParserRULE_preDecrementExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2693)
		p.Match(Java20ParserDEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2694)
		p.UnaryExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExpressionNotPlusMinusContext is an interface to support dynamic dispatch.
type IUnaryExpressionNotPlusMinusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpression() IPostfixExpressionContext
	TILDE() antlr.TerminalNode
	UnaryExpression() IUnaryExpressionContext
	BANG() antlr.TerminalNode
	CastExpression() ICastExpressionContext
	SwitchExpression() ISwitchExpressionContext

	// IsUnaryExpressionNotPlusMinusContext differentiates from other interfaces.
	IsUnaryExpressionNotPlusMinusContext()
}

type UnaryExpressionNotPlusMinusContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionNotPlusMinusContext() *UnaryExpressionNotPlusMinusContext {
	var p = new(UnaryExpressionNotPlusMinusContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unaryExpressionNotPlusMinus
	return p
}

func InitEmptyUnaryExpressionNotPlusMinusContext(p *UnaryExpressionNotPlusMinusContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_unaryExpressionNotPlusMinus
}

func (*UnaryExpressionNotPlusMinusContext) IsUnaryExpressionNotPlusMinusContext() {}

func NewUnaryExpressionNotPlusMinusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionNotPlusMinusContext {
	var p = new(UnaryExpressionNotPlusMinusContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_unaryExpressionNotPlusMinus

	return p
}

func (s *UnaryExpressionNotPlusMinusContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionNotPlusMinusContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionNotPlusMinusContext) TILDE() antlr.TerminalNode {
	return s.GetToken(Java20ParserTILDE, 0)
}

func (s *UnaryExpressionNotPlusMinusContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionNotPlusMinusContext) BANG() antlr.TerminalNode {
	return s.GetToken(Java20ParserBANG, 0)
}

func (s *UnaryExpressionNotPlusMinusContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *UnaryExpressionNotPlusMinusContext) SwitchExpression() ISwitchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchExpressionContext)
}

func (s *UnaryExpressionNotPlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionNotPlusMinusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionNotPlusMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterUnaryExpressionNotPlusMinus(s)
	}
}

func (s *UnaryExpressionNotPlusMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitUnaryExpressionNotPlusMinus(s)
	}
}

func (p *Java20Parser) UnaryExpressionNotPlusMinus() (localctx IUnaryExpressionNotPlusMinusContext) {
	localctx = NewUnaryExpressionNotPlusMinusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, Java20ParserRULE_unaryExpressionNotPlusMinus)
	p.SetState(2703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2696)
			p.PostfixExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2697)
			p.Match(Java20ParserTILDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2698)
			p.UnaryExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2699)
			p.Match(Java20ParserBANG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2700)
			p.UnaryExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2701)
			p.CastExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2702)
			p.SwitchExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	PrimitiveType() IPrimitiveTypeContext
	RPAREN() antlr.TerminalNode
	UnaryExpression() IUnaryExpressionContext
	ReferenceType() IReferenceTypeContext
	UnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinusContext
	AllAdditionalBound() []IAdditionalBoundContext
	AdditionalBound(i int) IAdditionalBoundContext
	LambdaExpression() ILambdaExpressionContext

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_castExpression
	return p
}

func InitEmptyCastExpressionContext(p *CastExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_castExpression
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *CastExpressionContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *CastExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *CastExpressionContext) ReferenceType() IReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *CastExpressionContext) UnaryExpressionNotPlusMinus() IUnaryExpressionNotPlusMinusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionNotPlusMinusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionNotPlusMinusContext)
}

func (s *CastExpressionContext) AllAdditionalBound() []IAdditionalBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditionalBoundContext); ok {
			len++
		}
	}

	tst := make([]IAdditionalBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditionalBoundContext); ok {
			tst[i] = t.(IAdditionalBoundContext)
			i++
		}
	}

	return tst
}

func (s *CastExpressionContext) AdditionalBound(i int) IAdditionalBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditionalBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditionalBoundContext)
}

func (s *CastExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (p *Java20Parser) CastExpression() (localctx ICastExpressionContext) {
	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, Java20ParserRULE_castExpression)
	var _la int

	p.SetState(2732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2705)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2706)
			p.PrimitiveType()
		}
		{
			p.SetState(2707)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2708)
			p.UnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2710)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2711)
			p.ReferenceType()
		}
		p.SetState(2715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserBITAND {
			{
				p.SetState(2712)
				p.AdditionalBound()
			}

			p.SetState(2717)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2718)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2719)
			p.UnaryExpressionNotPlusMinus()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2721)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2722)
			p.ReferenceType()
		}
		p.SetState(2726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserBITAND {
			{
				p.SetState(2723)
				p.AdditionalBound()
			}

			p.SetState(2728)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2729)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2730)
			p.LambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnaryExpression() IUnaryExpressionContext
	MultiplicativeExpression() IMultiplicativeExpressionContext
	MUL() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_multiplicativeExpression
	return p
}

func InitEmptyMultiplicativeExpressionContext(p *MultiplicativeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_multiplicativeExpression
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *MultiplicativeExpressionContext) MultiplicativeExpression() IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *MultiplicativeExpressionContext) MUL() antlr.TerminalNode {
	return s.GetToken(Java20ParserMUL, 0)
}

func (s *MultiplicativeExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(Java20ParserDIV, 0)
}

func (s *MultiplicativeExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(Java20ParserMOD, 0)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *Java20Parser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	return p.multiplicativeExpression(0)
}

func (p *Java20Parser) multiplicativeExpression(_p int) (localctx IMultiplicativeExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 452
	p.EnterRecursionRule(localctx, 452, Java20ParserRULE_multiplicativeExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2735)
		p.UnaryExpression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2746)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMultiplicativeExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_multiplicativeExpression)
				p.SetState(2737)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(2738)
					p.Match(Java20ParserMUL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2739)
					p.UnaryExpression()
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_multiplicativeExpression)
				p.SetState(2740)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2741)
					p.Match(Java20ParserDIV)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2742)
					p.UnaryExpression()
				}

			case 3:
				localctx = NewMultiplicativeExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_multiplicativeExpression)
				p.SetState(2743)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2744)
					p.Match(Java20ParserMOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2745)
					p.UnaryExpression()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiplicativeExpression() IMultiplicativeExpressionContext
	AdditiveExpression() IAdditiveExpressionContext
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_additiveExpression
	return p
}

func InitEmptyAdditiveExpressionContext(p *AdditiveExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_additiveExpression
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) MultiplicativeExpression() IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AdditiveExpression() IAdditiveExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *AdditiveExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(Java20ParserADD, 0)
}

func (s *AdditiveExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUB, 0)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *Java20Parser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	return p.additiveExpression(0)
}

func (p *Java20Parser) additiveExpression(_p int) (localctx IAdditiveExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 454
	p.EnterRecursionRule(localctx, 454, Java20ParserRULE_additiveExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2752)
		p.multiplicativeExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) {
			case 1:
				localctx = NewAdditiveExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_additiveExpression)
				p.SetState(2754)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2755)
					p.Match(Java20ParserADD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2756)
					p.multiplicativeExpression(0)
				}

			case 2:
				localctx = NewAdditiveExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_additiveExpression)
				p.SetState(2757)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2758)
					p.Match(Java20ParserSUB)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2759)
					p.multiplicativeExpression(0)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftExpressionContext is an interface to support dynamic dispatch.
type IShiftExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AdditiveExpression() IAdditiveExpressionContext
	ShiftExpression() IShiftExpressionContext
	AllLT() []antlr.TerminalNode
	LT(i int) antlr.TerminalNode
	AllGT() []antlr.TerminalNode
	GT(i int) antlr.TerminalNode

	// IsShiftExpressionContext differentiates from other interfaces.
	IsShiftExpressionContext()
}

type ShiftExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftExpressionContext() *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_shiftExpression
	return p
}

func InitEmptyShiftExpressionContext(p *ShiftExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_shiftExpression
}

func (*ShiftExpressionContext) IsShiftExpressionContext() {}

func NewShiftExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_shiftExpression

	return p
}

func (s *ShiftExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExpressionContext) AdditiveExpression() IAdditiveExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ShiftExpressionContext) ShiftExpression() IShiftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExpressionContext)
}

func (s *ShiftExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserLT)
}

func (s *ShiftExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserLT, i)
}

func (s *ShiftExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserGT)
}

func (s *ShiftExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserGT, i)
}

func (s *ShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitShiftExpression(s)
	}
}

func (p *Java20Parser) ShiftExpression() (localctx IShiftExpressionContext) {
	return p.shiftExpression(0)
}

func (p *Java20Parser) shiftExpression(_p int) (localctx IShiftExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewShiftExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShiftExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 456
	p.EnterRecursionRule(localctx, 456, Java20ParserRULE_shiftExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2766)
		p.additiveExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2781)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext()) {
			case 1:
				localctx = NewShiftExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_shiftExpression)
				p.SetState(2768)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(2769)
					p.Match(Java20ParserLT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2770)
					p.Match(Java20ParserLT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2771)
					p.additiveExpression(0)
				}

			case 2:
				localctx = NewShiftExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_shiftExpression)
				p.SetState(2772)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2773)
					p.Match(Java20ParserGT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2774)
					p.Match(Java20ParserGT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2775)
					p.additiveExpression(0)
				}

			case 3:
				localctx = NewShiftExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_shiftExpression)
				p.SetState(2776)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2777)
					p.Match(Java20ParserGT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2778)
					p.Match(Java20ParserGT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2779)
					p.Match(Java20ParserGT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2780)
					p.additiveExpression(0)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2785)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationalExpressionContext is an interface to support dynamic dispatch.
type IRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ShiftExpression() IShiftExpressionContext
	RelationalExpression() IRelationalExpressionContext
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	INSTANCEOF() antlr.TerminalNode
	ReferenceType() IReferenceTypeContext
	Pattern() IPatternContext

	// IsRelationalExpressionContext differentiates from other interfaces.
	IsRelationalExpressionContext()
}

type RelationalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalExpressionContext() *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_relationalExpression
	return p
}

func InitEmptyRelationalExpressionContext(p *RelationalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_relationalExpression
}

func (*RelationalExpressionContext) IsRelationalExpressionContext() {}

func NewRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_relationalExpression

	return p
}

func (s *RelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalExpressionContext) ShiftExpression() IShiftExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExpressionContext)
}

func (s *RelationalExpressionContext) RelationalExpression() IRelationalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *RelationalExpressionContext) LT() antlr.TerminalNode {
	return s.GetToken(Java20ParserLT, 0)
}

func (s *RelationalExpressionContext) GT() antlr.TerminalNode {
	return s.GetToken(Java20ParserGT, 0)
}

func (s *RelationalExpressionContext) LE() antlr.TerminalNode {
	return s.GetToken(Java20ParserLE, 0)
}

func (s *RelationalExpressionContext) GE() antlr.TerminalNode {
	return s.GetToken(Java20ParserGE, 0)
}

func (s *RelationalExpressionContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(Java20ParserINSTANCEOF, 0)
}

func (s *RelationalExpressionContext) ReferenceType() IReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceTypeContext)
}

func (s *RelationalExpressionContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (p *Java20Parser) RelationalExpression() (localctx IRelationalExpressionContext) {
	return p.relationalExpression(0)
}

func (p *Java20Parser) relationalExpression(_p int) (localctx IRelationalExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRelationalExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationalExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 458
	p.EnterRecursionRule(localctx, 458, Java20ParserRULE_relationalExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2787)
		p.shiftExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2807)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 342, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_relationalExpression)
				p.SetState(2789)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(2790)
					p.Match(Java20ParserLT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2791)
					p.shiftExpression(0)
				}

			case 2:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_relationalExpression)
				p.SetState(2792)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(2793)
					p.Match(Java20ParserGT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2794)
					p.shiftExpression(0)
				}

			case 3:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_relationalExpression)
				p.SetState(2795)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(2796)
					p.Match(Java20ParserLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2797)
					p.shiftExpression(0)
				}

			case 4:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_relationalExpression)
				p.SetState(2798)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2799)
					p.Match(Java20ParserGE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2800)
					p.shiftExpression(0)
				}

			case 5:
				localctx = NewRelationalExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_relationalExpression)
				p.SetState(2801)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2802)
					p.Match(Java20ParserINSTANCEOF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2805)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(2803)
						p.ReferenceType()
					}

				case 2:
					{
						p.SetState(2804)
						p.Pattern()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExpressionContext is an interface to support dynamic dispatch.
type IEqualityExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationalExpression() IRelationalExpressionContext
	EqualityExpression() IEqualityExpressionContext
	EQUAL() antlr.TerminalNode
	NOTEQUAL() antlr.TerminalNode

	// IsEqualityExpressionContext differentiates from other interfaces.
	IsEqualityExpressionContext()
}

type EqualityExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityExpressionContext() *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_equalityExpression
	return p
}

func InitEmptyEqualityExpressionContext(p *EqualityExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_equalityExpression
}

func (*EqualityExpressionContext) IsEqualityExpressionContext() {}

func NewEqualityExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_equalityExpression

	return p
}

func (s *EqualityExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExpressionContext) RelationalExpression() IRelationalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *EqualityExpressionContext) EqualityExpression() IEqualityExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExpressionContext)
}

func (s *EqualityExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Java20ParserEQUAL, 0)
}

func (s *EqualityExpressionContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(Java20ParserNOTEQUAL, 0)
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (p *Java20Parser) EqualityExpression() (localctx IEqualityExpressionContext) {
	return p.equalityExpression(0)
}

func (p *Java20Parser) equalityExpression(_p int) (localctx IEqualityExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewEqualityExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEqualityExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 460
	p.EnterRecursionRule(localctx, 460, Java20ParserRULE_equalityExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2813)
		p.relationalExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2821)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) {
			case 1:
				localctx = NewEqualityExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_equalityExpression)
				p.SetState(2815)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(2816)
					p.Match(Java20ParserEQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2817)
					p.relationalExpression(0)
				}

			case 2:
				localctx = NewEqualityExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_equalityExpression)
				p.SetState(2818)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(2819)
					p.Match(Java20ParserNOTEQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2820)
					p.relationalExpression(0)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EqualityExpression() IEqualityExpressionContext
	AndExpression() IAndExpressionContext
	BITAND() antlr.TerminalNode

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_andExpression
	return p
}

func InitEmptyAndExpressionContext(p *AndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_andExpression
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) EqualityExpression() IEqualityExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExpressionContext)
}

func (s *AndExpressionContext) AndExpression() IAndExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *AndExpressionContext) BITAND() antlr.TerminalNode {
	return s.GetToken(Java20ParserBITAND, 0)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (p *Java20Parser) AndExpression() (localctx IAndExpressionContext) {
	return p.andExpression(0)
}

func (p *Java20Parser) andExpression(_p int) (localctx IAndExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAndExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 462
	p.EnterRecursionRule(localctx, 462, Java20ParserRULE_andExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2827)
		p.equalityExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAndExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_andExpression)
			p.SetState(2829)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2830)
				p.Match(Java20ParserBITAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2831)
				p.equalityExpression(0)
			}

		}
		p.SetState(2836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExclusiveOrExpressionContext is an interface to support dynamic dispatch.
type IExclusiveOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AndExpression() IAndExpressionContext
	ExclusiveOrExpression() IExclusiveOrExpressionContext
	CARET() antlr.TerminalNode

	// IsExclusiveOrExpressionContext differentiates from other interfaces.
	IsExclusiveOrExpressionContext()
}

type ExclusiveOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveOrExpressionContext() *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_exclusiveOrExpression
	return p
}

func InitEmptyExclusiveOrExpressionContext(p *ExclusiveOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_exclusiveOrExpression
}

func (*ExclusiveOrExpressionContext) IsExclusiveOrExpressionContext() {}

func NewExclusiveOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_exclusiveOrExpression

	return p
}

func (s *ExclusiveOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusiveOrExpressionContext) AndExpression() IAndExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *ExclusiveOrExpressionContext) ExclusiveOrExpression() IExclusiveOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclusiveOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclusiveOrExpressionContext)
}

func (s *ExclusiveOrExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(Java20ParserCARET, 0)
}

func (s *ExclusiveOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusiveOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterExclusiveOrExpression(s)
	}
}

func (s *ExclusiveOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitExclusiveOrExpression(s)
	}
}

func (p *Java20Parser) ExclusiveOrExpression() (localctx IExclusiveOrExpressionContext) {
	return p.exclusiveOrExpression(0)
}

func (p *Java20Parser) exclusiveOrExpression(_p int) (localctx IExclusiveOrExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExclusiveOrExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExclusiveOrExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 464
	p.EnterRecursionRule(localctx, 464, Java20ParserRULE_exclusiveOrExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2838)
		p.andExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExclusiveOrExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_exclusiveOrExpression)
			p.SetState(2840)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2841)
				p.Match(Java20ParserCARET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2842)
				p.andExpression(0)
			}

		}
		p.SetState(2847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInclusiveOrExpressionContext is an interface to support dynamic dispatch.
type IInclusiveOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExclusiveOrExpression() IExclusiveOrExpressionContext
	InclusiveOrExpression() IInclusiveOrExpressionContext
	BITOR() antlr.TerminalNode

	// IsInclusiveOrExpressionContext differentiates from other interfaces.
	IsInclusiveOrExpressionContext()
}

type InclusiveOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclusiveOrExpressionContext() *InclusiveOrExpressionContext {
	var p = new(InclusiveOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_inclusiveOrExpression
	return p
}

func InitEmptyInclusiveOrExpressionContext(p *InclusiveOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_inclusiveOrExpression
}

func (*InclusiveOrExpressionContext) IsInclusiveOrExpressionContext() {}

func NewInclusiveOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InclusiveOrExpressionContext {
	var p = new(InclusiveOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_inclusiveOrExpression

	return p
}

func (s *InclusiveOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InclusiveOrExpressionContext) ExclusiveOrExpression() IExclusiveOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclusiveOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclusiveOrExpressionContext)
}

func (s *InclusiveOrExpressionContext) InclusiveOrExpression() IInclusiveOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInclusiveOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInclusiveOrExpressionContext)
}

func (s *InclusiveOrExpressionContext) BITOR() antlr.TerminalNode {
	return s.GetToken(Java20ParserBITOR, 0)
}

func (s *InclusiveOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InclusiveOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InclusiveOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterInclusiveOrExpression(s)
	}
}

func (s *InclusiveOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitInclusiveOrExpression(s)
	}
}

func (p *Java20Parser) InclusiveOrExpression() (localctx IInclusiveOrExpressionContext) {
	return p.inclusiveOrExpression(0)
}

func (p *Java20Parser) inclusiveOrExpression(_p int) (localctx IInclusiveOrExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewInclusiveOrExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInclusiveOrExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 466
	p.EnterRecursionRule(localctx, 466, Java20ParserRULE_inclusiveOrExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2849)
		p.exclusiveOrExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInclusiveOrExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_inclusiveOrExpression)
			p.SetState(2851)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2852)
				p.Match(Java20ParserBITOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2853)
				p.exclusiveOrExpression(0)
			}

		}
		p.SetState(2858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalAndExpressionContext is an interface to support dynamic dispatch.
type IConditionalAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InclusiveOrExpression() IInclusiveOrExpressionContext
	ConditionalAndExpression() IConditionalAndExpressionContext
	AND() antlr.TerminalNode

	// IsConditionalAndExpressionContext differentiates from other interfaces.
	IsConditionalAndExpressionContext()
}

type ConditionalAndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalAndExpressionContext() *ConditionalAndExpressionContext {
	var p = new(ConditionalAndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_conditionalAndExpression
	return p
}

func InitEmptyConditionalAndExpressionContext(p *ConditionalAndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_conditionalAndExpression
}

func (*ConditionalAndExpressionContext) IsConditionalAndExpressionContext() {}

func NewConditionalAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalAndExpressionContext {
	var p = new(ConditionalAndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_conditionalAndExpression

	return p
}

func (s *ConditionalAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalAndExpressionContext) InclusiveOrExpression() IInclusiveOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInclusiveOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInclusiveOrExpressionContext)
}

func (s *ConditionalAndExpressionContext) ConditionalAndExpression() IConditionalAndExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalAndExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalAndExpressionContext)
}

func (s *ConditionalAndExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(Java20ParserAND, 0)
}

func (s *ConditionalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConditionalAndExpression(s)
	}
}

func (s *ConditionalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConditionalAndExpression(s)
	}
}

func (p *Java20Parser) ConditionalAndExpression() (localctx IConditionalAndExpressionContext) {
	return p.conditionalAndExpression(0)
}

func (p *Java20Parser) conditionalAndExpression(_p int) (localctx IConditionalAndExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewConditionalAndExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConditionalAndExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 468
	p.EnterRecursionRule(localctx, 468, Java20ParserRULE_conditionalAndExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2860)
		p.inclusiveOrExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewConditionalAndExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_conditionalAndExpression)
			p.SetState(2862)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2863)
				p.Match(Java20ParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2864)
				p.inclusiveOrExpression(0)
			}

		}
		p.SetState(2869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalOrExpressionContext is an interface to support dynamic dispatch.
type IConditionalOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalAndExpression() IConditionalAndExpressionContext
	ConditionalOrExpression() IConditionalOrExpressionContext
	OR() antlr.TerminalNode

	// IsConditionalOrExpressionContext differentiates from other interfaces.
	IsConditionalOrExpressionContext()
}

type ConditionalOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalOrExpressionContext() *ConditionalOrExpressionContext {
	var p = new(ConditionalOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_conditionalOrExpression
	return p
}

func InitEmptyConditionalOrExpressionContext(p *ConditionalOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_conditionalOrExpression
}

func (*ConditionalOrExpressionContext) IsConditionalOrExpressionContext() {}

func NewConditionalOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalOrExpressionContext {
	var p = new(ConditionalOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_conditionalOrExpression

	return p
}

func (s *ConditionalOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalOrExpressionContext) ConditionalAndExpression() IConditionalAndExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalAndExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalAndExpressionContext)
}

func (s *ConditionalOrExpressionContext) ConditionalOrExpression() IConditionalOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalOrExpressionContext)
}

func (s *ConditionalOrExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(Java20ParserOR, 0)
}

func (s *ConditionalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConditionalOrExpression(s)
	}
}

func (s *ConditionalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConditionalOrExpression(s)
	}
}

func (p *Java20Parser) ConditionalOrExpression() (localctx IConditionalOrExpressionContext) {
	return p.conditionalOrExpression(0)
}

func (p *Java20Parser) conditionalOrExpression(_p int) (localctx IConditionalOrExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewConditionalOrExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConditionalOrExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 470
	p.EnterRecursionRule(localctx, 470, Java20ParserRULE_conditionalOrExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2871)
		p.conditionalAndExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewConditionalOrExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, Java20ParserRULE_conditionalOrExpression)
			p.SetState(2873)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2874)
				p.Match(Java20ParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2875)
				p.conditionalAndExpression(0)
			}

		}
		p.SetState(2880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalOrExpression() IConditionalOrExpressionContext
	QUESTION() antlr.TerminalNode
	Expression() IExpressionContext
	COLON() antlr.TerminalNode
	ConditionalExpression() IConditionalExpressionContext
	LambdaExpression() ILambdaExpressionContext

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_conditionalExpression
	return p
}

func InitEmptyConditionalExpressionContext(p *ConditionalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_conditionalExpression
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) ConditionalOrExpression() IConditionalOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalOrExpressionContext)
}

func (s *ConditionalExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(Java20ParserQUESTION, 0)
}

func (s *ConditionalExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(Java20ParserCOLON, 0)
}

func (s *ConditionalExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ConditionalExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}

func (p *Java20Parser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, Java20ParserRULE_conditionalExpression)
	p.SetState(2894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2881)
			p.conditionalOrExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2882)
			p.conditionalOrExpression(0)
		}
		{
			p.SetState(2883)
			p.Match(Java20ParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2884)
			p.Expression()
		}
		{
			p.SetState(2885)
			p.Match(Java20ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2886)
			p.ConditionalExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2888)
			p.conditionalOrExpression(0)
		}
		{
			p.SetState(2889)
			p.Match(Java20ParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2890)
			p.Expression()
		}
		{
			p.SetState(2891)
			p.Match(Java20ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2892)
			p.LambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExpressionContext is an interface to support dynamic dispatch.
type IAssignmentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalExpression() IConditionalExpressionContext
	Assignment() IAssignmentContext

	// IsAssignmentExpressionContext differentiates from other interfaces.
	IsAssignmentExpressionContext()
}

type AssignmentExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionContext() *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assignmentExpression
	return p
}

func InitEmptyAssignmentExpressionContext(p *AssignmentExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assignmentExpression
}

func (*AssignmentExpressionContext) IsAssignmentExpressionContext() {}

func NewAssignmentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_assignmentExpression

	return p
}

func (s *AssignmentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *AssignmentExpressionContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (p *Java20Parser) AssignmentExpression() (localctx IAssignmentExpressionContext) {
	localctx = NewAssignmentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, Java20ParserRULE_assignmentExpression)
	p.SetState(2898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2896)
			p.ConditionalExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2897)
			p.Assignment()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftHandSide() ILeftHandSideContext
	AssignmentOperator() IAssignmentOperatorContext
	Expression() IExpressionContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) LeftHandSide() ILeftHandSideContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeftHandSideContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeftHandSideContext)
}

func (s *AssignmentContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *Java20Parser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, Java20ParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2900)
		p.LeftHandSide()
	}
	{
		p.SetState(2901)
		p.AssignmentOperator()
	}
	{
		p.SetState(2902)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeftHandSideContext is an interface to support dynamic dispatch.
type ILeftHandSideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionName() IExpressionNameContext
	FieldAccess() IFieldAccessContext
	ArrayAccess() IArrayAccessContext

	// IsLeftHandSideContext differentiates from other interfaces.
	IsLeftHandSideContext()
}

type LeftHandSideContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeftHandSideContext() *LeftHandSideContext {
	var p = new(LeftHandSideContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_leftHandSide
	return p
}

func InitEmptyLeftHandSideContext(p *LeftHandSideContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_leftHandSide
}

func (*LeftHandSideContext) IsLeftHandSideContext() {}

func NewLeftHandSideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeftHandSideContext {
	var p = new(LeftHandSideContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_leftHandSide

	return p
}

func (s *LeftHandSideContext) GetParser() antlr.Parser { return s.parser }

func (s *LeftHandSideContext) ExpressionName() IExpressionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionNameContext)
}

func (s *LeftHandSideContext) FieldAccess() IFieldAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldAccessContext)
}

func (s *LeftHandSideContext) ArrayAccess() IArrayAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayAccessContext)
}

func (s *LeftHandSideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftHandSideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeftHandSideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLeftHandSide(s)
	}
}

func (s *LeftHandSideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLeftHandSide(s)
	}
}

func (p *Java20Parser) LeftHandSide() (localctx ILeftHandSideContext) {
	localctx = NewLeftHandSideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, Java20ParserRULE_leftHandSide)
	p.SetState(2907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2904)
			p.ExpressionName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2905)
			p.FieldAccess()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2906)
			p.ArrayAccess()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	MUL_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	MOD_ASSIGN() antlr.TerminalNode
	ADD_ASSIGN() antlr.TerminalNode
	SUB_ASSIGN() antlr.TerminalNode
	LSHIFT_ASSIGN() antlr.TerminalNode
	RSHIFT_ASSIGN() antlr.TerminalNode
	URSHIFT_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	XOR_ASSIGN() antlr.TerminalNode
	OR_ASSIGN() antlr.TerminalNode

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assignmentOperator
	return p
}

func InitEmptyAssignmentOperatorContext(p *AssignmentOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_assignmentOperator
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserASSIGN, 0)
}

func (s *AssignmentOperatorContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserMUL_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserDIV_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserMOD_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserADD_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserSUB_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserURSHIFT_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserAND_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserXOR_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(Java20ParserOR_ASSIGN, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *Java20Parser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, Java20ParserRULE_assignmentOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2909)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&34342961153) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaParameters() ILambdaParametersContext
	ARROW() antlr.TerminalNode
	LambdaBody() ILambdaBodyContext

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaParameters() ILambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(Java20ParserARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *Java20Parser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, Java20ParserRULE_lambdaExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2911)
		p.LambdaParameters()
	}
	{
		p.SetState(2912)
		p.Match(Java20ParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2913)
		p.LambdaBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LambdaParameterList() ILambdaParameterListContext
	Identifier() IIdentifierContext

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameters
	return p
}

func InitEmptyLambdaParametersContext(p *LambdaParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameters
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *LambdaParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *LambdaParametersContext) LambdaParameterList() ILambdaParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParameterListContext)
}

func (s *LambdaParametersContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *Java20Parser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, Java20ParserRULE_lambdaParameters)
	var _la int

	p.SetState(2921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2915)
			p.Match(Java20ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18102533424938990) != 0) || _la == Java20ParserAT || _la == Java20ParserIdentifier {
			{
				p.SetState(2916)
				p.LambdaParameterList()
			}

		}
		{
			p.SetState(2919)
			p.Match(Java20ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD, Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2920)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParameterListContext is an interface to support dynamic dispatch.
type ILambdaParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLambdaParameter() []ILambdaParameterContext
	LambdaParameter(i int) ILambdaParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsLambdaParameterListContext differentiates from other interfaces.
	IsLambdaParameterListContext()
}

type LambdaParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParameterListContext() *LambdaParameterListContext {
	var p = new(LambdaParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameterList
	return p
}

func InitEmptyLambdaParameterListContext(p *LambdaParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameterList
}

func (*LambdaParameterListContext) IsLambdaParameterListContext() {}

func NewLambdaParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParameterListContext {
	var p = new(LambdaParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_lambdaParameterList

	return p
}

func (s *LambdaParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParameterListContext) AllLambdaParameter() []ILambdaParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaParameterContext); ok {
			len++
		}
	}

	tst := make([]ILambdaParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaParameterContext); ok {
			tst[i] = t.(ILambdaParameterContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParameterListContext) LambdaParameter(i int) ILambdaParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParameterContext)
}

func (s *LambdaParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(Java20ParserCOMMA)
}

func (s *LambdaParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(Java20ParserCOMMA, i)
}

func (s *LambdaParameterListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParameterListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLambdaParameterList(s)
	}
}

func (s *LambdaParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLambdaParameterList(s)
	}
}

func (p *Java20Parser) LambdaParameterList() (localctx ILambdaParameterListContext) {
	localctx = NewLambdaParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, Java20ParserRULE_lambdaParameterList)
	var _la int

	p.SetState(2939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2923)
			p.LambdaParameter()
		}
		p.SetState(2928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserCOMMA {
			{
				p.SetState(2924)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2925)
				p.LambdaParameter()
			}

			p.SetState(2930)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2931)
			p.Identifier()
		}
		p.SetState(2936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserCOMMA {
			{
				p.SetState(2932)
				p.Match(Java20ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2933)
				p.Identifier()
			}

			p.SetState(2938)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParameterContext is an interface to support dynamic dispatch.
type ILambdaParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaParameterType() ILambdaParameterTypeContext
	VariableDeclaratorId() IVariableDeclaratorIdContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	VariableArityParameter() IVariableArityParameterContext

	// IsLambdaParameterContext differentiates from other interfaces.
	IsLambdaParameterContext()
}

type LambdaParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParameterContext() *LambdaParameterContext {
	var p = new(LambdaParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameter
	return p
}

func InitEmptyLambdaParameterContext(p *LambdaParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameter
}

func (*LambdaParameterContext) IsLambdaParameterContext() {}

func NewLambdaParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParameterContext {
	var p = new(LambdaParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_lambdaParameter

	return p
}

func (s *LambdaParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParameterContext) LambdaParameterType() ILambdaParameterTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParameterTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParameterTypeContext)
}

func (s *LambdaParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *LambdaParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LambdaParameterContext) VariableArityParameter() IVariableArityParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableArityParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableArityParameterContext)
}

func (s *LambdaParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLambdaParameter(s)
	}
}

func (s *LambdaParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLambdaParameter(s)
	}
}

func (p *Java20Parser) LambdaParameter() (localctx ILambdaParameterContext) {
	localctx = NewLambdaParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, Java20ParserRULE_lambdaParameter)
	var _la int

	p.SetState(2951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Java20ParserFINAL || _la == Java20ParserAT {
			{
				p.SetState(2941)
				p.VariableModifier()
			}

			p.SetState(2946)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2947)
			p.LambdaParameterType()
		}
		{
			p.SetState(2948)
			p.VariableDeclaratorId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2950)
			p.VariableArityParameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParameterTypeContext is an interface to support dynamic dispatch.
type ILambdaParameterTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnannType() IUnannTypeContext
	VAR() antlr.TerminalNode

	// IsLambdaParameterTypeContext differentiates from other interfaces.
	IsLambdaParameterTypeContext()
}

type LambdaParameterTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParameterTypeContext() *LambdaParameterTypeContext {
	var p = new(LambdaParameterTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameterType
	return p
}

func InitEmptyLambdaParameterTypeContext(p *LambdaParameterTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaParameterType
}

func (*LambdaParameterTypeContext) IsLambdaParameterTypeContext() {}

func NewLambdaParameterTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParameterTypeContext {
	var p = new(LambdaParameterTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_lambdaParameterType

	return p
}

func (s *LambdaParameterTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParameterTypeContext) UnannType() IUnannTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnannTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnannTypeContext)
}

func (s *LambdaParameterTypeContext) VAR() antlr.TerminalNode {
	return s.GetToken(Java20ParserVAR, 0)
}

func (s *LambdaParameterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParameterTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParameterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLambdaParameterType(s)
	}
}

func (s *LambdaParameterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLambdaParameterType(s)
	}
}

func (p *Java20Parser) LambdaParameterType() (localctx ILambdaParameterTypeContext) {
	localctx = NewLambdaParameterTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, Java20ParserRULE_lambdaParameterType)
	p.SetState(2955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2953)
			p.UnannType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2954)
			p.Match(Java20ParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Block() IBlockContext

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaBody
	return p
}

func InitEmptyLambdaBodyContext(p *LambdaBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_lambdaBody
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterLambdaBody(s)
	}
}

func (s *LambdaBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitLambdaBody(s)
	}
}

func (p *Java20Parser) LambdaBody() (localctx ILambdaBodyContext) {
	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, Java20ParserRULE_lambdaBody)
	p.SetState(2959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Java20ParserEXPORTS, Java20ParserMODULE, Java20ParserNONSEALED, Java20ParserOPEN, Java20ParserOPENS, Java20ParserPERMITS, Java20ParserPROVIDES, Java20ParserRECORD, Java20ParserREQUIRES, Java20ParserSEALED, Java20ParserTO, Java20ParserTRANSITIVE, Java20ParserUSES, Java20ParserVAR, Java20ParserWITH, Java20ParserYIELD, Java20ParserBOOLEAN, Java20ParserBYTE, Java20ParserCHAR, Java20ParserDOUBLE, Java20ParserFLOAT, Java20ParserINT, Java20ParserLONG, Java20ParserNEW, Java20ParserSHORT, Java20ParserSUPER, Java20ParserSWITCH, Java20ParserTHIS, Java20ParserVOID, Java20ParserIntegerLiteral, Java20ParserFloatingPointLiteral, Java20ParserBooleanLiteral, Java20ParserCharacterLiteral, Java20ParserStringLiteral, Java20ParserTextBlock, Java20ParserNullLiteral, Java20ParserLPAREN, Java20ParserAT, Java20ParserBANG, Java20ParserTILDE, Java20ParserINC, Java20ParserDEC, Java20ParserADD, Java20ParserSUB, Java20ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2957)
			p.Expression()
		}

	case Java20ParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2958)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchExpressionContext is an interface to support dynamic dispatch.
type ISwitchExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	SwitchBlock() ISwitchBlockContext

	// IsSwitchExpressionContext differentiates from other interfaces.
	IsSwitchExpressionContext()
}

type SwitchExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchExpressionContext() *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchExpression
	return p
}

func InitEmptySwitchExpressionContext(p *SwitchExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_switchExpression
}

func (*SwitchExpressionContext) IsSwitchExpressionContext() {}

func NewSwitchExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_switchExpression

	return p
}

func (s *SwitchExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchExpressionContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(Java20ParserSWITCH, 0)
}

func (s *SwitchExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserLPAREN, 0)
}

func (s *SwitchExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(Java20ParserRPAREN, 0)
}

func (s *SwitchExpressionContext) SwitchBlock() ISwitchBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockContext)
}

func (s *SwitchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterSwitchExpression(s)
	}
}

func (s *SwitchExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitSwitchExpression(s)
	}
}

func (p *Java20Parser) SwitchExpression() (localctx ISwitchExpressionContext) {
	localctx = NewSwitchExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, Java20ParserRULE_switchExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2961)
		p.Match(Java20ParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2962)
		p.Match(Java20ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2963)
		p.Expression()
	}
	{
		p.SetState(2964)
		p.Match(Java20ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2965)
		p.SwitchBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantExpressionContext is an interface to support dynamic dispatch.
type IConstantExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsConstantExpressionContext differentiates from other interfaces.
	IsConstantExpressionContext()
}

type ConstantExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantExpressionContext() *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constantExpression
	return p
}

func InitEmptyConstantExpressionContext(p *ConstantExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Java20ParserRULE_constantExpression
}

func (*ConstantExpressionContext) IsConstantExpressionContext() {}

func NewConstantExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Java20ParserRULE_constantExpression

	return p
}

func (s *ConstantExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstantExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.EnterConstantExpression(s)
	}
}

func (s *ConstantExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Java20ParserListener); ok {
		listenerT.ExitConstantExpression(s)
	}
}

func (p *Java20Parser) ConstantExpression() (localctx IConstantExpressionContext) {
	localctx = NewConstantExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, Java20ParserRULE_constantExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2967)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *Java20Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 226:
		var t *MultiplicativeExpressionContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExpressionContext)
		}
		return p.MultiplicativeExpression_Sempred(t, predIndex)

	case 227:
		var t *AdditiveExpressionContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExpressionContext)
		}
		return p.AdditiveExpression_Sempred(t, predIndex)

	case 228:
		var t *ShiftExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ShiftExpressionContext)
		}
		return p.ShiftExpression_Sempred(t, predIndex)

	case 229:
		var t *RelationalExpressionContext = nil
		if localctx != nil {
			t = localctx.(*RelationalExpressionContext)
		}
		return p.RelationalExpression_Sempred(t, predIndex)

	case 230:
		var t *EqualityExpressionContext = nil
		if localctx != nil {
			t = localctx.(*EqualityExpressionContext)
		}
		return p.EqualityExpression_Sempred(t, predIndex)

	case 231:
		var t *AndExpressionContext = nil
		if localctx != nil {
			t = localctx.(*AndExpressionContext)
		}
		return p.AndExpression_Sempred(t, predIndex)

	case 232:
		var t *ExclusiveOrExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExclusiveOrExpressionContext)
		}
		return p.ExclusiveOrExpression_Sempred(t, predIndex)

	case 233:
		var t *InclusiveOrExpressionContext = nil
		if localctx != nil {
			t = localctx.(*InclusiveOrExpressionContext)
		}
		return p.InclusiveOrExpression_Sempred(t, predIndex)

	case 234:
		var t *ConditionalAndExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ConditionalAndExpressionContext)
		}
		return p.ConditionalAndExpression_Sempred(t, predIndex)

	case 235:
		var t *ConditionalOrExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ConditionalOrExpressionContext)
		}
		return p.ConditionalOrExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Java20Parser) MultiplicativeExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) AdditiveExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) ShiftExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) RelationalExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) EqualityExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) AndExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) ExclusiveOrExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) InclusiveOrExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) ConditionalAndExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Java20Parser) ConditionalOrExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 19:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
